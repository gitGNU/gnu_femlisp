@node Reference manual, Copyright, FAQ, Top
@chapter Reference manual

@menu
* Package FL.UTILITIES::
* Package FL.MACROS::
* Package FL.DEBUG::
* Package FL.DEMO::
* Package FL.TESTS::
* Package FL.PORT::
* Package FL.AMOP::
* Package FL.ALIEN::
* Package FL.PARALLEL::
* Package FL.MATLISP::
* Package FL.FUNCTION::
* Package FL.MESH::
* Package FL.PROBLEM::
* Package FL.CDR::
* Package FL.ELLSYS::
* Package FL.ELASTICITY::
* Package FL.NAVIER-STOKES::
* Package FL.DISCRETIZATION::
* Package FL.ELLSYS-FE::
* Package FL.ELASTICITY-FE::
* Package FL.NAVIER-STOKES-FE::
* Package FL.ITERATION::
* Package FL.MULTIGRID::
* Package FL.GEOMG::
* Package FL.STRATEGY::
* Package FL.GRAPHIC::
* Package FL.PLOT::
* Package FL.DOMAINS::
* Package FL.APPLICATION::
* Package DDO::
* Package DDO-FEMLISP::
@end menu

@node Package FL.UTILITIES, Package FL.MACROS, Reference manual, Reference manual
@section Package FL.UTILITIES

This package contains generally useful utility functions.  Several of
those functions were taken from @cite{(Graham 1996)}, the SANS function was
contributed to the @cite{comp.lang.lisp} newsgroup by Erik Naggum.

@anchor{fun-fl.utilities-add-hook}
@deffn Function ADD-HOOK @var{FUNCTION-NAME} @var{HOOK-NAME} @var{HOOK-FUNCTION}
@findex ADD-HOOK
Add a hook with name @arg{hook-name} to the hooks for @arg{function-name}.
@end deffn

@anchor{fun-fl.utilities-array-for-each}
@deffn Function ARRAY-FOR-EACH @var{FUNC} &REST @var{ARRAYS}
@findex ARRAY-FOR-EACH
Calls @arg{func} on all element tuples of the array arguments.
@end deffn

@anchor{fun-fl.utilities-blackboard}
@deffn Function BLACKBOARD &REST @var{ITEMS}
@findex BLACKBOARD
Make the property list supplied in @arg{items} into a blackboard.
Copies @arg{items} to make sure that no literal list is modified.
@end deffn

@anchor{class-fl.utilities-blackboard}
@deftp Class BLACKBOARD
@tindex BLACKBOARD
A blackboard where data items can be put and extracted using the
function @code{GETBB}.

Direct slots:
@itemize
@item ITEMS: A property list of items on the blackboard.
@end itemize
@end deftp

@anchor{fun-fl.utilities-box}
@deffn Function BOX @var{OBJECT}
@findex BOX
Boxes an object.
@end deffn

@anchor{fun-fl.utilities-call-hooks}
@deffn Function CALL-HOOKS @var{FUNCTION-NAME} @var{OBJECT} &REST @var{ARGS}
@findex CALL-HOOKS
Call all hooks defined for @arg{function-name} on @arg{object} and
returns @arg{object}.
@end deffn

@anchor{fun-fl.utilities-check}
@deffn Function CHECK @var{OBJ}
@findex CHECK
Checks the data structure of @arg{obj}.
@end deffn

@anchor{fun-fl.utilities-check-properties}
@deffn Function CHECK-PROPERTIES @var{PLACE} @var{PROPERTIES}
@findex CHECK-PROPERTIES
Checks if all of the @arg{properties} are in the property list
@arg{place}.
@end deffn

@anchor{fun-fl.utilities-common-lisp-speed}
@deffn Function COMMON-LISP-SPEED &KEY (@var{MEMORY-WEIGHT} 0.5)
@findex COMMON-LISP-SPEED
Returns the speed which should be characteristic for the setting
determined by @arg{memory-weight}.  If this argument is 0.0
it means that all operations should be inside cache memory
whereas 1.0 means that the operation are restricted by
memory bandwidth available.
@end deffn

@anchor{fun-fl.utilities-compose}
@deffn Function COMPOSE &REST @var{FUNCTIONS}
@findex COMPOSE
Returns the composition of @arg{functions}.
@end deffn

@anchor{fun-fl.utilities-compose-2}
@deffn Function COMPOSE-2 @var{F} @var{G}
@findex COMPOSE-2
Composes two function objects @arg{f} and @arg{g}.
@end deffn

@anchor{fun-fl.utilities-concept-documentation}
@deffn Function CONCEPT-DOCUMENTATION @var{DOCSTRING}
@findex CONCEPT-DOCUMENTATION
Documents a certain concept.
@end deffn

@anchor{fun-fl.utilities-constant-vector}
@deffn Function CONSTANT-VECTOR @var{DIM} @var{VALUE}
@findex CONSTANT-VECTOR
Returns a uniform constant vector of which all elements are @arg{value}.
@end deffn

@anchor{fun-fl.utilities-copy-hash-table}
@deffn Function COPY-HASH-TABLE @var{HASH-TABLE}
@findex COPY-HASH-TABLE
Copy @arg{hash-table}.
@end deffn

@anchor{fun-fl.utilities-copy-slots}
@deffn Function COPY-SLOTS @var{OBJ1} @var{OBJ2} @var{SLOTS}
@findex COPY-SLOTS
Initializes the slots named in @arg{slots} from @arg{obj2} to
  @arg{obj1}.  Returns @arg{obj1}.
@end deffn

@anchor{fun-fl.utilities-curry}
@deffn Function CURRY @var{FUNC} &REST @var{ARGS}
@findex CURRY
Supplies @arg{args} to @arg{func} from the left.
@end deffn

@anchor{fun-fl.utilities-dequeue}
@deffn Function DEQUEUE @var{QUEUE}
@findex DEQUEUE
Pops an object from @arg{queue}.  Returns as second
value T if the queue was empty.
@end deffn

@anchor{fun-fl.utilities-dequeue-all}
@deffn Function DEQUEUE-ALL @var{QUEUE}
@findex DEQUEUE-ALL
Clears @arg{queue} and returns content as a list.
@end deffn

@anchor{fun-fl.utilities-display-ht}
@deffn Function DISPLAY-HT @var{HASH-TABLE}
@findex DISPLAY-HT
Display @arg{hash-table} in the form key1 -> value1 ...
@end deffn

@anchor{fun-fl.utilities-dll-front-insert}
@deffn Function DLL-FRONT-INSERT @var{OBJ} @var{DLL} &OPTIONAL @var{INSERT-ITEM-P}
@findex DLL-FRONT-INSERT
Inserts @arg{obj} in @arg{dll}.  It returns the newly created
@class{dll-item}.
@end deffn

@anchor{fun-fl.utilities-dll-rear-insert}
@deffn Function DLL-REAR-INSERT @var{OBJ} @var{DLL} &OPTIONAL @var{INSERT-ITEM-P}
@findex DLL-REAR-INSERT
Inserts @arg{obj} in @arg{dll}.  It returns the newly created
@class{dll-item}.
@end deffn

@anchor{macro-fl.utilities-dohash}
@deffn Macro DOHASH (@var{LOOPING-VAR} @var{HASH-TABLE}) &BODY @var{BODY}
@findex DOHASH
Loops through @arg{hash-table}.  If @arg{looping-var} is an atom
@emph{key}, loop through the keys; if it is a list of the form
@emph{(value)} loop through the values; if it is a list of the form
@emph{(key value)} loop through key and value.
@end deffn

@anchor{macro-fl.utilities-dotuple}
@deffn Macro DOTUPLE (@var{INDEX} @var{LIMITS} &OPTIONAL @var{RESULT}) &BODY @var{BODY}
@findex DOTUPLE
Loops through each tuple below @arg{limits}.
@end deffn

@anchor{fun-fl.utilities-emptyp}
@deffn Function EMPTYP @var{QUEUE}
@findex EMPTYP
Tests if @arg{queue} is empty.
@end deffn

@anchor{fun-fl.utilities-enqueue}
@deffn Function ENQUEUE @var{OBJECT} @var{QUEUE}
@findex ENQUEUE
Puts @arg{object} into the @arg{queue}.
@end deffn

@anchor{fun-fl.utilities-evaluate}
@deffn Function EVALUATE @var{F} @var{X}
@findex EVALUATE
Generic evaluation of functions on an argument.  Numbers and
arrays are treated as constants.  Special evaluation is defined for multivariate
polynomials on vectors and for <function> objects.
@end deffn

@anchor{fun-fl.utilities-factorial}
@deffn Function FACTORIAL @var{N}
@findex FACTORIAL
Compute the factorial of @arg{n}.  @arg{n} can also be a list of
numbers in which case the product of the factorials of the components is
computed.
@end deffn

@anchor{fun-fl.utilities-file-documentation}
@deffn Function FILE-DOCUMENTATION @var{DOCSTRING}
@findex FILE-DOCUMENTATION
If the manual is sorted by file, the string handed to this function
describes the use of the respective file.
@end deffn

@anchor{fun-fl.utilities-filter}
@deffn Function FILTER @var{ITEM} @var{SEQ} &REST @var{REST} &KEY @var{TEST} @var{TEST-NOT} &ALLOW-OTHER-KEYS
@findex FILTER
The positive REMOVE - i.e. like REMOVE with :test instead of :test-not.
@end deffn

@anchor{fun-fl.utilities-filter-if}
@deffn Function FILTER-IF &REST @var{ARGS}
@findex FILTER-IF
The positive version of REMOVE-IF-NOT.
@end deffn

@anchor{fun-fl.utilities-find-leaf}
@deffn Function FIND-LEAF @var{ATOM} @var{TREE} &KEY (@var{KEY} (@var{FUNCTION} @var{IDENTITY})) (@var{TEST} (@var{FUNCTION} @var{EQL}))
@findex FIND-LEAF
Finds atom in @arg{tree}.
@end deffn

@anchor{fun-fl.utilities-find-leaf-if}
@deffn Function FIND-LEAF-IF @var{TEST} @var{TREE} &KEY (@var{KEY} (@var{FUNCTION} @var{IDENTITY}))
@findex FIND-LEAF-IF
Finds a leaf in @arg{tree} where @arg{test} returns true.
@end deffn

@anchor{fun-fl.utilities-find-subtree-if}
@deffn Function FIND-SUBTREE-IF @var{TEST} @var{TREE} &KEY (@var{KEY} (@var{FUNCTION} @var{IDENTITY}))
@findex FIND-SUBTREE-IF
Finds a leaf in @arg{tree} where @arg{test} returns true.
@end deffn

@anchor{fun-fl.utilities-first-only}
@deffn Function FIRST-ONLY @var{LIST}
@findex FIRST-ONLY
Checks if @arg{list} is a singleton and returns its first element.
@end deffn

@anchor{fun-fl.utilities-fixnum-vec}
@deffn Function FIXNUM-VEC &REST @var{ELEMENTS}
@findex FIXNUM-VEC
Returns a @symbol{FIXNUM-VEC} constructed from the parameters.
@end deffn

@anchor{type-fl.utilities-fixnum-vec}
@deftp Type FIXNUM-VEC
@tindex FIXNUM-VEC
Vector with elements of type @code{fixnum}.
@end deftp

@anchor{fun-fl.utilities-flatten}
@deffn Function FLATTEN @var{TREE}
@findex FLATTEN
Flatten a tree.  Example:
@lisp
  (flatten '((1 2) (3) ((4))))  @result{}  (1 2 3 4)
@end lisp
@end deffn

@anchor{fun-fl.utilities-for-each}
@deffn Function FOR-EACH @var{FUNC} @var{COLLECTION}
@findex FOR-EACH
Applies @arg{func} to each element of @arg{collection}.
@end deffn

@anchor{fun-fl.utilities-for-each-tuple}
@deffn Function FOR-EACH-TUPLE @var{FUNC} @var{LIMITS}
@findex FOR-EACH-TUPLE
Calls @arg{func} on each tuple greater or equal to (0 ... 0) and below
@arg{dims}.
@end deffn

@anchor{fun-fl.utilities-get-property}
@deffn Function GET-PROPERTY @var{OBJECT} @var{PROPERTY}
@findex GET-PROPERTY
Gets @arg{property} for @arg{object}.  Returns NIL also if
@arg{property} is not available.
@end deffn

@anchor{fun-fl.utilities-geta}
@deffn Function GETA @var{ALIST} @var{KEY}
@findex GETA
An analog to @code{GETF} for association lists.
@end deffn

@anchor{setf-expander-fl.utilities-geta}
@deffn {Setf Expander} GETA
@findex GETA
An analog to @code{(SETF GETF)} for association lists.
@end deffn

@anchor{fun-fl.utilities-getbb}
@deffn Function GETBB @var{BLACKBOARD} @var{KEY} &OPTIONAL @var{DEFAULT}
@findex GETBB
Get the item for @arg{key} from @arg{blackboard}.  If there is no such
@arg{key} return @arg{default}.
@end deffn

@anchor{fun-fl.utilities-group-by}
@deffn Function GROUP-BY @var{CHARACTERISTIC} @var{SEQ} &KEY (@var{TEST} (@var{QUOTE} @var{EQL}))
@findex GROUP-BY
Groups elements in the sequence @arg{seq} according to @arg{characteristic}
 which is a function of one argument.  Example:
@lisp
  (group-by #'second '((1 2) (2 2) (3 4) (4 4)))
@end lisp
@end deffn

@anchor{fun-fl.utilities-hash-table-keys}
@deffn Function HASH-TABLE-KEYS @var{HASH-TABLE}
@findex HASH-TABLE-KEYS
Collect the keys of @arg{hash-table} into a list.
@end deffn

@anchor{fun-fl.utilities-hash-table-values}
@deffn Function HASH-TABLE-VALUES @var{HASH-TABLE}
@findex HASH-TABLE-VALUES
Collect the values of @arg{hash-table} into a list.
@end deffn

@anchor{fun-fl.utilities-identity-permutation-p}
@deffn Function IDENTITY-PERMUTATION-P @var{PERM}
@findex IDENTITY-PERMUTATION-P
Checks if the permutation is the identity.
@end deffn

@anchor{fun-fl.utilities-iterator}
@deffn Function ITERATOR @var{X}
@findex ITERATOR
Returns an iterator for @arg{x}.
@end deffn

@anchor{fun-fl.utilities-iterator-next}
@deffn Function ITERATOR-NEXT @var{VEC} @var{ITERATOR}
@findex ITERATOR-NEXT
Returns an incremented @arg{iterator}.
@end deffn

@anchor{fun-fl.utilities-k->l-subsets}
@deffn Function K->L-SUBSETS @var{SET} @var{K} @var{L}
@findex K->L-SUBSETS
Returns all subsets of @arg{set} with length between @arg{k} and
@arg{l}.  Example:
@lisp
  (k->l-subsets '(1 2 3) 1 2) @result{}
  ((1) (2) (3) (1 2) (1 3) (2 3))
@end lisp
@end deffn

@anchor{fun-fl.utilities-k-subsets}
@deffn Function K-SUBSETS @var{SET} @var{K}
@findex K-SUBSETS
Returns all subsets of @arg{set} with length @arg{k}.  Example:
@lisp
  (k-subsets '(1 2 3) 2)
  @result{} ((1 2) (1 3) (2 3))
@end lisp
@end deffn

@anchor{fun-fl.utilities-list->queue}
@deffn Function LIST->QUEUE @var{LIST}
@findex LIST->QUEUE
Transforms @arg{list} to a queue.
@end deffn

@anchor{macro-fl.utilities-loop+}
@deffn Macro LOOP+ @var{ITEMS} &BODY @var{BODY}
@findex LOOP+
Iterates @arg{body} over @arg{items}.  Example:
@lisp
  (let ((x (make-array 10))
	(y (make-list 10 :initial-element 1)))
    (loop+ ((xc x) (yc y) i) doing
       (setf xc (+ i yc))
       finally (return x)))
@end lisp
@end deffn

@anchor{fun-fl.utilities-make-analog}
@deffn Function MAKE-ANALOG @var{OBJ}
@findex MAKE-ANALOG
Generate an analogous but empty data structure.
@end deffn

@anchor{fun-fl.utilities-make-fixnum-vec}
@deffn Function MAKE-FIXNUM-VEC @var{DIM} &OPTIONAL (@var{INIT} 0)
@findex MAKE-FIXNUM-VEC
Construct a @symbol{FIXNUM-VEC} of size @arg{dim} initialized by
@arg{init}.
@end deffn

@anchor{fun-fl.utilities-map-hash-table}
@deffn Function MAP-HASH-TABLE @var{FUNC} @var{HASH-TABLE}
@findex MAP-HASH-TABLE
Call @arg{func} given in the first argument on each key of
@arg{hash-table}.  @arg{func} must return the new key and the new value as
two values.  Those pairs are stored in a new hash-table.
@end deffn

@anchor{fun-fl.utilities-map-list-in-hash-table}
@deffn Function MAP-LIST-IN-HASH-TABLE @var{FUNC} @var{LIST} &OPTIONAL (@var{TYPE} (@var{QUOTE} @var{EQL}))
@findex MAP-LIST-IN-HASH-TABLE
Maps the elements of @arg{list} in a hash-table identified by
@arg{identifier}.  @arg{func} is evaluated on each element and produces two
values which are used as key and value for the hash-table.
@end deffn

@anchor{fun-fl.utilities-map-product}
@deffn Function MAP-PRODUCT @var{FUNC} @var{LIST} &REST @var{REST-LISTS}
@findex MAP-PRODUCT
Applies @arg{func} to a product of lists.  Example:
@lisp
  (map-product #'cons '(2 3) '(1 4))
  @result{} ((2 . 1) (2 . 4) (3 . 1) (3 . 4))
@end lisp
@end deffn

@anchor{fun-fl.utilities-map-tree}
@deffn Function MAP-TREE @var{FUNC} @var{TREE}
@findex MAP-TREE
Maps @arg{tree} using @arg{func}.  Example:
@lisp
  (map-tree #'1+ '((1 (2)))) @result{} ((2 (3)))
@end lisp
@end deffn

@anchor{macro-fl.utilities-mapf}
@deffn Macro MAPF @var{VAR} @var{FUNC}
@findex MAPF
Replaces the value of the variable @arg{var} by setting it to its map
with @arg{func}.
@end deffn

@anchor{fun-fl.utilities-mappend}
@deffn Function MAPPEND @var{FUNC} &REST @var{LISTS}
@findex MAPPEND
Map @function{func} over @arg{lists} while appending the results.
@end deffn

@anchor{fun-fl.utilities-mapper-collect}
@deffn Function MAPPER-COLLECT @var{MAPPER} &REST @var{REST-ARGS}
@findex MAPPER-COLLECT
Collects the arguments with which a mapping construct calls a given function.  E.g.
@lisp
  (mapper-collect #'mapc '(3 4 5)) @result{} (3 4 5)
@end lisp
@end deffn

@anchor{fun-fl.utilities-mapper-count}
@deffn Function MAPPER-COUNT @var{MAPPER} &REST @var{REST-ARGS}
@findex MAPPER-COUNT
Counts the arguments with which a mapping construct calls a given function.  E.g.
@lisp
  (mapper-sum #'mapc '(3 4 5)) @result{} 3
@end lisp
@end deffn

@anchor{fun-fl.utilities-mapper-every}
@deffn Function MAPPER-EVERY @var{TEST} @var{MAPPER} &REST @var{REST-ARGS}
@findex MAPPER-EVERY
Tests if the test is fulfilled for every argument on which the mapper is
called:
@lisp
  (mapper-every #'plusp #'mapc '(3 4 5)) @result{} T
@end lisp
@end deffn

@anchor{fun-fl.utilities-mapper-select-first}
@deffn Function MAPPER-SELECT-FIRST @var{MAPPER} &REST @var{REST-ARGS}
@findex MAPPER-SELECT-FIRST
Select the arguments with which a mapping construct calls a given function.  E.g.
@lisp
  (mapper-select-first #'mapc '(3 4 5) '(7 8 9)) @result{} 3,7
@end lisp
@end deffn

@anchor{fun-fl.utilities-mapper-some}
@deffn Function MAPPER-SOME @var{TEST} @var{MAPPER} &REST @var{REST-ARGS}
@findex MAPPER-SOME
Tests if the test is fulfilled for some argument on which the mapper is
called:
@lisp
  (mapper-some #'plusp #'mapc '(-3 4 5)) @result{} T
@end lisp
@end deffn

@anchor{fun-fl.utilities-mapper-sum}
@deffn Function MAPPER-SUM @var{MAPPER} &REST @var{REST-ARGS}
@findex MAPPER-SUM
Sums the arguments with which a mapping construct calls a given function.  E.g.
@lisp
 (mapper-sum #'mapc '(3 4 5)) @result{} 12
@end lisp
@end deffn

@anchor{fun-fl.utilities-maximally-connected}
@deffn Function MAXIMALLY-CONNECTED @var{CONNECTED} @var{DISCONNECTED} &KEY (@var{TEST} (@var{FUNCTION} @var{EQL})) (@var{COMBINE} (@var{FUNCTION} @var{ADJOIN}))
@findex MAXIMALLY-CONNECTED
Finds a maximally connected set by taking the union of the elements in
connected with the sets of disconnected-sets.  Returns the maximally
connected sets and the remaining disconnected ones.  Example:

@lisp
  (maximally-connected '(1 2) '((3 4) (2 3) (5 6))
                       :test #'intersection :combine #'union)
  @result{} (1 2 3 4), ((5 6))
@end lisp
@end deffn

@anchor{fun-fl.utilities-measure-time}
@deffn Function MEASURE-TIME @var{FN} &OPTIONAL (@var{COUNT} 1) @var{REAL-P}
@findex MEASURE-TIME
Measures the time in seconds needed by @arg{count}-times
executing @arg{fn}.
@end deffn

@anchor{fun-fl.utilities-memoize-1}
@deffn Function MEMOIZE-1 @var{FUNC} &KEY (@var{TEST} (@var{QUOTE} @var{EQL}))
@findex MEMOIZE-1
Memoizes the function @arg{func} which should be a non-recursive
function of one argument.
@end deffn

@anchor{fun-fl.utilities-memoize-symbol}
@deffn Function MEMOIZE-SYMBOL @var{FUNSYM} &KEY (@var{TEST} (@var{QUOTE} @var{EQUAL}))
@findex MEMOIZE-SYMBOL
Memoizes multi-argument functions named by the symbol @arg{funsym}.
@end deffn

@anchor{fun-fl.utilities-mklist}
@deffn Function MKLIST @var{OBJ}
@findex MKLIST
Wraps @arg{obj} in a list, if it is not already a list.
@end deffn

@anchor{fun-fl.utilities-n-partitions-of-k}
@deffn Function N-PARTITIONS-OF-K @var{N} @var{K}
@findex N-PARTITIONS-OF-K
Returns a list of all ordered partitions of @arg{k} into @arg{n} natural
numbers.  Example:
@lisp
  (n-partitions-of-k 2 3)
   @result{} ((0 3) (1 2) (2 1) (3 0))
@end lisp
@end deffn

@anchor{fun-fl.utilities-nonempty-subsets}
@deffn Function NONEMPTY-SUBSETS @var{SET}
@findex NONEMPTY-SUBSETS
Returns a list of all nonempty subsets of @arg{set}.
@end deffn

@anchor{fun-fl.utilities-on-leaves}
@deffn Function ON-LEAVES @var{FUNC} @var{TREE}
@findex ON-LEAVES
Executes @arg{func} on the leaves of @arg{tree}.
@end deffn

@anchor{fun-fl.utilities-on-subtrees}
@deffn Function ON-SUBTREES @var{FUNC} @var{TREE}
@findex ON-SUBTREES
Calls @arg{func} on every subtree of @arg{tree}.
@end deffn

@anchor{fun-fl.utilities-partial-sums}
@deffn Function PARTIAL-SUMS @var{SEQ}
@findex PARTIAL-SUMS
Returns a sequence of the same type as @arg{seq} consisting of its
partial sums.
@end deffn

@anchor{fun-fl.utilities-permutation-inverse}
@deffn Function PERMUTATION-INVERSE @var{PERM-VEC}
@findex PERMUTATION-INVERSE
Returns the inverse of the permutation given by @arg{perm-vec}.
@end deffn

@anchor{fun-fl.utilities-permutation-p}
@deffn Function PERMUTATION-P @var{PERM}
@findex PERMUTATION-P
Checks if @arg{perm} is a possible permutation vector.  A permutation pi
is characterized by a vector containing the indices from 0,...,
@function{length}(@arg{perm})-1 in some order.
@end deffn

@anchor{fun-fl.utilities-permutation-signum}
@deffn Function PERMUTATION-SIGNUM @var{PERM}
@findex PERMUTATION-SIGNUM
Returns the sign of @arg{perm}.
@end deffn

@anchor{fun-fl.utilities-permute}
@deffn Function PERMUTE @var{PERM} @var{INDEX}
@findex PERMUTE
Functional version of @function{permute-into}.
@end deffn

@anchor{fun-fl.utilities-permute-into}
@deffn Function PERMUTE-INTO @var{PERM} @var{V} @var{RESULT}
@findex PERMUTE-INTO
A permutation @arg{perm} acts on the vector @arg{v} by permuting it
according to @math{result[i] = v[perm[i]]}.
@end deffn

@anchor{type-fl.utilities-positive-fixnum}
@deftp Type POSITIVE-FIXNUM
@tindex POSITIVE-FIXNUM
Positive fixnum tpye.
@end deftp

@anchor{fun-fl.utilities-positive-n-partitions-of-k}
@deffn Function POSITIVE-N-PARTITIONS-OF-K @var{N} @var{K}
@findex POSITIVE-N-PARTITIONS-OF-K
Returns a list of all positive ordered partitions of @arg{k} into
@arg{n} natural numbers.  Example:
@lisp
  (positive-n-partitions-of-k 2 3)
  @result{} ((1 2) (2 1))
@end lisp
@end deffn

@anchor{fun-fl.utilities-positive-partitions-of-k}
@deffn Function POSITIVE-PARTITIONS-OF-K @var{K}
@findex POSITIVE-PARTITIONS-OF-K
Returns a list of all positive ordered partitions of @arg{k}.
Example:
@lisp
  (positive-partitions-of-k 3) @result{} ((1 2) (2 1))
@end lisp
@end deffn

@anchor{class-fl.utilities-property-mixin}
@deftp Class PROPERTY-MIXIN
@tindex PROPERTY-MIXIN
A mixin adding a property slot to the class.

Direct slots:
@itemize
@item PROPERTIES: A property list for storing
unstructured information about this object.
@end itemize
@end deftp

@anchor{fun-fl.utilities-queue->list}
@deffn Function QUEUE->LIST @var{QUEUE}
@findex QUEUE->LIST
Transforms @arg{queue} to a list.
@end deffn

@anchor{fun-fl.utilities-range}
@deffn Function RANGE &REST @var{ARGS} &KEY @var{TO} @var{BELOW}
@findex RANGE
Constructor for a range of numbers.
@end deffn

@anchor{class-fl.utilities-range}
@deftp Class RANGE
@tindex RANGE
Range of numbers for iteration.

Direct slots:
@itemize
@item FROM: Start of range, defaults to 0.
@item TO: Inclusive end of range, defaults to infinity.
@item BELOW: Exclusive end of range, defaults to infinity.
@item BY: Step size.
@end itemize
@end deftp

@anchor{fun-fl.utilities-rcurry}
@deffn Function RCURRY @var{FUNC} &REST @var{ARGS}
@findex RCURRY
Supplies @arg{args} to @arg{func} from the right.
@end deffn

@anchor{fun-fl.utilities-reference}
@deffn Function REFERENCE @var{VEC} @var{ITERATOR}
@findex REFERENCE
Reader for the element of @arg{vec} referenced by @arg{iterator}.
@end deffn

@anchor{fun-fl.utilities-required-argument}
@deffn Function REQUIRED-ARGUMENT 
@findex REQUIRED-ARGUMENT
Calling this function results in an error.  Such a call may be used as
default form when an argument should be supplied.
@end deffn

@anchor{fun-fl.utilities-samep}
@deffn Function SAMEP @var{SEQUENCE} &KEY (@var{TEST} (@var{FUNCTION} @var{EQL})) (@var{KEY} (@var{FUNCTION} @var{IDENTITY}))
@findex SAMEP
Returns t if @arg{sequence} consists of equal elements.
@end deffn

@anchor{fun-fl.utilities-sans}
@deffn Function SANS @var{PLIST} &REST @var{KEYS}
@findex SANS
Removes the items marked by @arg{keys} from the property list
@arg{plist}.  This function was posted at 2.12.2002 to the
@emph{comp.lang.lisp} newsgroup by Erik Naggum.
@end deffn

@anchor{fun-fl.utilities-set-equal}
@deffn Function SET-EQUAL @var{SET1} @var{SET2} &KEY (@var{TEST} (@var{FUNCTION} @var{EQL}))
@findex SET-EQUAL
Tests two sets for equality, e.g.
@lisp
  (set-equal '(a b) '(b a)) @result{} T
@end lisp
@end deffn

@anchor{fun-fl.utilities-set-p}
@deffn Function SET-P @var{LIST}
@findex SET-P
Checks if @arg{list} is a set, i.e. if no members occur twice.
@end deffn

@anchor{fun-fl.utilities-split-by-length}
@deffn Function SPLIT-BY-LENGTH @var{ITEMS} @var{LENGTHS}
@findex SPLIT-BY-LENGTH
Breaks the list @arg{items} in pieces of lengths determined by
@arg{nrins}.  Example:
@lisp
  (split-by-length '(1 2 3 4) '(1 3)) @result{} ((1) (2 3 4))
@end lisp
@end deffn

@anchor{fun-fl.utilities-square}
@deffn Function SQUARE @var{X}
@findex SQUARE
Return the square of @arg{x}.
@end deffn

@anchor{fun-fl.utilities-subsets}
@deffn Function SUBSETS @var{SET}
@findex SUBSETS
Returns a list of all subsets of @arg{set}.
@end deffn

@anchor{fun-fl.utilities-transfer-bb}
@deffn Function TRANSFER-BB @var{FROM-BB} @var{TO-BB} @var{ITEMS} &KEY @var{ENSURE}
@findex TRANSFER-BB
Transfer @arg{items} between the blackboards @arg{from-bb} and
@arg{to-bb}.  When @arg{ensure} is set, an existing item is not modified.
@end deffn

@anchor{fun-fl.utilities-translate}
@deffn Function TRANSLATE @var{ITEM} @var{TRANSLATIONS}
@findex TRANSLATE
Performs certain translations from an association table on the string item.
Example: (translate "abcdefg" '(("a" . "x")  ("b" . "yz")))
@end deffn

@anchor{fun-fl.utilities-unbox}
@deffn Function UNBOX @var{BOX}
@findex UNBOX
Getter for a boxed object.
@end deffn

@anchor{fun-fl.utilities-vector-last}
@deffn Function VECTOR-LAST @var{VEC}
@findex VECTOR-LAST
Reader for the last element of @arg{vec}.
@end deffn

@anchor{fun-fl.utilities-vector-map}
@deffn Function VECTOR-MAP @var{FUNC} &REST @var{VECS}
@findex VECTOR-MAP
Map @arg{vec} with @arg{func} to a vector of the same type.
@end deffn

@anchor{macro-fl.utilities-with-items}
@deffn Macro WITH-ITEMS @var{PROPERTIES} @var{BLACKBOARD-FORM} &BODY @var{BODY}
@findex WITH-ITEMS
Work with the items on @arg{blackboard} corresponding to
@arg{properties}.  If some property is a list, the second element is the
default value and the third is an alias to be used to refer to this
parameter.  Example:
@lisp
  (with-items (&key sol (rhs nil rhs-high)) blackboard
     (setq sol rhs-high))
@end lisp
@end deffn

@anchor{fun-fl.utilities-zero-vector}
@deffn Function ZERO-VECTOR @var{DIM} @var{ELEMENT-TYPE}
@findex ZERO-VECTOR
Returns a uniform vector for the given element type filled with zeros.
@end deffn

@node Package FL.MACROS, Package FL.DEBUG, Package FL.UTILITIES, Reference manual
@section Package FL.MACROS

This package contains some basic macro definitions used in Femlisp.

@anchor{macro-fl.macros-?1}
@deffn Macro ?1 &REST @var{ARGS}
@findex ?1
A macro returning the first of its arguments.
@end deffn

@anchor{macro-fl.macros-?2}
@deffn Macro ?2 &REST @var{ARGS}
@findex ?2
A macro returning the second of its arguments.
@end deffn

@anchor{macro-fl.macros-?3}
@deffn Macro ?3 &REST @var{ARGS}
@findex ?3
A macro returning the third of its arguments.
@end deffn

@anchor{macro-fl.macros-?4}
@deffn Macro ?4 &REST @var{ARGS}
@findex ?4
A macro returning the fourth of its arguments.
@end deffn

@anchor{macro-fl.macros-?5}
@deffn Macro ?5 &REST @var{ARGS}
@findex ?5
A macro returning the fifth of its arguments.
@end deffn

@anchor{macro-fl.macros-?6}
@deffn Macro ?6 &REST @var{ARGS}
@findex ?6
A macro returning the sixth of its arguments.
@end deffn

@anchor{macro-fl.macros-aand}
@deffn Macro AAND &REST @var{ARGS}
@findex AAND
Anaphoric macro from @cite{(Graham 1993)}.
@end deffn

@anchor{macro-fl.macros-acond}
@deffn Macro ACOND &REST @var{CLAUSES}
@findex ACOND
Anaphoric macro from @cite{(Graham 1993)}.
@end deffn

@anchor{macro-fl.macros-awhen}
@deffn Macro AWHEN @var{TEST-FORM} &BODY @var{BODY}
@findex AWHEN
Anaphoric macro from @cite{(Graham 1993)}.
@end deffn

@anchor{macro-fl.macros-bif}
@deffn Macro BIF (@var{BINDVAR} @var{BOUNDFORM}) @var{YUP} &OPTIONAL @var{NOPE}
@findex BIF
Posted to cll by Kenny Tilton 22.4.2007.
@end deffn

@anchor{macro-fl.macros-definline}
@deffn Macro DEFINLINE @var{NAME} &REST @var{REST}
@findex DEFINLINE
Short form for defining an inlined function.  It should probably be
deprecated, because it won't be recognized by default by some IDEs.  Better
use the inlining macro directly.
@end deffn

@anchor{macro-fl.macros-deletef}
@deffn Macro DELETEF @var{ITEM} @var{SEQUENCE} &REST @var{ARGS}
@findex DELETEF
Delets @arg{item} from @arg{sequence} destructively.
@end deffn

@anchor{macro-fl.macros-echo}
@deffn Macro ECHO @var{EKX-ID} &REST @var{BODY}
@findex ECHO
Posted to cll at 17.10.2006 by Kenny Tilton.
@end deffn

@anchor{macro-fl.macros-ensure}
@deffn Macro ENSURE @var{PLACE} @var{NEWVAL}
@findex ENSURE
Essentially (or place (setf place newval)).  Posted by Erling Alf to
c.l.l. on 11.8.2004, implementing an idea of myself posted on c.l.l. on 30
Jul 2004 in a probably more ANSI conforming way.
@end deffn

@anchor{macro-fl.macros-fluid-let}
@deffn Macro FLUID-LET @var{BINDINGS} &BODY @var{BODY}
@findex FLUID-LET
Sets temporary bindings.
@end deffn

@anchor{macro-fl.macros-gencase}
@deffn Macro GENCASE @var{OBJ} @var{TEST} &BODY @var{CLAUSES}
@findex GENCASE
An analog to case using @arg{test} as comparison.
@end deffn

@anchor{macro-fl.macros-inlining}
@deffn Macro INLINING &REST @var{DEFINITIONS}
@findex INLINING
Declaims the following definitions inline together with executing them.
@end deffn

@anchor{macro-fl.macros-lret}
@deffn Macro LRET @var{BINDINGS} &BODY @var{BODY}
@findex LRET
A @function{let}-construct which returns its last binding.
@end deffn

@anchor{macro-fl.macros-lret*}
@deffn Macro LRET* @var{BINDINGS} &BODY @var{BODY}
@findex LRET*
A @function{let*}-construct which returns its last binding.
@end deffn

@anchor{macro-fl.macros-multi-dotimes}
@deffn Macro MULTI-DOTIMES (@var{VAR} @var{STOP}) &BODY @var{BODY}
@findex MULTI-DOTIMES
Special case of @func{multi-for}.  Loops starting from a zero-vector to @arg{stop}.
Examples:
@lisp
  (multi-dotimes (x #(3 3)) (princ x) (terpri))
@end lisp
@end deffn

@anchor{macro-fl.macros-multi-for}
@deffn Macro MULTI-FOR (@var{VAR} @var{START} @var{STOP} &KEY @var{FROM-END}) &BODY @var{BODY}
@findex MULTI-FOR
Loops for @arg{var} being an integer vector starting from @arg{start}
upto @arg{stop}.  Examples:
@lisp
  (multi-for (x #(1 1) #(3 3)) (princ x) (terpri))
  (multi-for (x #(1 1) #(3 3) :from-end t) (princ x) (terpri))
@end lisp
@end deffn

@anchor{macro-fl.macros-multiple-defgen}
@deffn Macro MULTIPLE-DEFGEN @var{NAMES} @var{ARGS}
@findex MULTIPLE-DEFGEN
Defines multiple generic functions at once.
Usually, this will only be used for helper functions.
@end deffn

@anchor{macro-fl.macros-named-let}
@deffn Macro NAMED-LET @var{NAME} @var{BINDINGS} &BODY @var{BODY}
@findex NAMED-LET
Implements the named-let construct from Scheme.
@end deffn

@anchor{macro-fl.macros-once-only}
@deffn Macro ONCE-ONLY @var{VARIABLES} &REST @var{BODY}
@findex ONCE-ONLY
Slightly modified macro taken from
   <http://groups.google.com/comp.lang.lisp/msg/2a92ad69a8185866>.
@end deffn

@anchor{macro-fl.macros-remove-this-method}
@deffn Macro REMOVE-THIS-METHOD @var{GF-NAME} &REST @var{REST}
@findex REMOVE-THIS-METHOD
Removes the method for the generic function @arg{gf-name} which is
specified by @arg{qualifiers} and @arg{specializers}.  Example:
@lisp
  (remove-this-method m* :before ((mat <matrix>) (x <vector>)))
@end lisp
It should be possible to use this directly on a copied first line of a
DEFMETHOD definition.
@end deffn

@anchor{macro-fl.macros-show-call}
@deffn Macro SHOW-CALL @var{FUNC} &OPTIONAL @var{NAME}
@findex SHOW-CALL
Wraps a function object inside a trace form.
@end deffn

@anchor{macro-fl.macros-stringcase}
@deffn Macro STRINGCASE @var{STRING} &BODY @var{CLAUSES}
@findex STRINGCASE
An analog to case using string comparison.
@end deffn

@anchor{macro-fl.macros-symbol-macroletf}
@deffn Macro SYMBOL-MACROLETF (&REST @var{BINDINGS}) &BODY @var{BODY}
@findex SYMBOL-MACROLETF
Like SYMBOL-MACROLET but evaluate subforms just once up front.
@end deffn

@anchor{fun-fl.macros-symconc}
@deffn Function SYMCONC &REST @var{ARGS}
@findex SYMCONC
This function builds a symbol from its arguments and interns it.  This
is used in some macros.
@end deffn

@anchor{macro-fl.macros-whereas}
@deffn Macro WHEREAS @var{CLAUSES} &BODY @var{BODY}
@findex WHEREAS
Own implementation of the macro @function{whereas} suggested by Erik
Naggum (c.l.l., 4.12.2002).
@end deffn

@anchor{macro-fl.macros-with-arrays}
@deffn Macro WITH-ARRAYS @var{SYMS} &BODY @var{BODY}
@findex WITH-ARRAYS
Improved version of a macro posted in cll by ?.  A similar but more
restricted macro was posted by KMP at 8.5.2007 under the name 'array-access'.
@end deffn

@anchor{macro-fl.macros-with-gensyms}
@deffn Macro WITH-GENSYMS @var{SYMS} &BODY @var{BODY}
@findex WITH-GENSYMS
Standard macro providing the freshly generated symbols @arg{syms} to the
code in @arg{body}.
@end deffn

@anchor{macro-fl.macros-_}
@deffn Macro _ &BODY @var{BODY}
@findex _
Easy definition of anonymous small functions.
Arguments are '_', '_1', ..., '_5'.
@end deffn

@anchor{macro-fl.macros-_f}
@deffn Macro _F @var{OP} @var{PLACE} &REST @var{ARGS}
@findex _F
Macro from @cite{(Graham 1993)}.  Turns the operator @arg{op} into a
modifying form, e.g. @code{(_f + a b) @equiv{} (incf a b)}.
@end deffn

@node Package FL.DEBUG, Package FL.DEMO, Package FL.MACROS, Reference manual
@section Package FL.DEBUG

This package adds debugging tools to Femlisp.  This is a
slightly modified version of the debugging suite proposed in @cite{(Norvig
1992)}.

@anchor{fun-fl.debug-dbg}
@deffn Function DBG @var{ID} @var{FORMAT-STRING} &REST @var{ARGS}
@findex DBG
When debugging on @arg{id} print out the arguments
@arg{args} using the format in @arg{format-string}.
@end deffn

@anchor{fun-fl.debug-dbg-indent}
@deffn Function DBG-INDENT @var{ID} @var{INDENT} @var{FORMAT-STRING} &REST @var{ARGS}
@findex DBG-INDENT
When debugging @arg{id}, print out the arguments
@arg{args} using the format in @arg{format-string} with indentation given
by @arg{indent}.
@end deffn

@anchor{fun-fl.debug-dbg-off}
@deffn Function DBG-OFF &REST @var{IDS}
@findex DBG-OFF
Stop debugging on the passed symbols.  With no arguments, stop debugging
altogether.
@end deffn

@anchor{fun-fl.debug-dbg-on}
@deffn Function DBG-ON &REST @var{IDS}
@findex DBG-ON
Register ids for dbg.
@end deffn

@anchor{fun-fl.debug-dbg-p}
@deffn Function DBG-P @var{ID}
@findex DBG-P
Returns T if @arg{id} is in the debug list, NIL otherwise.
@end deffn

@anchor{macro-fl.debug-dbg-when}
@deffn Macro DBG-WHEN @var{ID} &BODY @var{BODY}
@findex DBG-WHEN
Perform a check only if debugging @arg{id}.
@end deffn

@node Package FL.DEMO, Package FL.TESTS, Package FL.DEBUG, Reference manual
@section Package FL.DEMO

This package provides routines for building a
demo suite.  Wherever something interesting can be demonstrated,
a small demo node should be generated with the
@function{make-demo} and added to the tree of all demos with
@function{adjoin-demo}.  After loading @femlisp{}, the whole
demo suite is available and can be run with the command
@function{femlisp-demo}.

@anchor{var-fl.demo-*demo-time*}
@defvr Variable *DEMO-TIME*
@vindex *DEMO-TIME*
Suggested time for a demo which should be used as a
termination criterion in demo iterations.
@end defvr

@anchor{fun-fl.demo-adjoin-demo}
@deffn Function ADJOIN-DEMO @var{DEMO} @var{PARENT}
@findex ADJOIN-DEMO
Adjoins the demo @arg{demo} to @arg{parent}.
@end deffn

@anchor{fun-fl.demo-extract-demo-strings}
@deffn Function EXTRACT-DEMO-STRINGS @var{STRING} &OPTIONAL @var{TRANSLATIONS}
@findex EXTRACT-DEMO-STRINGS
Extract demo information from the documentation string of the
generating function.
@end deffn

@anchor{fun-fl.demo-femlisp-demo}
@deffn Function FEMLISP-DEMO &OPTIONAL (@var{DEMO} @var{*DEMO-ROOT*})
@findex FEMLISP-DEMO
Shows all demos below the given demo root.
@end deffn

@anchor{fun-fl.demo-remove-demo}
@deffn Function REMOVE-DEMO @var{DEMO} @var{PARENT}
@findex REMOVE-DEMO
Remove @arg{demo} from @arg{parent}.
@end deffn

@anchor{fun-fl.demo-test-all-demos}
@deffn Function TEST-ALL-DEMOS &OPTIONAL (@var{DEMO} @var{*DEMO-ROOT*})
@findex TEST-ALL-DEMOS
Performs all demos reachable from @arg{demo}.
@end deffn

@anchor{fun-fl.demo-user-input}
@deffn Function USER-INPUT @var{PROMPT} &OPTIONAL (@var{CONVERTER} (@var{FUNCTION} @var{IDENTITY})) (@var{TEST-P} (@var{CONSTANTLY} @var{T}))
@findex USER-INPUT
User input for demo functions.  Reads lines until
@arg{test-p} returns t on the item read.
@end deffn

@node Package FL.TESTS, Package FL.PORT, Package FL.DEMO, Reference manual
@section Package FL.TESTS

This package provides routines for building a simple
regression test suite.  Most files in @femlisp{} contain a test function at
the end which checks several critical features which the file or module
provides.  By calling the function @function{adjoin-test} at load time,
this function is added to a list of functions to be checked.  After loading
@femlisp{}, all functions in this list can be executed one after the other
by calling the function @function{test-femlisp}.  Errors and exceptions are
registered and finally reported.  It is very much recommended to run this
test suite before a release.

@anchor{fun-fl.tests-adjoin-test}
@deffn Function ADJOIN-TEST @var{FSYM}
@findex ADJOIN-TEST
Adjoins a test to the Femlisp test suite.
@end deffn

@anchor{fun-fl.tests-remove-test}
@deffn Function REMOVE-TEST @var{FSYM}
@findex REMOVE-TEST
Adjoins a test to the Femlisp test suite.
@end deffn

@anchor{macro-fl.tests-small-test}
@deffn Macro SMALL-TEST @var{FSYM} &BODY @var{BODY}
@findex SMALL-TEST
At the moment small tests are ignored.  One might think of collecting
them when compiling a certain file.
@end deffn

@anchor{fun-fl.tests-test-femlisp}
@deffn Function TEST-FEMLISP &KEY @var{CONTINUE} @var{PACKAGE} (@var{LOGFILE} (@var{FEMLISP-PATHNAME} "fltest.log")) (@var{DEMO} @var{T})
@findex TEST-FEMLISP
Runs the Femlisp test suite.  The result is printed to
*standard-output*.
@end deffn

@node Package FL.PORT, Package FL.AMOP, Package FL.TESTS, Reference manual
@section Package FL.PORT

This package should contain the implementation-dependent
parts of Femlisp with the exception of the MOP.  It serves a similar
purpose as the PORT module in CLOCC and is somewhat inspired by this
module.  It will be dropped when there is a portable and easily installable
alternative in all CL implementations we are interested in

@anchor{fun-fl.port-compile-and-eval}
@deffn Function COMPILE-AND-EVAL @var{SOURCE}
@findex COMPILE-AND-EVAL
Compiles and evaluates the given @arg{source}.  This should be an ANSI
compatible way of ensuring method compilation.
@end deffn

@anchor{fun-fl.port-compile-silently}
@deffn Function COMPILE-SILENTLY @var{NAME} @var{SOURCE}
@findex COMPILE-SILENTLY
Compiles @arg{source} silently.
@end deffn

@anchor{macro-fl.port-def-function}
@deffn Macro DEF-FUNCTION &REST @var{ARGS}
@findex DEF-FUNCTION
Defines a foreign function.  See examples in
@path{alien;src;superlu.lisp}.
@end deffn

@anchor{fun-fl.port-dynamic-space-size}
@deffn Function DYNAMIC-SPACE-SIZE 
@findex DYNAMIC-SPACE-SIZE
Available memory for calculations
@end deffn

@anchor{fun-fl.port-finalize}
@deffn Function FINALIZE @var{OBJ} @var{FUNC}
@findex FINALIZE
Sets up @arg{func} as finalizer for @arg{obj}.
@end deffn

@anchor{fun-fl.port-find-executable}
@deffn Function FIND-EXECUTABLE @var{NAME}
@findex FIND-EXECUTABLE
Finds an executable in the current path.
@end deffn

@anchor{fun-fl.port-find-shared-library}
@deffn Function FIND-SHARED-LIBRARY @var{NAME}
@findex FIND-SHARED-LIBRARY
Finds a shared library.
@end deffn

@anchor{fun-fl.port-foreign-call}
@deffn Function FOREIGN-CALL @var{FUNCTION} &REST @var{ARGS}
@findex FOREIGN-CALL
Ensures a safe environment for a foreign function call, especially so
that no GC changes array pointers obtained by @function{vector-sap}.
@end deffn

@anchor{fun-fl.port-getenv}
@deffn Function GETENV @var{VAR}
@findex GETENV
Return the value of the environment variable.
@end deffn

@anchor{fun-fl.port-hostname}
@deffn Function HOSTNAME 
@findex HOSTNAME
Returns the hostname.
@end deffn

@anchor{fun-fl.port-load-foreign-library}
@deffn Function LOAD-FOREIGN-LIBRARY @var{FILE}
@findex LOAD-FOREIGN-LIBRARY
Loads the foreign library @arg{file}.
@end deffn

@anchor{fun-fl.port-make-weak-pointer}
@deffn Function MAKE-WEAK-POINTER @var{OBJ}
@findex MAKE-WEAK-POINTER
Creates a weak pointer pointing to @arg{obj}.
@end deffn

@anchor{fun-fl.port-process-close}
@deffn Function PROCESS-CLOSE @var{PROCESS}
@findex PROCESS-CLOSE
Closes @arg{process}.
@end deffn

@anchor{fun-fl.port-process-error}
@deffn Function PROCESS-ERROR @var{PROCESS}
@findex PROCESS-ERROR
Process-output for @arg{process}.
@end deffn

@anchor{fun-fl.port-process-input}
@deffn Function PROCESS-INPUT @var{PROCESS}
@findex PROCESS-INPUT
Process-input for @arg{process}.
@end deffn

@anchor{fun-fl.port-process-output}
@deffn Function PROCESS-OUTPUT @var{PROCESS}
@findex PROCESS-OUTPUT
Process-output for @arg{process}.
@end deffn

@anchor{fun-fl.port-process-status}
@deffn Function PROCESS-STATUS @var{PROCESS}
@findex PROCESS-STATUS
Returns the status of @arg{process}.
@end deffn

@anchor{fun-fl.port-run-program}
@deffn Function RUN-PROGRAM @var{PROGRAM} @var{ARGS} &KEY @var{WAIT} @var{DIRECTORY} @var{INPUT} (@var{OUTPUT} @var{NIL} @var{OUTPUT-P}) @var{ERROR-OUTPUT}
@findex RUN-PROGRAM
Runs @arg{program} with arguments @arg{args}.
@end deffn

@anchor{fun-fl.port-run-program-output}
@deffn Function RUN-PROGRAM-OUTPUT @var{PROGRAM} @var{ARGS}
@findex RUN-PROGRAM-OUTPUT
Returns a list of all lines of the output of @function{RUN-PROGRAM}
when called with the arguments @arg{PROGRAM} and @arg{ARGS}.
@end deffn

@anchor{fun-fl.port-runtime-compile}
@deffn Function RUNTIME-COMPILE @var{SOURCE}
@findex RUNTIME-COMPILE
Calls compile on the provided @arg{source}.  When :compile is activated
for debugging, the source code is printed.
@end deffn

@anchor{fun-fl.port-save-femlisp-core-and-die}
@deffn Function SAVE-FEMLISP-CORE-AND-DIE &OPTIONAL @var{CORE-FILE-NAME}
@findex SAVE-FEMLISP-CORE-AND-DIE
Saves Femlisp core and quits.
@end deffn

@anchor{fun-fl.port-unix-chdir}
@deffn Function UNIX-CHDIR @var{PATH}
@findex UNIX-CHDIR
Change the directory to @arg{path}.
@end deffn

@anchor{fun-fl.port-vector-sap}
@deffn Function VECTOR-SAP @var{PTR}
@findex VECTOR-SAP
Returns an array pointer which can be used in a foreign call.
@end deffn

@anchor{fun-fl.port-weak-pointer-value}
@deffn Function WEAK-POINTER-VALUE @var{WP}
@findex WEAK-POINTER-VALUE
Returns the value of the weak pointer @arg{wp}.
@end deffn

@node Package FL.AMOP, Package FL.ALIEN, Package FL.PORT, Reference manual
@section Package FL.AMOP

This package provides some MOP functionality.  These functions are
non-ANSI and may represent a problem when porting Femlisp.

@anchor{fun-fl.amop-find-programmatic-class}
@deffn Function FIND-PROGRAMMATIC-CLASS @var{SUPERCLASSES} &KEY @var{CLASS-NAME} @var{ADDITIONAL-SLOTS}
@findex FIND-PROGRAMMATIC-CLASS
Finds and, if necessary, generates a class from the given superclasses.
@end deffn

@anchor{fun-fl.amop-make-programmatic-instance}
@deffn Function MAKE-PROGRAMMATIC-INSTANCE @var{SUPERCLASS-ES} &REST @var{INITARGS} &KEY @var{CLASS-NAME} @var{ADDITIONAL-SLOTS} &ALLOW-OTHER-KEYS
@findex MAKE-PROGRAMMATIC-INSTANCE
Makes an instance of a class denoted by a list of the names of its
superclasses.  This class is generated automatically, if necessary.
@end deffn

@anchor{fun-fl.amop-remove-subclass-methods}
@deffn Function REMOVE-SUBCLASS-METHODS @var{GF} @var{TEMPLATE-ARGS}
@findex REMOVE-SUBCLASS-METHODS
Removes all methods dispatching on subclasses of the template
arguments.
@end deffn

@node Package FL.ALIEN, Package FL.PARALLEL, Package FL.AMOP, Reference manual
@section Package FL.ALIEN

This package loads some foreign libraries and does set
up a Lisp interface for it.

@node Package FL.PARALLEL, Package FL.MATLISP, Package FL.ALIEN, Reference manual
@section Package FL.PARALLEL

This package provides some Femlisp extensions for parallel execution
building on the BORDEAUX-THREADS and LPARALLEL libraries

@anchor{class-fl.parallel-mutex-mixin}
@deftp Class MUTEX-MIXIN
@tindex MUTEX-MIXIN
A mixin which adds a mutex to every instance of the
class.

Direct slots:
@itemize
@item MUTEX: A mutex for excluding access of other threads.
@end itemize
@end deftp

@anchor{class-fl.parallel-parpool}
@deftp Class PARPOOL
@tindex PARPOOL
A parallel pool implemented as a shared hash-table.
The slot pool contains a hash-table, the test slot contains the hash-table test, the generator contains a function which is called if the pool is empty, i.e. all objects are used and generates a new object for the given argument.

Superclasses: MUTEX-MIXIN

Direct slots:
@itemize
@item TABLE: A table mapping keys to a list of parpool entries
@item PPES: A table mapping an object to its ppe
@item TEST: Self-explanatory.
@end itemize
@end deftp

@anchor{class-fl.parallel-parqueue}
@deftp Class PARQUEUE
@tindex PARQUEUE
A thread-safe queue waiting for input.

Superclasses: QUEUE WAITQUEUE-MIXIN

Direct slots:
@itemize
@item FINISHED-P: Indicator for no-more-input-allowed.
@item MAXIMAL-SIZE: Self-explanatory.
@item CURRENT-SIZE: Self-explanatory.
@end itemize
@end deftp

@anchor{fun-fl.parallel-pwork}
@deffn Function PWORK @var{FUNCTION} &OPTIONAL @var{ARGUMENTS}
@findex PWORK
Distribute a task to each lparallel worker and wait until all finish.
Arguments may be a vector of size equal or smaller than (kernel-worker-count).
All results are collected in a vector of the same size.
@end deffn

@anchor{fun-fl.parallel-register-in-pool}
@deffn Function REGISTER-IN-POOL @var{POOL} @var{KEY} @var{OBJECT}
@findex REGISTER-IN-POOL
Note that the object is only registered, but not put in the pool!
@end deffn

@anchor{class-fl.parallel-waitqueue-mixin}
@deftp Class WAITQUEUE-MIXIN
@tindex WAITQUEUE-MIXIN
Waitqueue mixin.

Superclasses: MUTEX-MIXIN

Direct slots:
@itemize
@item WAITQUEUE: Self-explanatory.
@end itemize
@end deftp

@anchor{macro-fl.parallel-with-accumulators}
@deffn Macro WITH-ACCUMULATORS (@var{NAME} @var{INITIAL-ELEMENT} @var{REDUCE-OP}) &BODY @var{BODY}
@findex WITH-ACCUMULATORS
This macro sets up an array of accumulators for each worker initialized
with initial-element.  Within each worker the symbol @arg{name} can be used
for accessing the private accumulator.
After the body was executed (probably containing parallel operations),
the result array is reduced using @arg{reduce-op}.
@end deffn

@anchor{macro-fl.parallel-with-atomic-output}
@deffn Macro WITH-ATOMIC-OUTPUT &BODY @var{BODY}
@findex WITH-ATOMIC-OUTPUT
If output of a process is desired to be atomic
wrap it in @arg{with-atomic-output}.
@end deffn

@anchor{macro-fl.parallel-with-femlisp-workers}
@deffn Macro WITH-FEMLISP-WORKERS (@var{WORK}) &BODY @var{BODY}
@findex WITH-FEMLISP-WORKERS
This macro distributes work generated in body with calling the locally
bound function @function{work-on} on some arguments to several working
threads which call @arg{func} on those arguments.
@end deffn

@anchor{macro-fl.parallel-with-mutex}
@deffn Macro WITH-MUTEX @var{OBJECT} &BODY @var{BODY}
@findex WITH-MUTEX
Needs to be called unfortunately around push/incf/setf.
@end deffn

@anchor{macro-fl.parallel-with-mutual-exclusion}
@deffn Macro WITH-MUTUAL-EXCLUSION (@var{OBJ}) &BODY @var{BODY}
@findex WITH-MUTUAL-EXCLUSION
Execute @arg{body} on the waitqueue @arg{obj} without other threads
interfering.
@end deffn

@anchor{macro-fl.parallel-with-workers}
@deffn Macro WITH-WORKERS (@var{WORK} &REST @var{KEYWORD-ARGS} &KEY &ALLOW-OTHER-KEYS) &BODY @var{BODY}
@findex WITH-WORKERS
This macro distributes work generated in body with calling the locally
bound function @function{work-on} on some arguments to several working
threads which call @arg{func} on those arguments.
@end deffn

@node Package FL.MATLISP, Package FL.FUNCTION, Package FL.PARALLEL, Reference manual
@section Package FL.MATLISP

This package provides a Common Lisp version of full
  matrices with elements being numbers of a given type.  Those classes are
automatically generated when needed.  It provides also part of the BLAS and
LAPACK operations for those matrices.  The corresponding methods are
automatically compiled for the given matrix classes.  The interface is very
similar to the library Matlisp @cite{(Matlisp)}, which provides a CLOS
interface to the Fortran BLAS and LAPACK routines.

@anchor{var-fl.matlisp-*mzerop-threshold*}
@defvr Variable *MZEROP-THRESHOLD*
@vindex *MZEROP-THRESHOLD*
Threshold below which a matrix is considered to be zero.
@end defvr

@anchor{var-fl.matlisp-*print-matrix*}
@defvr Variable *PRINT-MATRIX*
@vindex *PRINT-MATRIX*
Maximum number of columns and/or rows to print. NIL: no elements, T: all
elements.
@end defvr

@anchor{var-fl.matlisp-*print-matrix-element-format*}
@defvr Variable *PRINT-MATRIX-ELEMENT-FORMAT*
@vindex *PRINT-MATRIX-ELEMENT-FORMAT*
Format of matrix element field to be printed.  A useful format is
  "~10,2,2E" for debugging purposes.
@end defvr

@anchor{var-fl.matlisp-*print-tensor*}
@defvr Variable *PRINT-TENSOR*
@vindex *PRINT-TENSOR*
Maximum number of columns and/or rows to print.  Set this to NIL to
  print no cells (same as *PRINT-ARRAY* set to NIL).  Set this to T
  to print all cells of the tensor.
@end defvr

@anchor{class-fl.matlisp-<matrix>}
@deftp Class <MATRIX>
@tindex <MATRIX>
General matrix class.

Superclasses: <VECTOR>
@end deftp

@anchor{class-fl.matlisp-<sparse-matrix>}
@deftp Class <SPARSE-MATRIX>
@tindex <SPARSE-MATRIX>
Abstract class for sparse matrices.

Superclasses: <MATRIX>
@end deftp

@anchor{class-fl.matlisp-<sparse-tensor>}
@deftp Class <SPARSE-TENSOR>
@tindex <SPARSE-TENSOR>
A general sparse tensor class which is implemented as a
sparse vector containing full-or sparse tensor entries.

Superclasses: TENSOR

Direct slots:
@itemize
@item RANK: Tensor rank.
@item INDICES: The (nonzero) indices of the first slot.
@item ENTRIES: The (nonzero) entries of the first slot.
@end itemize
@end deftp

@anchor{class-fl.matlisp-<sparse-vector>}
@deftp Class <SPARSE-VECTOR>
@tindex <SPARSE-VECTOR>
Abstract class for sparse vectors.

Superclasses: <VECTOR>

Direct slots:
@itemize
@item MULTIPLICITY: Multiplicity of the sparse vector.  A
multiplicity different from 1 is used when handling multiple right-hand sides
and solutions simultaneously.
@end itemize
@end deftp

@anchor{class-fl.matlisp-<submatrix>}
@deftp Class <SUBMATRIX>
@tindex <SUBMATRIX>
Describes an ordered submatrix of a matrix.  Only a
restricted set of operations is allowed for these matrices and element
access is slow.  They are indexed with ordinary integers.

Superclasses: <MATRIX>

Direct slots:
@itemize
@item MATRIX: The "supermatrix".
@item ROW-KEYS: The row indices of the submatrix.
@item COL-KEYS: The column indices of the submatrix.
@end itemize
@end deftp

@anchor{class-fl.matlisp-<vector>}
@deftp Class <VECTOR>
@tindex <VECTOR>
General vector class.
@end deftp

@anchor{fun-fl.matlisp-access-type}
@deffn Function ACCESS-TYPE @var{MAT} &KEY @var{SUGGEST} @var{REQUIRE}
@findex ACCESS-TYPE
If @arg{suggest} and @arg{require} are NIL, returns which of
  @symbol{:row} or @symbol{:column} is prefered for @arg{mat}.  Otherwise
  determine if the order in @arg{suggest} or @arg{require} is acceptable without
  serious performance hit.
@end deffn

@anchor{fun-fl.matlisp-add-svec-to-local-block}
@deffn Function ADD-SVEC-TO-LOCAL-BLOCK @var{SVEC} @var{LOCAL-VEC} &OPTIONAL @var{KEYS} @var{RANGES}
@findex ADD-SVEC-TO-LOCAL-BLOCK
Copies a local block in matlisp format into a <ht-sparse-vector>.
@end deffn

@anchor{fun-fl.matlisp-area-of-span}
@deffn Function AREA-OF-SPAN @var{MAT}
@findex AREA-OF-SPAN
Computes the volume spanned by the columns of @arg{mat}.
@end deffn

@anchor{fun-fl.matlisp-axpy}
@deffn Function AXPY @var{ALPHA} @var{X} @var{Y}
@findex AXPY
Returns alpha X + Y.  Uses AXPY! and COPY.
@end deffn

@anchor{fun-fl.matlisp-axpy!}
@deffn Function AXPY! @var{ALPHA} @var{X} @var{Y}
@findex AXPY!
Y <- alpha*X + Y
@end deffn

@anchor{fun-fl.matlisp-blocks}
@deffn Function BLOCKS @var{VEC}
@findex BLOCKS
Returns a dictionary mapping keys to entries for @arg{vec}.
@end deffn

@anchor{fun-fl.matlisp-col-keys}
@deffn Function COL-KEYS @var{MAT}
@findex COL-KEYS
All column keys for a matrix.
@end deffn

@anchor{fun-fl.matlisp-combined-projection}
@deffn Function COMBINED-PROJECTION @var{P1} @var{P2}
@findex COMBINED-PROJECTION
Returns a projection to the range of the given projections.
@end deffn

@anchor{fun-fl.matlisp-compressed->matlisp}
@deffn Function COMPRESSED->MATLISP @var{CM}
@findex COMPRESSED->MATLISP
Converts a compressed matrix into matlisp format.
@end deffn

@anchor{fun-fl.matlisp-compressed-matrix}
@deffn Function COMPRESSED-MATRIX @var{TYPE}
@findex COMPRESSED-MATRIX
Construct a compressed sparse matrix with entries of @arg{type}.
@end deffn

@anchor{class-fl.matlisp-compressed-matrix}
@deftp Class COMPRESSED-MATRIX
@tindex COMPRESSED-MATRIX
A compressed sparse matrix.  This is an abstract class
which is made concrete by mixing it with a store-vector containing the
entries.

Superclasses: <MATRIX>

Direct slots:
@itemize
@item PATTERN: A compressed pattern.
@end itemize
@end deftp

@anchor{class-fl.matlisp-compressed-pattern}
@deftp Class COMPRESSED-PATTERN
@tindex COMPRESSED-PATTERN
A compressed sparse pattern.  Note: we use int32 vectors
for @slot{starts} and @slot{indices}, such that they do not have to be
copied for a call to the alien sparse solvers.

Direct slots:
@itemize
@item SIZES: Vector of matrix sizes, at the moment only length
2 is allowed here.  The first is the dimension which is not compressed, the
second is the dimension which gets compressed.
@item ORIENTATION: Denotes if rows or columns are compressed.
@item STARTS: Vector with start indices of compressed columns/rows.
@item INDICES: Vector with compressed row/column indices.
@item OFFSETS: Vector of offsets.  This is only non-nil, if
the pattern supports identification.
@end itemize
@end deftp

@anchor{fun-fl.matlisp-copy}
@deffn Function COPY @var{X}
@findex COPY
Returns a deep copy of X.
@end deffn

@anchor{fun-fl.matlisp-copy!}
@deffn Function COPY! @var{X} @var{Y}
@findex COPY!
Y <- X
@end deffn

@anchor{fun-fl.matlisp-det}
@deffn Function DET @var{MAT}
@findex DET
Returns the determinant of the square matrix @arg{mat}.
@end deffn

@anchor{fun-fl.matlisp-det-from-lr}
@deffn Function DET-FROM-LR @var{LR} @var{PIVOT}
@findex DET-FROM-LR
This routine computes the determinant using a given LR decomposition.
@end deffn

@anchor{fun-fl.matlisp-diag}
@deffn Function DIAG @var{VEC}
@findex DIAG
Returns a diagonal matrix with diagonal entries from vec.
@end deffn

@anchor{fun-fl.matlisp-diagonal}
@deffn Function DIAGONAL @var{A}
@findex DIAGONAL
Extracts the diagonal from matrix @arg{A} as a vector.
@end deffn

@anchor{fun-fl.matlisp-diagonal-sparse-tensor}
@deffn Function DIAGONAL-SPARSE-TENSOR @var{VALUES} &OPTIONAL @var{NCOMPS}
@findex DIAGONAL-SPARSE-TENSOR
Constructs a sparse tensor of rank 2 where @arg{values} are the diagonal
entries.  If @arg{ncomps} is given then the tensor dimension is nxn with
each diagonal entry being @arg{values}.
@end deffn

@anchor{fun-fl.matlisp-display}
@deffn Function DISPLAY @var{MATRIX} &KEY (@var{STREAM} @var{T}) @var{ORDER} @var{COL-ORDER} @var{ROW-ORDER} &ALLOW-OTHER-KEYS
@findex DISPLAY
Formats the contents of @arg{matrix} in rectangular
  form.
@end deffn

@anchor{macro-fl.matlisp-docols}
@deffn Macro DOCOLS (@var{KEY} @var{MAT}) &BODY @var{BODY}
@findex DOCOLS
Syntax: @slisp{(docols (key mat) ...)}
@end deffn

@anchor{macro-fl.matlisp-dorows}
@deffn Macro DOROWS (@var{KEY} @var{MAT}) &BODY @var{BODY}
@findex DOROWS
Syntax: @slisp{(dorows (key mat) ...)}
@end deffn

@anchor{fun-fl.matlisp-dot}
@deffn Function DOT @var{X} @var{Y}
@findex DOT
Returns the dot product of X and Y.
@end deffn

@anchor{fun-fl.matlisp-dot-abs}
@deffn Function DOT-ABS @var{X} @var{Y}
@findex DOT-ABS
Returns the dot product between |X| and |Y|.
@end deffn

@anchor{macro-fl.matlisp-dotensor}
@deffn Macro DOTENSOR (@var{ARGS} @var{TENSOR} &KEY @var{DEPTH}) &BODY @var{BODY}
@findex DOTENSOR
Usage:
(dotensor (entry tensor :depth 1) ...)
(dotensor ((index1 ... . entry) tensor :depth 1) ...)
(dotensor ((index1 ...) tensor :depth 1) ...)
@end deffn

@anchor{fun-fl.matlisp-double-vec}
@deffn Function DOUBLE-VEC &REST @var{COMPS}
@findex DOUBLE-VEC
Returns a @class{double-vec} with the entries in @arg{comps}.
@end deffn

@anchor{type-fl.matlisp-double-vec}
@deftp Type DOUBLE-VEC
@tindex DOUBLE-VEC
Uniform @type{double-float} vector.
@end deftp

@anchor{macro-fl.matlisp-dovec}
@deffn Macro DOVEC (@var{LOOP-VARS} @var{VEC} &OPTIONAL @var{RESULT}) &BODY @var{BODY}
@findex DOVEC
Loops on indices and entries of a vector, matrix or tensor.  Examples:
@lisp
  (dovec (entry vec) ...)
  (dovec ((entry key1 ...) vec) ...)
@end lisp
@end deffn

@anchor{fun-fl.matlisp-element-type}
@deffn Function ELEMENT-TYPE @var{VECTOR}
@findex ELEMENT-TYPE
Type of the elements of the vector/matrix.
@end deffn

@anchor{fun-fl.matlisp-ensure-matlisp}
@deffn Function ENSURE-MATLISP @var{OBJ} &OPTIONAL @var{TYPE}
@findex ENSURE-MATLISP
Tries to coerce @arg{obj} into Matlisp format.
@end deffn

@anchor{fun-fl.matlisp-entries}
@deffn Function ENTRIES @var{OBJECT}
@findex ENTRIES
List of entries.
@end deffn

@anchor{fun-fl.matlisp-entry-allowed-p}
@deffn Function ENTRY-ALLOWED-P @var{TENSOR} &REST @var{INDICES}
@findex ENTRY-ALLOWED-P
Tests if an entry is allowed at this position.
@end deffn

@anchor{fun-fl.matlisp-extend-by-identity}
@deffn Function EXTEND-BY-IDENTITY @var{MAT} @var{EXTEND} &KEY @var{IGNORE} (@var{COPY} @var{T})
@findex EXTEND-BY-IDENTITY
Extends A such that the keys in extend which are not in ignore are
mapped to identity.
@end deffn

@anchor{fun-fl.matlisp-extract-if}
@deffn Function EXTRACT-IF @var{TEST} @var{SVEC} &ALLOW-OTHER-KEYS
@findex EXTRACT-IF
Extract a subvector or submatrix from a sparse
  vector/matrix.
@end deffn

@anchor{fun-fl.matlisp-extract-value-blocks}
@deffn Function EXTRACT-VALUE-BLOCKS @var{SOBJ} @var{KEYS} &OPTIONAL @var{COL-KEYS}
@findex EXTRACT-VALUE-BLOCKS
Extract a vector or array of value blocks from @arg{sobj}.
@end deffn

@anchor{fun-fl.matlisp-eye}
@deffn Function EYE @var{N} &OPTIONAL (@var{M} @var{N}) (@var{TYPE} (@var{QUOTE} @var{DOUBLE-FLOAT}))
@findex EYE
Returns the nxn identity matrix.  The value is freshly allocated.
@end deffn

@anchor{fun-fl.matlisp-fill!}
@deffn Function FILL! @var{X} @var{S}
@findex FILL!
Fills X with element s.
@end deffn

@anchor{fun-fl.matlisp-fill-random!}
@deffn Function FILL-RANDOM! @var{X} @var{S}
@findex FILL-RANDOM!
Fills X with random values (obtained by (random s)).
@end deffn

@anchor{fun-fl.matlisp-for-each-col-key}
@deffn Function FOR-EACH-COL-KEY @var{FUNC} @var{MAT}
@findex FOR-EACH-COL-KEY
Loop through column keys.
@end deffn

@anchor{fun-fl.matlisp-for-each-entry}
@deffn Function FOR-EACH-ENTRY @var{FUNC} @var{VEC}
@findex FOR-EACH-ENTRY
Calls @arg{func} on all entries of @arg{vec}.
@end deffn

@anchor{fun-fl.matlisp-for-each-entry-and-key}
@deffn Function FOR-EACH-ENTRY-AND-KEY @var{FUNC} @var{OBJECT}
@findex FOR-EACH-ENTRY-AND-KEY
Calls @arg{func} on all entries of the collection
@arg{object} and their corresponding keys.
@end deffn

@anchor{fun-fl.matlisp-for-each-entry-and-vector-index}
@deffn Function FOR-EACH-ENTRY-AND-VECTOR-INDEX @var{FUNC} @var{VEC}
@findex FOR-EACH-ENTRY-AND-VECTOR-INDEX
Calls @arg{func} on all entries of @arg{vec} and their
corresponding vector indices.  The index used should be unserstood by
@func{vref}.
@end deffn

@anchor{fun-fl.matlisp-for-each-entry-in-col}
@deffn Function FOR-EACH-ENTRY-IN-COL @var{FUNC} @var{MAT} @var{COL-KEY}
@findex FOR-EACH-ENTRY-IN-COL
Loop through entries in column col.
@end deffn

@anchor{fun-fl.matlisp-for-each-entry-in-row}
@deffn Function FOR-EACH-ENTRY-IN-ROW @var{FUNC} @var{MAT} @var{ROW-KEY}
@findex FOR-EACH-ENTRY-IN-ROW
Loop through col-keys in row.
@end deffn

@anchor{fun-fl.matlisp-for-each-key}
@deffn Function FOR-EACH-KEY @var{FUNC} @var{VEC}
@findex FOR-EACH-KEY
Calls @arg{func} on all indices/keys of @arg{vec}.
@end deffn

@anchor{fun-fl.matlisp-for-each-key-and-entry-in-col}
@deffn Function FOR-EACH-KEY-AND-ENTRY-IN-COL @var{FUNC} @var{MAT} @var{COL-KEY}
@findex FOR-EACH-KEY-AND-ENTRY-IN-COL
Loop through row-keys and entries in col.
@end deffn

@anchor{fun-fl.matlisp-for-each-key-and-entry-in-row}
@deffn Function FOR-EACH-KEY-AND-ENTRY-IN-ROW @var{FUNC} @var{MAT} @var{ROW-KEY}
@findex FOR-EACH-KEY-AND-ENTRY-IN-ROW
Loop through col-keys and entries in row.
@end deffn

@anchor{fun-fl.matlisp-for-each-key-in-col}
@deffn Function FOR-EACH-KEY-IN-COL @var{FUNC} @var{MAT} @var{COL-KEY}
@findex FOR-EACH-KEY-IN-COL
Loop through row-keys in column col.
@end deffn

@anchor{fun-fl.matlisp-for-each-key-in-row}
@deffn Function FOR-EACH-KEY-IN-ROW @var{FUNC} @var{MAT} @var{ROW-KEY}
@findex FOR-EACH-KEY-IN-ROW
Loop through col-keys in row.
@end deffn

@anchor{fun-fl.matlisp-for-each-row-key}
@deffn Function FOR-EACH-ROW-KEY @var{FUNC} @var{MAT}
@findex FOR-EACH-ROW-KEY
Loop through row keys.
@end deffn

@anchor{fun-fl.matlisp-full-compressed-pattern}
@deffn Function FULL-COMPRESSED-PATTERN @var{NROWS} @var{NCOLS} &OPTIONAL (@var{ORIENTATION} @var{COLUMN})
@findex FULL-COMPRESSED-PATTERN
Returns a full compressed pattern.
@end deffn

@anchor{fun-fl.matlisp-full-tensor}
@deffn Function FULL-TENSOR @var{TYPE}
@findex FULL-TENSOR
Construct a full tensor with entries of @arg{type}.
@end deffn

@anchor{class-fl.matlisp-full-tensor}
@deftp Class FULL-TENSOR
@tindex FULL-TENSOR
Mixin for full tensors.

Superclasses: TENSOR

Direct slots:
@itemize
@item DIMENSIONS: The dimensions of the tensor.
@item OFFSET0: An initial offset into the store-vector which
defaults to 0.
@item OFFSETS: The offsets for the different dimensions.  This
is internal information computed at tensor construction time.
@end itemize
@end deftp

@anchor{fun-fl.matlisp-gemm}
@deffn Function GEMM @var{ALPHA} @var{X} @var{Y} @var{BETA} @var{Z} &OPTIONAL (@var{JOB} @var{NN})
@findex GEMM
Rewriting of GEMM in terms of GEMM!.
@end deffn

@anchor{fun-fl.matlisp-gemm!}
@deffn Function GEMM! @var{ALPHA} @var{X} @var{Y} @var{BETA} @var{Z} &OPTIONAL (@var{JOB} @var{NN})
@findex GEMM!
Dispatches on the optional job argument (member :nn :tn :nt :tt) and
calls the corresponding generic function, e.g. GEMM-NN!.
@end deffn

@anchor{fun-fl.matlisp-gemm-nn!}
@deffn Function GEMM-NN! @var{A} @var{X} @var{Y} @var{B} @var{Z}
@findex GEMM-NN!
General matrix-matrix multiplication:
@math{Z <- alpha * X * Y + beta * Z}
@end deffn

@anchor{fun-fl.matlisp-gemm-nt!}
@deffn Function GEMM-NT! @var{A} @var{X} @var{Y} @var{B} @var{Z}
@findex GEMM-NT!
General matrix-matrix multiplication:
@math{Z <- alpha * X * Y' + beta * Z}
@end deffn

@anchor{fun-fl.matlisp-gemm-tn!}
@deffn Function GEMM-TN! @var{A} @var{X} @var{Y} @var{B} @var{Z}
@findex GEMM-TN!
General matrix-matrix multiplication:
@math{Z <- alpha * X' * Y + beta * Z}
@end deffn

@anchor{fun-fl.matlisp-gemm-tt!}
@deffn Function GEMM-TT! @var{A} @var{X} @var{Y} @var{B} @var{Z}
@findex GEMM-TT!
General matrix-matrix multiplication:
@math{Z <- alpha * X' * Y' + beta * Z}
@end deffn

@anchor{fun-fl.matlisp-gesv}
@deffn Function GESV @var{A} @var{B}
@findex GESV
Rewriting for GESV in terms of GESV!.
@end deffn

@anchor{fun-fl.matlisp-gesv!}
@deffn Function GESV! @var{A} @var{B}
@findex GESV!
Solves a linear system A X = B for X.
@end deffn

@anchor{fun-fl.matlisp-getrf}
@deffn Function GETRF @var{X} &OPTIONAL @var{IPIV}
@findex GETRF
Rewriting for GETRF in terms of GETRF!.
@end deffn

@anchor{fun-fl.matlisp-getrf!}
@deffn Function GETRF! @var{A} &OPTIONAL @var{IPIV}
@findex GETRF!
Computes the PA=LU decomposition of @arg{A} which is
stored again in @arg{A}.  @arg{ipiv} can be a pre-allocated vector which
the routine fills with the indices for column pivoting, or NIL which
implies that the routine allocates such a vector itself.  If @arg{ipiv} is
@symbol{:none}, no pivoting is done.  Returns @arg{A} as the first value,
the pivot vector as a second value, and a boolean as the third value
indicating that the decomposition succeeded.
@end deffn

@anchor{fun-fl.matlisp-getrs}
@deffn Function GETRS @var{LU} @var{B} &OPTIONAL @var{IPIV}
@findex GETRS
Rewriting for GETRS in terms of GETRS!.
@end deffn

@anchor{fun-fl.matlisp-getrs!}
@deffn Function GETRS! @var{LU} @var{B} &OPTIONAL @var{IPIV}
@findex GETRS!
Solves the PA=LU decomposition specified by @arg{LU} and
@arg{ipiv} for the rhs @arg{b}.  The result is stored in @arg{b}.
@end deffn

@anchor{fun-fl.matlisp-ggev}
@deffn Function GGEV @var{A} @var{B} &OPTIONAL @var{JOB}
@findex GGEV
Syntax: (GGEV A B [job])

Purpose: Computes the generalized eigenvalues and left/right eigenvectors
of @math{A - s B}.

  1. (GGEV A B :N) => lambda

     Computes the generalized eigenvalues of @math{A - s B}.

  2. (GGEV A B :V) => lambda, V, W

     Computes generalized eigenvalues and eigenvectors of (A - sB).

     @math{ A*V = B*V*diag(lambda), \ W'*A = diag(lambda)*W'*B}
            
     with V and W orthogonal (unitary).

Remark: The symmetric/hermitian counterpart of this routine is
@function{hegv}.
@end deffn

@anchor{fun-fl.matlisp-hegv}
@deffn Function HEGV @var{A} @var{B} &OPTIONAL @var{JOB}
@findex HEGV
Syntax: (HEGV A B [job])

Purpose: Computes the generalized eigenvalues and left/right eigenvectors
of @math{A - s B} for Hermitian matrices A and B.

  1. (HEGV A B :N) => lambda

     Computes the generalized eigenvalues of @math{A - s B}.

  2. (HEGV A B :V) => lambda, V

     Computes generalized eigenvalues and eigenvectors of (A - sB).

     @math{ A*V = B*V*diag(lambda), \ W'*A = diag(lambda)*W'*B}
            
     with V and W orthogonal (unitary).

Remark: The non-symmetric counterpart of this routine is
@function{ggev}.
@end deffn

@anchor{fun-fl.matlisp-in-pattern-p}
@deffn Function IN-PATTERN-P @var{TENSOR} &REST @var{INDICES}
@findex IN-PATTERN-P
Returns T, if the indices are in the nonzero pattern.
@end deffn

@anchor{fun-fl.matlisp-index-range-disjoint-p}
@deffn Function INDEX-RANGE-DISJOINT-P @var{MAT1} @var{MAT2}
@findex INDEX-RANGE-DISJOINT-P
Checks if the range of indices of two sparse matrices is disjoint.
@end deffn

@anchor{fun-fl.matlisp-int-vec}
@deffn Function INT-VEC &REST @var{COMPS}
@findex INT-VEC
Returns a @class{int-vec} with the entries in @arg{comps}.
@end deffn

@anchor{type-fl.matlisp-int-vec}
@deftp Type INT-VEC
@tindex INT-VEC
Uniform @type{int} vector.
@end deftp

@anchor{fun-fl.matlisp-join}
@deffn Function JOIN @var{ORIENTATION} &REST @var{MATRICES}
@findex JOIN
Joins @arg{matrices} either horizontally or vertically depending on
@arg{orientation}.  Due to the call to @function{zeros} this is not yet a
generic function.
@end deffn

@anchor{fun-fl.matlisp-join-horizontal!}
@deffn Function JOIN-HORIZONTAL! @var{RESULT} &REST @var{MATRICES}
@findex JOIN-HORIZONTAL!
Joins @arg{matrices} horizontally into result.
@end deffn

@anchor{fun-fl.matlisp-join-instance}
@deffn Function JOIN-INSTANCE @var{ORIENTATION} @var{MATRIX} &REST @var{MATRICES}
@findex JOIN-INSTANCE
Compute an instance for storing the join of
  @arg{orientation} applied to matrix and matrices.
@end deffn

@anchor{fun-fl.matlisp-join-vertical!}
@deffn Function JOIN-VERTICAL! @var{RESULT} &REST @var{MATRICES}
@findex JOIN-VERTICAL!
Joins @arg{matrices} vertically into result.
@end deffn

@anchor{fun-fl.matlisp-key->size}
@deffn Function KEY->SIZE @var{SVEC}
@findex KEY->SIZE
Returns NIL, if @arg{svec} cannot extend automatically when
  being accessed.  Otherwise returns a function mapping keys to vector block
  sizes.
@end deffn

@anchor{fun-fl.matlisp-keys}
@deffn Function KEYS @var{DIC}
@findex KEYS
Returns a list of all keys of @arg{dic}.
@end deffn

@anchor{fun-fl.matlisp-keys-of-column}
@deffn Function KEYS-OF-COLUMN @var{MAT} @var{KEY}
@findex KEYS-OF-COLUMN
All row keys in the given column for a matrix.
@end deffn

@anchor{fun-fl.matlisp-keys-of-row}
@deffn Function KEYS-OF-ROW @var{MAT} @var{KEY}
@findex KEYS-OF-ROW
All column keys in the given row for a matrix.
@end deffn

@anchor{fun-fl.matlisp-l2-norm}
@deffn Function L2-NORM @var{X}
@findex L2-NORM
Returns the 2-norm of @arg{x}.
@end deffn

@anchor{fun-fl.matlisp-laplace-full-matrix}
@deffn Function LAPLACE-FULL-MATRIX @var{N} &OPTIONAL (@var{DIM} 1)
@findex LAPLACE-FULL-MATRIX
Generates the matrix for a @arg{dim}-dimensional Laplace problem
discretized with the @math{2*@arg{dim}+1}-point stencil on a structured
mesh with Dirichlet boundary conditions.
@end deffn

@anchor{fun-fl.matlisp-laplace-sparse-matrix}
@deffn Function LAPLACE-SPARSE-MATRIX @var{N}
@findex LAPLACE-SPARSE-MATRIX
Generates a sparse matrix for a 1-dimensional Laplace problem
discretized with the 3-point stencil on a structured mesh.
@end deffn

@anchor{fun-fl.matlisp-linf-norm}
@deffn Function LINF-NORM @var{X}
@findex LINF-NORM
Returns the maximum norm of @arg{x}.
@end deffn

@anchor{fun-fl.matlisp-lp-norm}
@deffn Function LP-NORM @var{X} @var{P}
@findex LP-NORM
Returns the @arg{p}-norm of @arg{x}.
@end deffn

@anchor{fun-fl.matlisp-m*}
@deffn Function M* @var{X} @var{Y}
@findex M*
Multiply X by Y.
@end deffn

@anchor{fun-fl.matlisp-m*-nt}
@deffn Function M*-NT @var{X} @var{Y}
@findex M*-NT
Multiply X by Y^t.
@end deffn

@anchor{fun-fl.matlisp-m*-product-instance}
@deffn Function M*-PRODUCT-INSTANCE @var{X} @var{Y}
@findex M*-PRODUCT-INSTANCE
Allocates an instance for the product of X and Y.
@end deffn

@anchor{fun-fl.matlisp-m*-tn}
@deffn Function M*-TN @var{X} @var{Y}
@findex M*-TN
Multiply X^t by Y.
@end deffn

@anchor{fun-fl.matlisp-m*-tn-product-instance}
@deffn Function M*-TN-PRODUCT-INSTANCE @var{X} @var{Y}
@findex M*-TN-PRODUCT-INSTANCE
Allocates an instance for the product of X^t and Y.
@end deffn

@anchor{fun-fl.matlisp-m+}
@deffn Function M+ @var{X} @var{Y}
@findex M+
Returns @math{X} + @math{Y}.
@end deffn

@anchor{fun-fl.matlisp-m+!}
@deffn Function M+! @var{X} @var{Y}
@findex M+!
Y <- X + Y
@end deffn

@anchor{fun-fl.matlisp-m-}
@deffn Function M- @var{X} @var{Y}
@findex M-
Returns X-Y.  Uses AXPY.
@end deffn

@anchor{fun-fl.matlisp-m-!}
@deffn Function M-! @var{X} @var{Y}
@findex M-!
Y - X -> Y.  Uses AXPY!.
@end deffn

@anchor{macro-fl.matlisp-m-incf}
@deffn Macro M-INCF @var{RESULT} @var{INCREMENT}
@findex M-INCF
Adds increment to result which should be a symbol.  If its value is nil
then result is set to increment.
@end deffn

@anchor{fun-fl.matlisp-m.*}
@deffn Function M.* @var{X} @var{Y}
@findex M.*
Returns X .* Y.  Uses M.*! and COPY.
@end deffn

@anchor{fun-fl.matlisp-m/}
@deffn Function M/ @var{X}
@findex M/
Returns the inverse of X.
@end deffn

@anchor{fun-fl.matlisp-make-double-vec}
@deffn Function MAKE-DOUBLE-VEC @var{DIM} &OPTIONAL (@var{INIT} 0.0)
@findex MAKE-DOUBLE-VEC
Returns a @class{double-vec} of length @arg{dim} and initial value
@arg{init}.
@end deffn

@anchor{fun-fl.matlisp-make-real-matrix}
@deffn Function MAKE-REAL-MATRIX &REST @var{ARGS}
@findex MAKE-REAL-MATRIX
Generates a real matrix as specified by its arguments.
@end deffn

@anchor{fun-fl.matlisp-make-real-tensor}
@deffn Function MAKE-REAL-TENSOR @var{DIMENSIONS}
@findex MAKE-REAL-TENSOR
Generates an instance of a tensor with DOUBLE-FLOAT entries and the
given @arg{dimensions}.
@end deffn

@anchor{fun-fl.matlisp-make-real-vector}
@deffn Function MAKE-REAL-VECTOR @var{DIM} &OPTIONAL (@var{VALUE} 0.0)
@findex MAKE-REAL-VECTOR
Generates a real matrix of dimension @arg{dim} x 1.
@end deffn

@anchor{fun-fl.matlisp-mat-diff}
@deffn Function MAT-DIFF @var{X} @var{Y}
@findex MAT-DIFF
Prints a list of differences between X and Y.
@end deffn

@anchor{fun-fl.matlisp-matrix-block}
@deffn Function MATRIX-BLOCK @var{SMAT} @var{ROW-KEY} @var{COL-KEY}
@findex MATRIX-BLOCK
Low-level block lookup for a sparse block matrix.
@end deffn

@anchor{fun-fl.matlisp-matrix-column}
@deffn Function MATRIX-COLUMN @var{MAT} @var{COL-KEY}
@findex MATRIX-COLUMN
Returns a dictionary mapping row-key to entry.
@end deffn

@anchor{fun-fl.matlisp-matrix-row}
@deffn Function MATRIX-ROW @var{MAT} @var{ROW-KEY}
@findex MATRIX-ROW
Returns a dictionary mapping col-key to entry.
@end deffn

@anchor{fun-fl.matlisp-matrix-slice}
@deffn Function MATRIX-SLICE @var{X} &KEY @var{FROM-ROW} @var{FROM-COL} @var{NROWS} @var{NCOLS} (@var{NCOLS} (@var{-} (@var{NCOLS} @var{MAT}) @var{FROM-COL})) (@var{NROWS} (@var{-} (@var{NROWS} @var{MAT}) @var{FROM-ROW})) (@var{FROM-COL} 0) (@var{FROM-ROW} 0)
@findex MATRIX-SLICE
Extract a submatrix of size @arg{nrows} @math{times}
@arg{ncols} out of @arg{x} starting from position
@arg{from-row}/@arg{from-col}.
@end deffn

@anchor{fun-fl.matlisp-matrix-transpose-instance}
@deffn Function MATRIX-TRANSPOSE-INSTANCE @var{X}
@findex MATRIX-TRANSPOSE-INSTANCE
Returns a zero matrix for storing the transpose of X.
@end deffn

@anchor{fun-fl.matlisp-mequalp}
@deffn Function MEQUALP @var{X} @var{Y}
@findex MEQUALP
Returns T if X and Y have equal entries, otherwise NIL.
@end deffn

@anchor{fun-fl.matlisp-mextract!}
@deffn Function MEXTRACT! @var{X} @var{Y} @var{ROW-OFFSET} @var{COL-OFFSET}
@findex MEXTRACT!
Extract matrix X out of matrix Y from the position given
by ROW-OFFSET and COL-OFFSET.
@end deffn

@anchor{fun-fl.matlisp-midentity-p}
@deffn Function MIDENTITY-P @var{NUMBER} &OPTIONAL @var{THRESHOLD}
@findex MIDENTITY-P
Returns T, if @arg{mat} is the identity, i.e. if the
  elementwise difference to the identity is not larger than
  @arg{threshold}.
@end deffn

@anchor{fun-fl.matlisp-minject!}
@deffn Function MINJECT! @var{X} @var{Y} @var{ROW-OFFSET} @var{COL-OFFSET}
@findex MINJECT!
Inject matrix X in matrix Y at the position given by
ROW-OFFSET and COL-OFFSET.
@end deffn

@anchor{fun-fl.matlisp-mrandom}
@deffn Function MRANDOM @var{N} &OPTIONAL @var{M} (@var{TYPE} (@var{QUOTE} @var{DOUBLE-FLOAT})) (@var{RANGE} 1.0)
@findex MRANDOM
Returns a random nxn or (if m is provided) nxm matrix.  The value is
freshly allocated.
@end deffn

@anchor{fun-fl.matlisp-mref}
@deffn Function MREF @var{A} @var{I} @var{J}
@findex MREF
Returns the matrix element @code{A[i,j]}.
@end deffn

@anchor{fun-fl.matlisp-msquare-p}
@deffn Function MSQUARE-P @var{MAT}
@findex MSQUARE-P
Returns T, iff @arg{mat} is square.
@end deffn

@anchor{fun-fl.matlisp-msymmetric-p}
@deffn Function MSYMMETRIC-P @var{MAT} &KEY @var{THRESHOLD} @var{OUTPUT} (@var{THRESHOLD} 0.0)
@findex MSYMMETRIC-P
Returns T, if @arg{mat} is symmetric up to a accuracy in THRESHOLD.
If output is T, the differences to symmetry are reported.
@end deffn

@anchor{fun-fl.matlisp-multiplicity}
@deffn Function MULTIPLICITY @var{VEC}
@findex MULTIPLICITY
We allow multiple vectors, for solving linear problems
in parallel.
@end deffn

@anchor{fun-fl.matlisp-mzerop}
@deffn Function MZEROP @var{X} &OPTIONAL @var{THRESHOLD}
@findex MZEROP
Returns T if each entry of @arg{x} is smaller or equal
than @arg{threshold}.
@end deffn

@anchor{fun-fl.matlisp-ncols}
@deffn Function NCOLS @var{MAT}
@findex NCOLS
Number of matrix columns.
@end deffn

@anchor{fun-fl.matlisp-norm}
@deffn Function NORM @var{X} &OPTIONAL @var{P}
@findex NORM
Returns the @arg{p}-norm of @arg{x}.
@end deffn

@anchor{fun-fl.matlisp-normalize}
@deffn Function NORMALIZE @var{X} &OPTIONAL (@var{P} 2)
@findex NORMALIZE
Scales @arg{x} to have @arg{p}-norm equal to 1.
@end deffn

@anchor{fun-fl.matlisp-normalize!}
@deffn Function NORMALIZE! @var{X} &OPTIONAL (@var{P} 2)
@findex NORMALIZE!
Scales @arg{x} destructively to have @arg{p}-norm equal to 1.
@end deffn

@anchor{fun-fl.matlisp-nr-of-entries}
@deffn Function NR-OF-ENTRIES @var{VECTOR}
@findex NR-OF-ENTRIES
Total number of (block) entries for vectors.
@end deffn

@anchor{fun-fl.matlisp-nrows}
@deffn Function NROWS @var{MAT}
@findex NROWS
Number of matrix rows.
@end deffn

@anchor{fun-fl.matlisp-number-of-nonzero-entries}
@deffn Function NUMBER-OF-NONZERO-ENTRIES @var{PATTERN}
@findex NUMBER-OF-NONZERO-ENTRIES
Number of nonzero entries of a sparse matrix pattern.
@end deffn

@anchor{fun-fl.matlisp-ones}
@deffn Function ONES @var{N} &OPTIONAL (@var{M} @var{N}) (@var{TYPE} (@var{QUOTE} @var{DOUBLE-FLOAT}))
@findex ONES
Returns nxn or (if m is provided) nxm ones.  The value is freshly
allocated.
@end deffn

@anchor{fun-fl.matlisp-range-and-domain-disjoint-p}
@deffn Function RANGE-AND-DOMAIN-DISJOINT-P @var{MAT}
@findex RANGE-AND-DOMAIN-DISJOINT-P
Checks if index range and index domain of some matrix are disjoint.
@end deffn

@anchor{fun-fl.matlisp-rank}
@deffn Function RANK @var{TENSOR}
@findex RANK
Rank of a tensor.
@end deffn

@anchor{fun-fl.matlisp-remove-column}
@deffn Function REMOVE-COLUMN @var{SMAT} @var{COL-KEY}
@findex REMOVE-COLUMN
Removes a column of @arg{smat}.
@end deffn

@anchor{fun-fl.matlisp-remove-key}
@deffn Function REMOVE-KEY @var{SOBJ} &REST @var{INDICES}
@findex REMOVE-KEY
Remove the entry for @arg{key} from the sparse object.
@end deffn

@anchor{fun-fl.matlisp-remove-row}
@deffn Function REMOVE-ROW @var{SMAT} @var{ROW-KEY}
@findex REMOVE-ROW
Removes a row of @arg{smat}.
@end deffn

@anchor{fun-fl.matlisp-row-keys}
@deffn Function ROW-KEYS @var{MAT}
@findex ROW-KEYS
All row keys for a matrix.
@end deffn

@anchor{fun-fl.matlisp-row<-id}
@deffn Function ROW<-ID @var{A} @var{KEY}
@findex ROW<-ID
Set the row of matrix A defined by KEY to identity
@end deffn

@anchor{fun-fl.matlisp-scal}
@deffn Function SCAL @var{ALPHA} @var{X}
@findex SCAL
Returns alpha * X.  Uses SCAL! and COPY.
@end deffn

@anchor{fun-fl.matlisp-scal!}
@deffn Function SCAL! @var{ALPHA} @var{X}
@findex SCAL!
X <- alpha X
@end deffn

@anchor{fun-fl.matlisp-scalar-type}
@deffn Function SCALAR-TYPE @var{VECTOR}
@findex SCALAR-TYPE
Type of the scalars for the vector class.
@end deffn

@anchor{fun-fl.matlisp-set-svec-to-local-block}
@deffn Function SET-SVEC-TO-LOCAL-BLOCK @var{SVEC} @var{LOCAL-VEC} &OPTIONAL @var{KEYS} @var{RANGES}
@findex SET-SVEC-TO-LOCAL-BLOCK
Copies a local block in matlisp format into a <sparse-vector>.
@end deffn

@anchor{fun-fl.matlisp-shift-diagonal-inverter}
@deffn Function SHIFT-DIAGONAL-INVERTER @var{ETA}
@findex SHIFT-DIAGONAL-INVERTER
Can be used for obtainint a diagonal modification to get ILU_mod.
@end deffn

@anchor{fun-fl.matlisp-show}
@deffn Function SHOW @var{MATRIX} &KEY (@var{STREAM} @var{T}) @var{KEYS} (@var{ZEROS} @var{T}) &ALLOW-OTHER-KEYS
@findex SHOW
Shows the contents of @arg{matrix} in a readable form.
@end deffn

@anchor{fun-fl.matlisp-slice}
@deffn Function SLICE @var{TENSOR} @var{FIXED}
@findex SLICE
Slices @arg{tensor}.  @arg{fixed} determines which indices are fixed.
@end deffn

@anchor{fun-fl.matlisp-sparse-ldu}
@deffn Function SPARSE-LDU @var{A} &KEY @var{ORDERING} @var{INCOMPLETE} (@var{OMEGA} 0.0) @var{DIAGONAL-INVERTER} &ALLOW-OTHER-KEYS
@findex SPARSE-LDU
Sparse LDU decomposition
@end deffn

@anchor{fun-fl.matlisp-sparse-m*}
@deffn Function SPARSE-M* @var{A} @var{B} &KEY @var{JOB} @var{SPARSITY} (@var{SPARSITY} @var{A}) (@var{JOB} @var{NN})
@findex SPARSE-M*
Sparse matrix-matrix or matrix-vector multiplication.
Usually, m* should be used.  But in situations, where A or B are very
sparse, the complexity of this routine is much lower.
@end deffn

@anchor{fun-fl.matlisp-sparse-matrix->ccs}
@deffn Function SPARSE-MATRIX->CCS @var{A} &KEY @var{KEYS} @var{ROW-KEYS} @var{COL-KEYS} @var{RANGES} @var{ROW-RANGES} @var{COL-RANGES}
@findex SPARSE-MATRIX->CCS
Converts the sparse matrix @arg{A} to CCS format.  @arg{row-keys} and
@arg{col-keys} may denote a submatrix, @arg{col-ranges} and
@arg{row-ranges} may be used for extracting even subblocks of the entries.
This is a rather difficult routine, which might suggest switching to CCS
completely.
@end deffn

@anchor{fun-fl.matlisp-sparse-matrix->matlisp}
@deffn Function SPARSE-MATRIX->MATLISP @var{MAT} &KEY @var{KEYS} @var{ROW-KEYS} @var{COL-KEYS} @var{RANGES} @var{ROW-RANGES} @var{COL-RANGES} &ALLOW-OTHER-KEYS
@findex SPARSE-MATRIX->MATLISP
Converts sparse matrices into matlisp format.
@end deffn

@anchor{fun-fl.matlisp-sparse-tensor}
@deffn Function SPARSE-TENSOR @var{CONTENTS}
@findex SPARSE-TENSOR
Constructor for @class{sparse-tensor}.
@end deffn

@anchor{fun-fl.matlisp-sparse-vector->matlisp}
@deffn Function SPARSE-VECTOR->MATLISP @var{SVEC} &OPTIONAL @var{KEYS} @var{RANGES}
@findex SPARSE-VECTOR->MATLISP
Transforms all or a part of @arg{svec} corresponding to the keys in
@arg{keys} and maybe the ranges in 'ranges' to a matlisp matrix.
@end deffn

@anchor{fun-fl.matlisp-standard-matrix}
@deffn Function STANDARD-MATRIX @var{TYPE}
@findex STANDARD-MATRIX
Defines the programmatic class @class{standard-matrix} for element type
@arg{type} as extensions of the programmatic class @class{store-vector}.
@end deffn

@anchor{class-fl.matlisp-standard-matrix}
@deftp Class STANDARD-MATRIX
@tindex STANDARD-MATRIX
Mixin for dense matrices.

Superclasses: <MATRIX>

Direct slots:
@itemize
@item NROWS: Number of rows in the matrix
@item NCOLS: Number of columns in the matrix
@end itemize
@end deftp

@anchor{fun-fl.matlisp-standard-matrix-p}
@deffn Function STANDARD-MATRIX-P @var{OBJ}
@findex STANDARD-MATRIX-P
Tests if @arg{obj} is a @class{standard-matrix}.
@end deffn

@anchor{class-fl.matlisp-store-vector}
@deftp Class STORE-VECTOR
@tindex STORE-VECTOR
This mixin yields vector behaviour for a class
containing a store.  The store is a unifom array with elements of a certain
type which can be determined by the funtion @function{element-type}.  It
often is but does not have to be equal to the type of scalars for this
vector which can be obtained by calling the function
@function{scalar-type}.

Superclasses: <VECTOR>

Direct slots:
@itemize
@item STORE: The vector entries.
@end itemize
@end deftp

@anchor{fun-fl.matlisp-submatrix}
@deffn Function SUBMATRIX @var{MAT} &KEY @var{ROW-INDICES} @var{COL-INDICES}
@findex SUBMATRIX
General extraction of submatrices specified
by non-adjacent lists of row- and column indices.
@end deffn

@anchor{fun-fl.matlisp-t*}
@deffn Function T* @var{TENSOR1} @var{TENSOR2} @var{CONTRACTION-PAIRS}
@findex T*
Contracts TENSOR1 and TENSOR2 along the pairs of indices specified by CONTRACTION-PAIRS.
@end deffn

@anchor{class-fl.matlisp-tensor}
@deftp Class TENSOR
@tindex TENSOR
Tensor superclass.
@end deftp

@anchor{fun-fl.matlisp-tensor-for-each}
@deffn Function TENSOR-FOR-EACH @var{FUNC} @var{TENSOR} &KEY @var{JOB} @var{DEPTH} (@var{JOB} @var{BOTH}) &ALLOW-OTHER-KEYS
@findex TENSOR-FOR-EACH
Applies @arg{func} to each index of @arg{tensor} up to
  @arg{depth}.  @arg{job} can be :entry, :index, or :both.
@end deffn

@anchor{fun-fl.matlisp-tensor-map}
@deffn Function TENSOR-MAP @var{FUNC} @var{TENSOR}
@findex TENSOR-MAP
Maps @arg{tensor} with @arg{func} to a tensor of the
same type.
@end deffn

@anchor{fun-fl.matlisp-tensor-ref}
@deffn Function TENSOR-REF @var{TENSOR} &REST @var{INDICES}
@findex TENSOR-REF
Reader for a tensor entry.
@end deffn

@anchor{fun-fl.matlisp-total-entries}
@deffn Function TOTAL-ENTRIES @var{VECTOR}
@findex TOTAL-ENTRIES
Total number of entries for block vectors.
@end deffn

@anchor{fun-fl.matlisp-total-nrows}
@deffn Function TOTAL-NROWS @var{MAT}
@findex TOTAL-NROWS
Total number of rows for a matrix (works also for block
  matrices).
@end deffn

@anchor{fun-fl.matlisp-transpose}
@deffn Function TRANSPOSE @var{X}
@findex TRANSPOSE
Transpose the matrix @arg{x}.
@end deffn

@anchor{fun-fl.matlisp-transpose!}
@deffn Function TRANSPOSE! @var{X} @var{Y}
@findex TRANSPOSE!
Sets Y to the transpose of X.
@end deffn

@anchor{fun-fl.matlisp-transposed-pattern}
@deffn Function TRANSPOSED-PATTERN @var{PATTERN}
@findex TRANSPOSED-PATTERN
Transpose a sparse matrix pattern.
@end deffn

@anchor{fun-fl.matlisp-uint-vec}
@deffn Function UINT-VEC &REST @var{COMPS}
@findex UINT-VEC
Returns a @class{uint-vec} with the entries in @arg{comps}.
@end deffn

@anchor{type-fl.matlisp-uint-vec}
@deftp Type UINT-VEC
@tindex UINT-VEC
Uniform @type{uint} vector.
@end deftp

@anchor{fun-fl.matlisp-unit-vector}
@deffn Function UNIT-VECTOR @var{DIM} @var{I}
@findex UNIT-VECTOR
Returns a freshly created copy of the @arg{i}-th carthesian unit vector
in dimension @arg{dim}.
@end deffn

@anchor{fun-fl.matlisp-vector-block}
@deffn Function VECTOR-BLOCK @var{SVEC} @var{KEY}
@findex VECTOR-BLOCK
Low-level key lookup.  Returns NIL if there is no block at
  this position.
@end deffn

@anchor{fun-fl.matlisp-vector-slice}
@deffn Function VECTOR-SLICE @var{X} @var{OFFSET} @var{SIZE}
@findex VECTOR-SLICE
Extract a subvector of size @arg{size} out of @arg{x}
starting from position @arg{offset}.
@end deffn

@anchor{fun-fl.matlisp-vlength}
@deffn Function VLENGTH @var{VEC}
@findex VLENGTH
Length of vector.
@end deffn

@anchor{fun-fl.matlisp-vref}
@deffn Function VREF @var{X} @var{I}
@findex VREF
Reader for @math{x_i}.
@end deffn

@anchor{fun-fl.matlisp-x<-0}
@deffn Function X<-0 @var{X}
@findex X<-0
X <- 0 X.  Uses SCAL!.
@end deffn

@anchor{fun-fl.matlisp-zeros}
@deffn Function ZEROS @var{N} &OPTIONAL (@var{M} @var{N}) (@var{TYPE} (@var{QUOTE} @var{DOUBLE-FLOAT}))
@findex ZEROS
Returns nxn or (if m is provided) nxm zeros.  The value is freshly
allocated.
@end deffn

@node Package FL.FUNCTION, Package FL.MESH, Package FL.MATLISP, Reference manual
@section Package FL.FUNCTION

NIL

@anchor{class-fl.function-<constant-function>}
@deftp Class <CONSTANT-FUNCTION>
@tindex <CONSTANT-FUNCTION>
For a <constant-function> evaluation and derivative
computation are trivial.

Superclasses: <FUNCTION>

Direct slots:
@itemize
@item VALUE: Self-explanatory.
@end itemize
@end deftp

@anchor{class-fl.function-<function>}
@deftp Class <FUNCTION>
@tindex <FUNCTION>
The <function> class is an abstract class for a general
function.  This function will usually accept vector arguments, the dimensions of
domain and image are fixed when defining the function. If the function is
differentiable, the gradient matrix can be obtained by evaluating the gradient
slot.

Direct slots:
@itemize
@item DOMAIN-DIMENSION: Self-explanatory.
@item IMAGE-DIMENSION: Self-explanatory.
@end itemize
@end deftp

@anchor{class-fl.function-<linear-function>}
@deftp Class <LINEAR-FUNCTION>
@tindex <LINEAR-FUNCTION>
A <linear-function> is determined by a matrix A and a
vector b.  It represents the map @math{x -> Ax+b}.

Superclasses: <FUNCTION>

Direct slots:
@itemize
@item A: Self-explanatory.
@item B: Self-explanatory.
@end itemize
@end deftp

@anchor{class-fl.function-<periodic-polygon>}
@deftp Class <PERIODIC-POLYGON>
@tindex <PERIODIC-POLYGON>
This class implements a periodic polygon.

Superclasses: <POLYGON>
@end deftp

@anchor{class-fl.function-<polygon>}
@deftp Class <POLYGON>
@tindex <POLYGON>
This class implements a function which maps the unit
interval to a polygon.

Superclasses: <FUNCTION>

Direct slots:
@itemize
@item POINTS: A vector of points for the polygon.
@end itemize
@end deftp

@anchor{class-fl.function-<special-function>}
@deftp Class <SPECIAL-FUNCTION>
@tindex <SPECIAL-FUNCTION>
A <special-function> provides its own evaluation and gradient
computation.

Superclasses: <FUNCTION>

Direct slots:
@itemize
@item EVALUATOR: Self-explanatory.
@item GRADIENT: Self-explanatory.
@item JET: Self-explanatory.
@end itemize
@end deftp

@anchor{fun-fl.function-circle-function}
@deffn Function CIRCLE-FUNCTION &OPTIONAL (@var{RADIAL-DISTANCE} 1.0) (@var{MIDPOINT} (@var{COERCE} (@var{QUOTE} (0.0 0.0)) (@var{QUOTE} @var{DOUBLE-VEC}))) (@var{OMEGA} 1.0) (@var{PHI0} 0.0)
@findex CIRCLE-FUNCTION
Returns a special function drawing a polar around @arg{midpoint} with
distance given by the function or number @arg{radial-distance} with angular
velocity omega.  Without arguments it yields a function mapping @math{R^1}
isometrically to @math{S^1}.
@end deffn

@anchor{fun-fl.function-cubic-spline}
@deffn Function CUBIC-SPLINE @var{Y}
@findex CUBIC-SPLINE
On a regular partition of the unit interval interpolating values y are
given.  This function returns an interpolating spline.
@end deffn

@anchor{fun-fl.function-degree}
@deffn Function DEGREE @var{POLY}
@findex DEGREE
Degree of a polynomial
@end deffn

@anchor{fun-fl.function-differentiable-p}
@deffn Function DIFFERENTIABLE-P @var{F} &OPTIONAL @var{K}
@findex DIFFERENTIABLE-P
Returns t if f is differentiable or differentiable of the
given degree.
@end deffn

@anchor{fun-fl.function-differentiate}
@deffn Function DIFFERENTIATE @var{POLY} @var{INDEX}
@findex DIFFERENTIATE
Differentiate a multivariate polynomial wrt the variable given by INDEX.
@end deffn

@anchor{fun-fl.function-ellipse-matrix}
@deffn Function ELLIPSE-MATRIX @var{RADIUS} @var{EXCENTRICITY} @var{PHI}
@findex ELLIPSE-MATRIX
Returns a matrix A suitable for describing the ellipse as (Ax,x)=1.
@end deffn

@anchor{fun-fl.function-evaluate}
@deffn Function EVALUATE @var{F} @var{X}
@findex EVALUATE
Generic evaluation of functions on an argument.  Numbers and
arrays are treated as constants.  Special evaluation is defined for multivariate
polynomials on vectors and for <function> objects.
@end deffn

@anchor{fun-fl.function-evaluate-gradient}
@deffn Function EVALUATE-GRADIENT @var{F} @var{X}
@findex EVALUATE-GRADIENT
Generic evaluation of gradients of differentiable functions.
@end deffn

@anchor{fun-fl.function-homotopy}
@deffn Function HOMOTOPY @var{FUNC1} @var{FUNC2}
@findex HOMOTOPY
Returns a function which uses its first coordinate as a homotopy
parameter.
@end deffn

@anchor{fun-fl.function-interval-method}
@deffn Function INTERVAL-METHOD @var{FUNC} @var{A} @var{B} @var{ACCURACY}
@findex INTERVAL-METHOD
Finds zeros of functions in 1d by the interval method.
@end deffn

@anchor{fun-fl.function-make-polynomial}
@deffn Function MAKE-POLYNOMIAL @var{COEFFS}
@findex MAKE-POLYNOMIAL
Constructor which simplifies the coefficient list.
@end deffn

@anchor{fun-fl.function-maximal-partial-degree}
@deffn Function MAXIMAL-PARTIAL-DEGREE @var{POLY}
@findex MAXIMAL-PARTIAL-DEGREE
Maximal partial degree of a polynomial.
@end deffn

@anchor{fun-fl.function-multiple-evaluate}
@deffn Function MULTIPLE-EVALUATE @var{FUNC} @var{POSITIONS}
@findex MULTIPLE-EVALUATE
Multiple evaluations of @arg{func} may be optimized.
@end deffn

@anchor{fun-fl.function-multiple-evaluate-gradient}
@deffn Function MULTIPLE-EVALUATE-GRADIENT @var{F} @var{POSITIONS}
@findex MULTIPLE-EVALUATE-GRADIENT
Multiple evaluations may be optimized.
@end deffn

@anchor{fun-fl.function-n-variate-monomials-of-degree}
@deffn Function N-VARIATE-MONOMIALS-OF-DEGREE @var{N} @var{DEGREE} &OPTIONAL (@var{TYPE} (@var{QUOTE} @var{=}))
@findex N-VARIATE-MONOMIALS-OF-DEGREE
Returns n-variate monomials of degree being equal or being lower or
equal than deg.
Examples:
 (n-variate-monomials-of-degree 2 2) -> (x2^2 x1*x2 x1^2)
 (n-variate-monomials-of-degree 2 2 '<=)  -> (1 x2 x1 x2^2 x1*x2 x1^2)
@end deffn

@anchor{fun-fl.function-numerical-complex-derivative}
@deffn Function NUMERICAL-COMPLEX-DERIVATIVE @var{F}
@findex NUMERICAL-COMPLEX-DERIVATIVE
Computes a very accurate real derivative for functions which can be
applied to complex arguments.
@end deffn

@anchor{fun-fl.function-numerical-gradient}
@deffn Function NUMERICAL-GRADIENT @var{FUNC} &KEY (@var{SHIFT} 1.e-6)
@findex NUMERICAL-GRADIENT
Computes the numerical gradient of func at pos.
@end deffn

@anchor{fun-fl.function-partial-degree}
@deffn Function PARTIAL-DEGREE @var{POLY} @var{INDEX}
@findex PARTIAL-DEGREE
Partial degree in variable INDEX of a multivariate polynomial.
@end deffn

@anchor{fun-fl.function-poly*}
@deffn Function POLY* @var{P1} @var{P2}
@findex POLY*
Multiplies two polynomials P1 and P2.
@end deffn

@anchor{fun-fl.function-poly-expt}
@deffn Function POLY-EXPT @var{P} @var{N}
@findex POLY-EXPT
Raises the polynomial P to power N.
@end deffn

@anchor{class-fl.function-polynomial}
@deftp Class POLYNOMIAL
@tindex POLYNOMIAL
Multivariate polynomial.  The coefficients are
represented as nested lists.

Superclasses: <VECTOR>

Direct slots:
@itemize
@item COEFFS: Self-explanatory.
@end itemize
@end deftp

@anchor{fun-fl.function-project-to-ellipsoid}
@deffn Function PROJECT-TO-ELLIPSOID @var{MIDPOINT} @var{A}
@findex PROJECT-TO-ELLIPSOID
Returns a function which projects to the ellipsoid given by
Q(x-midpoint)=1 where Q is the quadratic form associated with the matrix
A.
@end deffn

@anchor{fun-fl.function-project-to-sphere}
@deffn Function PROJECT-TO-SPHERE @var{MIDPOINT} @var{RADIUS}
@findex PROJECT-TO-SPHERE
Returns a function which projects to the sphere with given midpoint and
radius.
@end deffn

@anchor{fun-fl.function-shift-polynomial}
@deffn Function SHIFT-POLYNOMIAL @var{POLY} @var{DIM}
@findex SHIFT-POLYNOMIAL
Shifts a polynomial in dimension, e.g. x_1 becomes x_2.
@end deffn

@anchor{fun-fl.function-sparse-real-derivative}
@deffn Function SPARSE-REAL-DERIVATIVE @var{SPARSE-F}
@findex SPARSE-REAL-DERIVATIVE
Warning: works only for real-valued functions!
@end deffn

@anchor{fun-fl.function-special-1d-function}
@deffn Function SPECIAL-1D-FUNCTION @var{F} &OPTIONAL @var{DF}
@findex SPECIAL-1D-FUNCTION
Constructs a special function between 1D-spaces from ordinary Lisp
functions.
@end deffn

@anchor{fun-fl.function-total-degree}
@deffn Function TOTAL-DEGREE @var{POLY}
@findex TOTAL-DEGREE
Degree of a multivariate polynomial
@end deffn

@anchor{fun-fl.function-unit}
@deffn Function UNIT @var{F}
@findex UNIT
Generates a unit of the same kind as @arg{F}.
@end deffn

@anchor{fun-fl.function-xn-distortion-function}
@deffn Function XN-DISTORTION-FUNCTION @var{F} @var{GRAD-F} @var{DIM}
@findex XN-DISTORTION-FUNCTION
Returns a function which distorts the xn-coordinate by a factor f(x').
Also grad-f has to be provided.
@end deffn

@anchor{fun-fl.function-zero}
@deffn Function ZERO @var{F}
@findex ZERO
Generates a zero of the same kind as @arg{F}.
@end deffn

@node Package FL.MESH, Package FL.PROBLEM, Package FL.FUNCTION, Reference manual
@section Package FL.MESH

This module contains the definitions of meshes and
routines for mesh management.  The meshes allowed in @femlisp{} are more
general than those of most other software for solving PDEs.  In @femlisp{},
both mesh, domain and problem definitions are defined over an underlying
abstraction, the so-called @class{<skeleton>}.  A @class{<skeleton>}
captures the mathematical idea of a "cell complex" which builds a
topological space by mapping from standard cells @class{<cell>}.  Now, a
@class{<skeleton>} can be seen as mapping the cells of such a cell complex
to arbitrary values.  Then, a @class{<domain>} is a @class{<skeleton>}
where each cell (which we call "patch" in this case) is mapped to
geometric properties, and a @class{<mesh>} is a @class{<skeleton>} where
each cell is mapped to the patch to which it belongs.

The basic entities are the class @class{<cell>}, the subclass
@class{<simplex>} which in turn contains subclasses for arbitrarily
dimensional simplices generated on demand, and the subclass
@class{<product-cell>} containing arbitrary products of simplices, e.g. square
or cube.

Meshes can be refined either uniformly or locally using the Freudenthal
algorithm as presented in @cite{JBey_2000a} and generalized to product
elements.  When local refinement is used, hanging nodes may occur.  In
contrast to most other finite element software, in @femlisp{} the
difference of refinement levels of adjacent cells may be arbitrarily large.
Up to now, anisotropic refinement of product cells has not yet been
implemented.

@anchor{var-fl.mesh-*reference-vertex*}
@defvr Variable *REFERENCE-VERTEX*
@vindex *REFERENCE-VERTEX*
The reference vertex.
@end defvr

@anchor{class-fl.mesh-<boundary-cell>}
@deftp Class <BOUNDARY-CELL>
@tindex <BOUNDARY-CELL>
This cell is only fuzzily defined.  Its use is mostly
for defining domains by their boundary.  The slot @slot{midpoint} can be
useful for the graphical output of the cell, the slot @slot{holes} contains
a list of points lying inside holes.  This is intended as help for
triangulation programs.

Superclasses: <CELL-WITH-BOUNDARY>

Direct slots:
@itemize
@item DIMENSION: Self-explanatory.
@item MIDPOINT: Self-explanatory.
@item HOLES: Self-explanatory.
@end itemize
@end deftp

@anchor{class-fl.mesh-<cell>}
@deftp Class <CELL>
@tindex <CELL>
The basic cell class.
@end deftp

@anchor{class-fl.mesh-<domain>}
@deftp Class <DOMAIN>
@tindex <DOMAIN>
A @class{<domain>} is a special @class{<skeleton>}.  We
call its cells @emph{patches}, and the properties of a patch carries
geometric information.  Properties supported up to now are:

@itemize
@item @code{IDENTIFIED}: @emph{list of identified patches}
@item @code{EXTENSION}: @emph{extender}
@item @code{METRIC}: @emph{metric tensor function}
@item @code{VOLUME}: @emph{volume function}
@end itemize

Metric and volume should be functions depending on keyword arguments like
@code{:LOCAL} and @code{:GLOBAL} and allowing arbitrary other keys.

Superclasses: <SKELETON> PROPERTY-MIXIN

Direct slots:
@itemize
@item CLASSIFIERS: A list of functions of two arguments -patch and classifications so
far- which are called from the right to classify the patch.
@end itemize
@end deftp

@anchor{class-fl.mesh-<hierarchical-mesh>}
@deftp Class <HIERARCHICAL-MESH>
@tindex <HIERARCHICAL-MESH>
Hierarchical-meshes are those meshes which will be used
most often, because they remember the refinement history and therefore
allow for refinement and coarsening.  The slot levels is an array of
skeletons containing the cells for different levels.

Superclasses: <MESH>

Direct slots:
@itemize
@item LEVELS: Self-explanatory.
@end itemize
@end deftp

@anchor{class-fl.mesh-<mapped-cell>}
@deftp Class <MAPPED-CELL>
@tindex <MAPPED-CELL>
A mixin which distinguishes cells which are mapped by a
special mapping.

Direct slots:
@itemize
@item MAPPING: Self-explanatory.
@end itemize
@end deftp

@anchor{class-fl.mesh-<mesh>}
@deftp Class <MESH>
@tindex <MESH>
A <mesh> is a special <skeleton> mapping cells to
property lists with properties of the cell.  The most important property of
a cell is its patch in the domain.  Another one could be a list of possibly
identified cells.  The slot parametric determines which kind of cell
mappings are used for approximating the domain.  These can be the nonlinear
mappings used in the domain definition, but also arbitrary approximations,
to those mappings, e.g. isoparametric mappings.  The special value NIL
means that multilinear mappings are used for all cells outside the
boundaries.

Superclasses: <SKELETON>

Direct slots:
@itemize
@item DOMAIN: The domain of the mesh.
@item PARAMETRIC: Self-explanatory.
@end itemize
@end deftp

@anchor{class-fl.mesh-<product-cell>}
@deftp Class <PRODUCT-CELL>
@tindex <PRODUCT-CELL>
A mixin for simplex-product cells.
@end deftp

@anchor{class-fl.mesh-<simplex>}
@deftp Class <SIMPLEX>
@tindex <SIMPLEX>
A mixin for simplicial cells.
@end deftp

@anchor{class-fl.mesh-<skeleton>}
@deftp Class <SKELETON>
@tindex <SKELETON>
A skeleton is a vector of hash-tables containing the
cells of a certain dimension as keys.  The information stored in the
values is different depending on the subclass derived from skeleton.

Superclasses: PROPERTY-MIXIN

Direct slots:
@itemize
@item DIMENSION: Self-explanatory.
@item ETABLES: Self-explanatory.
@end itemize
@end deftp

@anchor{class-fl.mesh-<vertex>}
@deftp Class <VERTEX>
@tindex <VERTEX>
The vertex class.

Superclasses: <CELL>

Direct slots:
@itemize
@item CELL-CLASS-INFORMATION: Self-explanatory.
@item POSITION: Self-explanatory.
@end itemize
@end deftp

@anchor{fun-fl.mesh-boundary-identifications}
@deffn Function BOUNDARY-IDENTIFICATIONS @var{IDENTIFICATIONS}
@findex BOUNDARY-IDENTIFICATIONS
Returns an identification list for the boundaries of the cells in
identifications.
@end deffn

@anchor{fun-fl.mesh-box-domain}
@deffn Function BOX-DOMAIN @var{DIMENSIONS}
@findex BOX-DOMAIN
Generates a box domain for the given dimensions.  Here,
dimensions is expected to be a list of 2-element lists denoting
the interval along the respective axis.  The algorithm works by
copying the unit cube and modifying the coordinates of the
vertices of the copy.
@end deffn

@anchor{fun-fl.mesh-cartesian-product}
@deffn Function CARTESIAN-PRODUCT @var{OBJ1} @var{OBJ2} &KEY @var{PROPERTY-COMBINER} &ALLOW-OTHER-KEYS
@findex CARTESIAN-PRODUCT
Computes the cartesian product of two skeletons.
@end deffn

@anchor{fun-fl.mesh-cell->cube}
@deffn Function CELL->CUBE @var{CELL}
@findex CELL->CUBE
Transforms a product-cell into a degenerated cube with the same vertices.
@end deffn

@anchor{fun-fl.mesh-cell-identification}
@deffn Function CELL-IDENTIFICATION @var{CELL} @var{SKEL}
@findex CELL-IDENTIFICATION
Returns @arg{cell}'s identification in @arg{skel} or NIL.
@end deffn

@anchor{fun-fl.mesh-cell-mapping}
@deffn Function CELL-MAPPING @var{CELL}
@findex CELL-MAPPING
Return the mapping for mapped cells.
@end deffn

@anchor{fun-fl.mesh-cells-of-dim}
@deffn Function CELLS-OF-DIM @var{SKEL} @var{DIM}
@findex CELLS-OF-DIM
Returns the cells of @arg{skel} of dimension @arg{dim} in form of a
list.
@end deffn

@anchor{fun-fl.mesh-cells-of-highest-dim}
@deffn Function CELLS-OF-HIGHEST-DIM @var{SKEL}
@findex CELLS-OF-HIGHEST-DIM
Returns the cells of @arg{skel} of highest dimension in form of a list.
@end deffn

@anchor{fun-fl.mesh-combine-identifications}
@deffn Function COMBINE-IDENTIFICATIONS @var{SETS}
@findex COMBINE-IDENTIFICATIONS
Reduces identifications to maximally connected sets.
@end deffn

@anchor{fun-fl.mesh-compare-lexicographically}
@deffn Function COMPARE-LEXICOGRAPHICALLY &KEY (@var{FUZZY} 1.e-12) @var{DIRECTION}
@findex COMPARE-LEXICOGRAPHICALLY
Returns a function which compares two vectors lexicographically.
@end deffn

@anchor{fun-fl.mesh-copy-mesh}
@deffn Function COPY-MESH @var{MESH}
@findex COPY-MESH
Copies a mesh.  Properties copied are only patch and identification.  If
necessary, one might add further properties to be copied as a keyword
argument.
@end deffn

@anchor{fun-fl.mesh-copy-skeleton}
@deffn Function COPY-SKELETON @var{SKEL} &KEY @var{PROPERTIES} @var{TRANSFORMATION}
@findex COPY-SKELETON
Copies a skeleton.  Properties is a list of properties to be copied.
@end deffn

@anchor{fun-fl.mesh-corners}
@deffn Function CORNERS @var{CELL}
@findex CORNERS
Returns a list of corners of the cell, i.e. the global
positions of the cell's vertices.
@end deffn

@anchor{fun-fl.mesh-cube-extender}
@deffn Function CUBE-EXTENDER @var{DOMAIN-CUBE} @var{DIRECTION}
@findex CUBE-EXTENDER
Makes domain-cube ---which should be a cube in a domain--- extensible in
the given direction.
@end deffn

@anchor{fun-fl.mesh-cube-p}
@deffn Function CUBE-P @var{CELL}
@findex CUBE-P
Returns T iff CELL is a cube.
@end deffn

@anchor{fun-fl.mesh-diameter}
@deffn Function DIAMETER @var{CELL}
@findex DIAMETER
Returns the diameter of a cell.
@end deffn

@anchor{fun-fl.mesh-dimension}
@deffn Function DIMENSION @var{CELL}
@findex DIMENSION
Returns the dimension of the cell.
@end deffn

@anchor{fun-fl.mesh-dimension-of-part}
@deffn Function DIMENSION-OF-PART @var{SKEL} @var{PART}
@findex DIMENSION-OF-PART
Parts of a skeleton can be named with the property @symbol{:part}.
@end deffn

@anchor{fun-fl.mesh-domain-boundary}
@deffn Function DOMAIN-BOUNDARY @var{DOMAIN}
@findex DOMAIN-BOUNDARY
The boundary of the domain as a skeleton.
@end deffn

@anchor{fun-fl.mesh-domain-characteristics}
@deffn Function DOMAIN-CHARACTERISTICS @var{DOMAIN}
@findex DOMAIN-CHARACTERISTICS
Returns a property list of characteristics.  The property curved means
that curved patches exist.  The property exact is set to t if the domain
mappings are exact.  Otherwise, only the boundary of the domain should be
assumed to be provided in an exact form.
@end deffn

@anchor{macro-fl.mesh-doskel}
@deffn Macro DOSKEL (@var{LOOPING-VAR} @var{SKEL} &KEY (@var{DIRECTION} @var{UP}) @var{WHERE} @var{DIMENSION}) &BODY @var{BODY}
@findex DOSKEL
Loop through a skeleton.  If looping-var is an atom, it loops through
all cells, otherwise it loops through cells and properties.
@end deffn

@anchor{fun-fl.mesh-embedded-dimension}
@deffn Function EMBEDDED-DIMENSION @var{OBJECT}
@findex EMBEDDED-DIMENSION
Dimension of the embedding space for @arg{object}.  If
  @arg{check} is T, a test is performed if the dimension is well-defined
  for all parts of @arg{object}.  If not, NIL is returned.
@end deffn

@anchor{fun-fl.mesh-ensure-domain}
@deffn Function ENSURE-DOMAIN @var{DOMAIN}
@findex ENSURE-DOMAIN
If @arg{domain} is an integer, return the corresponding
@arg{n-cube-domain}, if @arg{domain} is a domain return it unchanged,
otherwise signal an error.
@end deffn

@anchor{fun-fl.mesh-ensure-simplex-product}
@deffn Function ENSURE-SIMPLEX-PRODUCT @var{FACTOR-DIMS}
@findex ENSURE-SIMPLEX-PRODUCT
Returns the reference product-cell for the given factor dimensions.
@end deffn

@anchor{fun-fl.mesh-etable}
@deffn Function ETABLE @var{SKEL} @var{DIM}
@findex ETABLE
A table for cells of dimension @arg{dim} in @arg{skel}.
@end deffn

@anchor{fun-fl.mesh-extend}
@deffn Function EXTEND @var{MESH} &KEY (@var{TEST} (@var{CONSTANTLY} @var{T}))
@findex EXTEND
Extends a mesh on all extensible cells for which test ---if provided---
yields T.
@end deffn

@anchor{fun-fl.mesh-factor-simplices}
@deffn Function FACTOR-SIMPLICES @var{CELL}
@findex FACTOR-SIMPLICES
Returns the factor-simplices.
@end deffn

@anchor{fun-fl.mesh-find-cell-from-position}
@deffn Function FIND-CELL-FROM-POSITION @var{SKEL} @var{POS}
@findex FIND-CELL-FROM-POSITION
Finds a cell from @arg{skel} which contains the global position @arg{pos}.
@end deffn

@anchor{fun-fl.mesh-find-cells}
@deffn Function FIND-CELLS @var{TEST} @var{SKEL} &KEY @var{DIMENSION} @var{WITH-PROPERTIES} @var{WHERE}
@findex FIND-CELLS
Returns a list of cells contained in skel and satisfying test.
@end deffn

@anchor{fun-fl.mesh-find-patch}
@deffn Function FIND-PATCH @var{DOMAIN} @var{CLASSIFIERS} &KEY @var{MIDPOINT}
@findex FIND-PATCH
Searches for a patch of @arg{domain} having the given list
@arg{classifiers}.
@end deffn

@anchor{fun-fl.mesh-for-each-cell-of-highest-dimension-on-surface}
@deffn Function FOR-EACH-CELL-OF-HIGHEST-DIMENSION-ON-SURFACE @var{FUNC} @var{H-MESH}
@findex FOR-EACH-CELL-OF-HIGHEST-DIMENSION-ON-SURFACE
Calls func for each cell on the hierarchical-mesh surface.
@end deffn

@anchor{fun-fl.mesh-g2l}
@deffn Function G2L @var{CELL} @var{GLOBAL-POS}
@findex G2L
Computes the local position inside the cell for the given global position.
This function is not really used at the moment, in contrast to @function{global->local}.
@end deffn

@anchor{fun-fl.mesh-get-cell-property}
@deffn Function GET-CELL-PROPERTY @var{CELL} @var{SKEL} @var{PROPERTY}
@findex GET-CELL-PROPERTY
Returns the value of the property.
@end deffn

@anchor{fun-fl.mesh-get-refinement-rule}
@deffn Function GET-REFINEMENT-RULE @var{CELL} @var{ID}
@findex GET-REFINEMENT-RULE
Finds the refinement rule for @arg{cell} defined by the @arg{id}.  This
@arg{id} can be a number (position of the rule, T (meaning 0), or some
symbol which is contained in the names of some rule.  Two values are
returned: the rule and its position in the refinement-rule vector.
@end deffn

@anchor{fun-fl.mesh-global->embedded-local}
@deffn Function GLOBAL->EMBEDDED-LOCAL @var{CELL} @var{GLOBAL-POS}
@findex GLOBAL->EMBEDDED-LOCAL
This computes a local coordinate which solves the
Ausgleichsproblem of mapping to a point as near as possible to global-pos.  It
involves more computational work than global->local.  As a second value, the
distance to global-pos is returned.
@end deffn

@anchor{fun-fl.mesh-global->local}
@deffn Function GLOBAL->LOCAL @var{CELL} @var{GLOBAL-POS}
@findex GLOBAL->LOCAL
Mainly useful for finite element evaluation: from the
local position, the value of a fe function can be obtained by
interpolation.  This is done by a Newton iteration, which converges in one
step for linear mappings.  The result is NIL, if no local point could be
determined.
@end deffn

@anchor{fun-fl.mesh-hierarchically-ordered-cells}
@deffn Function HIERARCHICALLY-ORDERED-CELLS @var{H-MESH} &KEY (@var{WHERE} @var{SURFACE}) @var{LEVEL}
@findex HIERARCHICALLY-ORDERED-CELLS
Sorts the cells up to the given level (defaulting to the last
level) hierarchically for use in something similar to the nested
disection method.  Returns a list of the sorted cells.
@end deffn

@anchor{fun-fl.mesh-identified-cells}
@deffn Function IDENTIFIED-CELLS @var{CELL} @var{SKEL}
@findex IDENTIFIED-CELLS
Returns a list of cells in @arg{skel} which are
identified with @arg{cell}.
@end deffn

@anchor{fun-fl.mesh-identified-p}
@deffn Function IDENTIFIED-P @var{CELL} @var{SKEL}
@findex IDENTIFIED-P
Returns @arg{cell}'s identification in @arg{skel} or NIL.
@end deffn

@anchor{fun-fl.mesh-identify}
@deffn Function IDENTIFY @var{IDENTIFIED-CELLS} @var{SKEL}
@findex IDENTIFY
Identifies all cells in @arg{identified-cells} within @arg{skel}.
@end deffn

@anchor{fun-fl.mesh-identify-unit-cell-faces}
@deffn Function IDENTIFY-UNIT-CELL-FACES @var{SKEL} &KEY (@var{INDICES} @var{ALL})
@findex IDENTIFY-UNIT-CELL-FACES
This routines identifies boundary cells in skel which correspond to
boundary cells in the unit cube.  Warning: exact arithmetic is used to
recognize identified cells.  This should work for skeletons derived from
the unit cell, but may create problems in other situations.
@end deffn

@anchor{fun-fl.mesh-inner-refcell-children}
@deffn Function INNER-REFCELL-CHILDREN @var{REFCELL} @var{RULE}
@findex INNER-REFCELL-CHILDREN
Returns the children of refcell.
@end deffn

@anchor{fun-fl.mesh-insert-cell!}
@deffn Function INSERT-CELL! @var{SKEL} @var{CELL} &OPTIONAL @var{PROPERTIES}
@findex INSERT-CELL!
Inserts @arg{cell} and if necessary also its boundary into @arg{skel}.
If properties are given those are used for @arg{cell}.
@end deffn

@anchor{fun-fl.mesh-insert-cell-from-corners}
@deffn Function INSERT-CELL-FROM-CORNERS @var{MESH} @var{CORNERS->CELL} @var{CELL-CLASS} @var{CORNERS} @var{PROPERTIES} &KEY (@var{CREATE-SUBCELLS} @var{T})
@findex INSERT-CELL-FROM-CORNERS
Creates a cell of type cell-class with corners given by corners.
corners->cell has to be an equalp hash-table mapping corners to the
corresponding cell.  It is updated by this function.
@end deffn

@anchor{fun-fl.mesh-insert-cells!}
@deffn Function INSERT-CELLS! @var{SKEL} @var{CELLS}
@findex INSERT-CELLS!
Inserts a list of cells into a skeleton.
@end deffn

@anchor{fun-fl.mesh-inside-cell?}
@deffn Function INSIDE-CELL? @var{CELL} @var{GLOBAL-POS} &OPTIONAL @var{THRESHOLD}
@findex INSIDE-CELL?
Checks if @arg{global-pos} is inside the interior of the
@arg{cell}.  It calls @function{global->local} to obtain local coordinates
and then @function{coordinates-inside?} to check if those are inside the
cell.  If @arg{threshold} is a non-negative number, an additional check is
performed, if the local coordinates map to @arg{global-pos} with accuracy
threshold.
@end deffn

@anchor{fun-fl.mesh-iterate-identifications}
@deffn Function ITERATE-IDENTIFICATIONS @var{INITIAL-IDENTIFICATIONS}
@findex ITERATE-IDENTIFICATIONS
Generates all identifications of the skeleton from the identifications
of some higher-dimensional cells.
@end deffn

@anchor{fun-fl.mesh-key-is-subcell-p}
@deffn Function KEY-IS-SUBCELL-P @var{KEY1} @var{KEY2}
@findex KEY-IS-SUBCELL-P
Checks if @arg{key1} occurs as subcell of @arg{key2}.  The keys can be
either cells or identifications.
@end deffn

@anchor{fun-fl.mesh-l-domain}
@deffn Function L-DOMAIN @var{DIM}
@findex L-DOMAIN
Creates an L-domain by cutting out cubes from the uniform refinement of
the unit cube.
@end deffn

@anchor{fun-fl.mesh-l2dg}
@deffn Function L2DG @var{CELL} @var{LOCAL-POS}
@findex L2DG
Computes the gradient for a multilinear
interpolation from the vertices.
@end deffn

@anchor{fun-fl.mesh-l2g}
@deffn Function L2G @var{CELL} @var{LOCAL-POS}
@findex L2G
Computes the global position by interpolation from the
vertices.
@end deffn

@anchor{fun-fl.mesh-level-of-cell}
@deffn Function LEVEL-OF-CELL @var{CELL} @var{H-MESH}
@findex LEVEL-OF-CELL
Returns the level of @arg{cell} in the hirearchical mesh @arg{h-mesh}.
@end deffn

@anchor{fun-fl.mesh-linearly-transformed-skeleton}
@deffn Function LINEARLY-TRANSFORMED-SKELETON @var{SKEL} &KEY @var{A} @var{B} @var{PROPERTIES}
@findex LINEARLY-TRANSFORMED-SKELETON
Transforms skel by transforming the vertex positions.
@end deffn

@anchor{fun-fl.mesh-local->dglobal}
@deffn Function LOCAL->DGLOBAL @var{CELL} @var{LOCAL-POS}
@findex LOCAL->DGLOBAL
local->Dglobal checks if a mapping is given for the cell.
If yes, then the gradient of this mapping is evaluated (if available).  If no,
then the function l2Dg is called which gives the gradient for a multilinear
interpolation from the cell's corners.
@end deffn

@anchor{fun-fl.mesh-local->global}
@deffn Function LOCAL->GLOBAL @var{CELL} @var{LOCAL-POS}
@findex LOCAL->GLOBAL
local->global checks if a mapping is given for the cell.
If yes, then this mapping is evaluated.  If no, then the function l2g is called
which should do a multilinear interpolation from the cell's corners.
@end deffn

@anchor{fun-fl.mesh-local-coordinates-of-midpoint}
@deffn Function LOCAL-COORDINATES-OF-MIDPOINT @var{CELL}
@findex LOCAL-COORDINATES-OF-MIDPOINT
Returns the local coordinates of the cell midpoint.
@end deffn

@anchor{fun-fl.mesh-make-cell-from-corners}
@deffn Function MAKE-CELL-FROM-CORNERS @var{CELL-CLASS} @var{CORNERS}
@findex MAKE-CELL-FROM-CORNERS
Creates a cell of class CELL-CLASS having the given CORNERS.
@end deffn

@anchor{fun-fl.mesh-make-cell-from-vertices}
@deffn Function MAKE-CELL-FROM-VERTICES @var{CELL-CLASS} @var{VERTICES}
@findex MAKE-CELL-FROM-VERTICES
Creates a cell of class CELL-CLASS having the given VERTICES.
@end deffn

@anchor{fun-fl.mesh-make-classifier}
@deffn Function MAKE-CLASSIFIER @var{TEST} @var{CLASSIFICATION}
@findex MAKE-CLASSIFIER
Returns a classifier for patches.
@end deffn

@anchor{fun-fl.mesh-make-domain}
@deffn Function MAKE-DOMAIN @var{SKEL} &REST @var{ARGS}
@findex MAKE-DOMAIN
Changes a skeleton into a domain.
@end deffn

@anchor{fun-fl.mesh-make-hierarchical-mesh-from}
@deffn Function MAKE-HIERARCHICAL-MESH-FROM &REST @var{ARGS}
@findex MAKE-HIERARCHICAL-MESH-FROM
Creates a hierarchical-mesh from the given arguments.  See @function{MAKE-MESH-FROM}.
@end deffn

@anchor{fun-fl.mesh-make-hierarchical-mesh-from-domain}
@deffn Function MAKE-HIERARCHICAL-MESH-FROM-DOMAIN @var{DOMAIN} &KEY @var{PARAMETRIC} &ALLOW-OTHER-KEYS
@findex MAKE-HIERARCHICAL-MESH-FROM-DOMAIN
Construct a hierarchical-mesh from a domain.
@end deffn

@anchor{fun-fl.mesh-make-line}
@deffn Function MAKE-LINE @var{FROM-VTX} @var{TO-VTX} &KEY (@var{CHECK} @var{T}) @var{MAPPING}
@findex MAKE-LINE
Creates a line given its endpoints.
@end deffn

@anchor{fun-fl.mesh-make-mesh-from}
@deffn Function MAKE-MESH-FROM @var{OBJECT} &KEY @var{PARAMETRIC} &ALLOW-OTHER-KEYS
@findex MAKE-MESH-FROM
Makes a mesh from or for the given object.
@end deffn

@anchor{fun-fl.mesh-make-simplex}
@deffn Function MAKE-SIMPLEX @var{BOUNDARY} &KEY (@var{CHECK} @var{T}) @var{MAPPING}
@findex MAKE-SIMPLEX
Short form of creating a simplex given its boundary.  An alternative is
creating it from its vertices, see the functions MAKE-CELL-FROM-VERTICES
and INSERT-CELL-FROM-CORNERS.
@end deffn

@anchor{fun-fl.mesh-make-vertex}
@deffn Function MAKE-VERTEX @var{POSITION} &OPTIONAL @var{MAPPING}
@findex MAKE-VERTEX
General vertex constructor.
@end deffn

@anchor{fun-fl.mesh-mapped-cell-class}
@deffn Function MAPPED-CELL-CLASS @var{CLASS} &OPTIONAL @var{DISTORTED}
@findex MAPPED-CELL-CLASS
Constructs a cell class with <mapped-cell> mixin.
@end deffn

@anchor{fun-fl.mesh-mark-skeleton}
@deffn Function MARK-SKELETON @var{SKEL} @var{PROP} @var{VALUE}
@findex MARK-SKELETON
Marks all cells of @arg{skel} with the given @arg{prop}/@arg{value}
pair.
@end deffn

@anchor{fun-fl.mesh-member-of-skeleton?}
@deffn Function MEMBER-OF-SKELETON? @var{CELL} @var{SKEL}
@findex MEMBER-OF-SKELETON?
Returns T if @arg{cell} is in @arg{skel}, NIL otherwise.
@end deffn

@anchor{fun-fl.mesh-meshsize}
@deffn Function MESHSIZE @var{MESH}
@findex MESHSIZE
Computes a meshsize.  Please refer to the method
documentations for the exact definition.
@end deffn

@anchor{fun-fl.mesh-midpoint}
@deffn Function MIDPOINT @var{CELL}
@findex MIDPOINT
Returns cell midpoint in global coordinates.
@end deffn

@anchor{fun-fl.mesh-multiple-local->dglobal}
@deffn Function MULTIPLE-LOCAL->DGLOBAL @var{CELL} @var{LOCAL-POS}
@findex MULTIPLE-LOCAL->DGLOBAL
Applies LOCAL->DGLOBAL for several positions at once.
@end deffn

@anchor{fun-fl.mesh-multiple-local->global}
@deffn Function MULTIPLE-LOCAL->GLOBAL @var{CELL} @var{LOCAL-POS}
@findex MULTIPLE-LOCAL->GLOBAL
Applies LOCAL->GLOBAL for several positions at once.
@end deffn

@anchor{fun-fl.mesh-n-ball-domain}
@deffn Function N-BALL-DOMAIN @var{DIM}
@findex N-BALL-DOMAIN
Generates an n-dimensional ball domain with 2^n simplex patches.
@end deffn

@anchor{fun-fl.mesh-n-cell-domain}
@deffn Function N-CELL-DOMAIN @var{DIM}
@findex N-CELL-DOMAIN
Generates an n-dimensional cell domain which is a n-dimensional unit
cube with its opposite sides identified.
@end deffn

@anchor{fun-fl.mesh-n-cube}
@deffn Function N-CUBE @var{DIM}
@findex N-CUBE
Returns the reference cube of dimension dim.
@end deffn

@anchor{fun-fl.mesh-n-simplex}
@deffn Function N-SIMPLEX @var{DIM}
@findex N-SIMPLEX
Returns the reference simplex of the given dimension.
@end deffn

@anchor{fun-fl.mesh-nr-of-cells}
@deffn Function NR-OF-CELLS @var{SKEL} &OPTIONAL @var{DIMENSION}
@findex NR-OF-CELLS
Returns number of cells in a skeleton.
@end deffn

@anchor{fun-fl.mesh-nr-of-sides}
@deffn Function NR-OF-SIDES @var{CELL}
@findex NR-OF-SIDES
Returns the number of boundary faces.
@end deffn

@anchor{fun-fl.mesh-nr-of-subcells}
@deffn Function NR-OF-SUBCELLS @var{CELL}
@findex NR-OF-SUBCELLS
Returns the number of subcells.
@end deffn

@anchor{fun-fl.mesh-nr-of-vertices}
@deffn Function NR-OF-VERTICES @var{CELL}
@findex NR-OF-VERTICES
Returns the number of vertices.
@end deffn

@anchor{fun-fl.mesh-origin}
@deffn Function ORIGIN @var{CELL}
@findex ORIGIN
Returns cell origin in global coordinates.
@end deffn

@anchor{fun-fl.mesh-patch-classification}
@deffn Function PATCH-CLASSIFICATION @var{PATCH} @var{DOMAIN}
@findex PATCH-CLASSIFICATION
Returns a list of classifications for @arg{patch} in @arg{domain}.
@end deffn

@anchor{fun-fl.mesh-refcell-children}
@deffn Function REFCELL-CHILDREN @var{REFCELL} @var{RULE}
@findex REFCELL-CHILDREN
Returns the children for refcell and subcells.
@end deffn

@anchor{fun-fl.mesh-refcell-refinement-skeleton}
@deffn Function REFCELL-REFINEMENT-SKELETON @var{REFCELL} &OPTIONAL (@var{LEVEL} 1) (@var{RULE} 0) @var{REINIT}
@findex REFCELL-REFINEMENT-SKELETON
Returns an LEVEL times refined skeleton of REFCELL.  It is partially
memoized, see the documentation of *REFCELL-REFINEMENT-MEMOIZE-DEPTH*.
@end deffn

@anchor{fun-fl.mesh-reference-cell}
@deffn Function REFERENCE-CELL @var{CELL-OR-CLASS}
@findex REFERENCE-CELL
Returns the cell's or cell-classes reference-cell.
@end deffn

@anchor{fun-fl.mesh-reference-cell-p}
@deffn Function REFERENCE-CELL-P @var{CELL}
@findex REFERENCE-CELL-P
Tests if a cell is a reference cell.
@end deffn

@anchor{fun-fl.mesh-refine}
@deffn Function REFINE @var{SKEL} &KEY @var{INDICATOR} (@var{INDICATOR} (@var{CONSTANTLY} @var{T})) @var{HIGHEST} (@var{DECOUPLE} @var{T}) &ALLOW-OTHER-KEYS
@findex REFINE
Refines @arg{skel} either locally or globally depending
on the @function{indicator}.
@end deffn

@anchor{fun-fl.mesh-refine-info}
@deffn Function REFINE-INFO @var{CELL}
@findex REFINE-INFO
Returns refinement information for the cell.
@end deffn

@anchor{fun-fl.mesh-refinement}
@deffn Function REFINEMENT @var{CELL} @var{SKELETON}
@findex REFINEMENT
Returns the refinement of @arg{cell} in @arg{skeleton} as two values:
the rule and the children.
@end deffn

@anchor{fun-fl.mesh-refinement-interface}
@deffn Function REFINEMENT-INTERFACE @var{H-MESH} &KEY @var{LEVEL}
@findex REFINEMENT-INTERFACE
Returns the refined boundary subcells of unrefined cells in a skeleton.
Those cells are found as all refined cells which are not part of the domain
boundary.  At the moment, this is a global operation.  Later on, it should
probably be localized.
@end deffn

@anchor{fun-fl.mesh-refinement-rule}
@deffn Function REFINEMENT-RULE @var{CELL} @var{SKEL}
@findex REFINEMENT-RULE
Returns the refinement rule of @arg{cell} in @arg{skel}.
@end deffn

@anchor{class-fl.mesh-refinement-rule}
@deftp Class REFINEMENT-RULE
@tindex REFINEMENT-RULE
Rule for refining reference cells.  Those rules are
stored in the refine-info slot of the cell class.

Direct slots:
@itemize
@item NAMES: Names identifying the rule.
@item REFCELL: Reference cell for this refinement rule.
@item BOUNDARY-REFINEMENT-RULES: Refinement rules for the sides required by this rule.
@item REFINEMENT-INFO: Vector of refinement information for the children.
@end itemize
@end deftp

@anchor{fun-fl.mesh-representative}
@deffn Function REPRESENTATIVE @var{OBJ}
@findex REPRESENTATIVE
Returns a representative for this object.
@end deffn

@anchor{fun-fl.mesh-shift-skeleton}
@deffn Function SHIFT-SKELETON @var{SKEL} @var{SHIFT} &KEY @var{PROPERTIES}
@findex SHIFT-SKELETON
Shifts skel by vec.  vec has to be a vector of dimension
(embedded-dimension skel).
@end deffn

@anchor{fun-fl.mesh-simplex-class}
@deffn Function SIMPLEX-CLASS @var{DIM} &OPTIONAL @var{MAPPED} @var{DISTORTED}
@findex SIMPLEX-CLASS
Returns the n-simplex class.
@end deffn

@anchor{fun-fl.mesh-simplex-product-domain}
@deffn Function SIMPLEX-PRODUCT-DOMAIN @var{DIMS}
@findex SIMPLEX-PRODUCT-DOMAIN
Generates a product-cell domain for the given factor dimensions.
@end deffn

@anchor{fun-fl.mesh-skel-add!}
@deffn Function SKEL-ADD! @var{SKEL-1} @var{SKEL-2} &KEY (@var{OVERRIDE} @var{NIL}) @var{THRESHOLD} @var{ACTIVE-SKEL-1}
@findex SKEL-ADD!
Adds @arg{skel-2} to @arg{skel-1} destructively for @arg{skel-1}.
Overlaying cells are identified.  @arg{override} is a list of properties
which are copied from skel-2 on the overlap.  @arg{active-skel-1} is used
for hierarchical-meshes for selecting a level to which @arg{skel-2} is
added.  This function returns three values: the first is @arg{skel-1}, the
second is @arg{skel-2}, the third is a hash-table mapping overlapping cells
from @arg{skel-2} to their counterpart in @arg{skel-1}.
@end deffn

@anchor{fun-fl.mesh-skel-for-each}
@deffn Function SKEL-FOR-EACH @var{FUNC} @var{SKEL} &KEY @var{DIRECTION} @var{DIMENSION} @var{WHERE} @var{WITH-PROPERTIES}
@findex SKEL-FOR-EACH
Loops through a skeleton applying func.  When direction is :down then loops
with dimension of the cells decreasing, otherwise increasing.
@end deffn

@anchor{fun-fl.mesh-skel-map}
@deffn Function SKEL-MAP @var{FUNC} @var{SKEL}
@findex SKEL-MAP
Maps a skeleton with func to another skeleton having the same keys
and mapped values.  May be configured later on.
@end deffn

@anchor{fun-fl.mesh-skel-ref}
@deffn Function SKEL-REF @var{SKEL} @var{CELL}
@findex SKEL-REF
Returns the properties of @arg{cell} in @arg{skel}.
@end deffn

@anchor{fun-fl.mesh-skeleton}
@deffn Function SKELETON @var{CELL-OR-CELLS}
@findex SKELETON
Returns a skeleton for the given cell or the given
cells.
@end deffn

@anchor{fun-fl.mesh-skeleton-boundary}
@deffn Function SKELETON-BOUNDARY @var{SKEL}
@findex SKELETON-BOUNDARY
Returns a skeleton consisting of cells of skel of dimension n-1 which
have only one neighbor.
@end deffn

@anchor{fun-fl.mesh-skeleton-disjoint-union}
@deffn Function SKELETON-DISJOINT-UNION &REST @var{SKELS}
@findex SKELETON-DISJOINT-UNION
Builds a disjoint union skeleton of all skeletons.
@end deffn

@anchor{fun-fl.mesh-skeleton-without-cell}
@deffn Function SKELETON-WITHOUT-CELL @var{SKEL} @var{CELL-TO-REMOVE}
@findex SKELETON-WITHOUT-CELL
Removes a cell from a skeleton such that the rest remains a skeleton.
Warning: does not handle identifications yet.
@end deffn

@anchor{fun-fl.mesh-sort-lexicographically}
@deffn Function SORT-LEXICOGRAPHICALLY @var{ELIST} &KEY (@var{FUZZY} 1.e-12)
@findex SORT-LEXICOGRAPHICALLY
Sorts a cell list lexicographically by the coordinates of their
midpoint.
@end deffn

@anchor{fun-fl.mesh-special-mesh-on-box-domain}
@deffn Function SPECIAL-MESH-ON-BOX-DOMAIN @var{DOMAIN} @var{PATCH->MESH-SIZES}
@findex SPECIAL-MESH-ON-BOX-DOMAIN
Creates a uniform mesh consisting of N_1 x ... x N_dim cells on a box
domain.
@end deffn

@anchor{fun-fl.mesh-standard-extender}
@deffn Function STANDARD-EXTENDER @var{ORIGINAL-CELL} @var{REPLACEMENT}
@findex STANDARD-EXTENDER
Extension function replacing an original-cell with a replacement.
@end deffn

@anchor{fun-fl.mesh-structured-skeleton}
@deffn Function STRUCTURED-SKELETON @var{N} @var{H} &KEY @var{CORNERS->CELL}
@findex STRUCTURED-SKELETON
Create a uniform box skeleton consisting of N_1 x ... x N_dim cubes of
dimensions h_1 x ... x h_dim.
@end deffn

@anchor{fun-fl.mesh-subcell-children}
@deffn Function SUBCELL-CHILDREN @var{CELL} @var{SKELETON}
@findex SUBCELL-CHILDREN
Returns a vector of all children of the subcells of @arg{cell} in
@arg{skeleton}.
@end deffn

@anchor{fun-fl.mesh-subcells}
@deffn Function SUBCELLS @var{CELL}
@findex SUBCELLS
Returns a vector containing all subcells of a given cell.  The code is
special to each class and often automatically generated by
@function{generate-subcell-access-code}.
@end deffn

@anchor{fun-fl.mesh-subskeleton}
@deffn Function SUBSKELETON @var{SKEL} @var{TEST}
@findex SUBSKELETON
Returns a minimal skeleton containing the cells satisfying the test.
@end deffn

@anchor{fun-fl.mesh-surface-cells-of-dim}
@deffn Function SURFACE-CELLS-OF-DIM @var{H-MESH} @var{DIM}
@findex SURFACE-CELLS-OF-DIM
This function returns the surface cells of a locally refined
hierarchical-mesh structure.
@end deffn

@anchor{fun-fl.mesh-surface-cells-of-highest-dim}
@deffn Function SURFACE-CELLS-OF-HIGHEST-DIM @var{H-MESH}
@findex SURFACE-CELLS-OF-HIGHEST-DIM
This function returns the surface cells of highest dimension of a
locally refined hierarchical-mesh structure.
@end deffn

@anchor{fun-fl.mesh-test-condition}
@deffn Function TEST-CONDITION @var{CONDITION} @var{CLASSIFICATIONS}
@findex TEST-CONDITION
Test if @arg{condition} holds for @arg{classifications}.
@arg{condition} should be a logical combination of the keyword symbols in
the list @arg{classification}.
@end deffn

@anchor{fun-fl.mesh-top-level}
@deffn Function TOP-LEVEL @var{MH}
@findex TOP-LEVEL
Top-level of a mesh hierarchy.
@end deffn

@anchor{fun-fl.mesh-transformed-skeleton}
@deffn Function TRANSFORMED-SKELETON @var{SKEL} &KEY @var{TRANSFORMATION} @var{PROPERTIES}
@findex TRANSFORMED-SKELETON
Transforms skel by transforming the cell mappings resp. vertex
positions.
@end deffn

@anchor{fun-fl.mesh-triangulate}
@deffn Function TRIANGULATE @var{DOMAIN} &REST @var{ARGS} &KEY @var{PARAMETRIC} (@var{CHECK-P} @var{T}) &ALLOW-OTHER-KEYS
@findex TRIANGULATE
Triangulate @arg{domain} by successively building a mesh on the domain
skeleton starting from the 0-dimensional patches.
@end deffn

@anchor{fun-fl.mesh-triangulize}
@deffn Function TRIANGULIZE @var{MESH}
@findex TRIANGULIZE
Transforms a product-cell mesh into a simplex mesh.
@end deffn

@anchor{fun-fl.mesh-uniform-mesh-on-box-domain}
@deffn Function UNIFORM-MESH-ON-BOX-DOMAIN @var{DOMAIN} @var{N}
@findex UNIFORM-MESH-ON-BOX-DOMAIN
Creates a uniform mesh consisting of N_1 x ... x N_dim cells on a box
domain.
@end deffn

@anchor{fun-fl.mesh-uniformly-refined-mesh}
@deffn Function UNIFORMLY-REFINED-MESH @var{DOMAIN} @var{N} &KEY @var{PARAMETRIC}
@findex UNIFORMLY-REFINED-MESH
Generates a mesh by refining the domain partition uniformly.
@end deffn

@anchor{fun-fl.mesh-vertices}
@deffn Function VERTICES @var{CELL}
@findex VERTICES
Returns a list of all vertices of the cell.
@end deffn

@node Package FL.PROBLEM, Package FL.CDR, Package FL.MESH, Reference manual
@section Package FL.PROBLEM

 The @package{FL.PROBLEM} package introduces the
general class @class{<problem>} and some subclasses.  The most interesting
subclass is @class{<pde-problem>}.  A @class{<pde-problem>} is defined on a
domain and provides a table mapping the domain patches to property lists
containing the coefficient functions.

Several subclasses of @class{<pde-problem>} are defined in own packages,
e.g. @class{<cdr-problem>} in @package{FL.CDR},
@class{<elasticity-problem>} in @package{FL.ELASTICITY} and
@class{<navier-stokes-problem} in @package{FL.NAVIER-STOKES}.

@anchor{class-fl.problem-<coefficient>}
@deftp Class <COEFFICIENT>
@tindex <COEFFICIENT>
The coefficient class.

Superclasses: PROPERTY-MIXIN

Direct slots:
@itemize
@item NAME: Self-explanatory.
@item DIMENSION: The dimension of the cell on which this coefficient is
active.  The value T means that it is active on all cells lying on the
patch.  The default value NIL means that it is active on cells with the
same dimension as the patch.
@item DEMANDS: A list indicating which information the evaluation
function needs.  Possible choices depend on problem and discretization,
e.g. @code{:local}, @code{:global}, @code{:fe}, @code{:cell} are possible
choices.  One element can also be a list starting with the keyword
@code{:fe-parameters} and followed by symbols indicating names of finite
element functions on the discretization blackboard.
@item EVAL: The evaluation funtion.  It accepts a list of
keyword parameters which should correspond to the list in DEMANDS.
@item RESIDUAL: T means evaluation for computing the residual.
@item JACOBIAN: T means evaluation for computing the Jacobian.
@end itemize
@end deftp

@anchor{class-fl.problem-<domain-problem>}
@deftp Class <DOMAIN-PROBLEM>
@tindex <DOMAIN-PROBLEM>
An instance of this class describes a problem posed on
@slot{domain} with coefficients given on each patch of the domain.  The
slot @slot{multiplicity} is a positive integer which denotes the number of
right-hand sides and solutions (e.g. when computing several eigenvectors at
once).

Superclasses: <PROBLEM>

Direct slots:
@itemize
@item DOMAIN: Self-explanatory.
@item COMPONENTS: A list whose elements are lists of the form
(symbol dim) or (symbol dim type) or (symbol subcomponents) describing
the components occuring in the pde.  Alternatively, this slot can contain a
function/dictionary mapping patches to such lists.
@item MULTIPLICITY: Multiplicity of the right-hand side.
@item COEFFICIENTS: A function mapping patches to coefficient lists.
@end itemize
@end deftp

@anchor{class-fl.problem-<evp-mixin>}
@deftp Class <EVP-MIXIN>
@tindex <EVP-MIXIN>
A mixin for eigenvalue problems.

Direct slots:
@itemize
@item MULTIPLICITY: The multiplicity of the eigenspace.
@item EIGENVALUES: The current approximation of the eigenvalues.
@item MU: The multiplier for the system matrix.
@end itemize
@end deftp

@anchor{class-fl.problem-<evp>}
@deftp Class <EVP>
@tindex <EVP>
Standard class for discrete eigenvalue problems.

Superclasses: <EVP-MIXIN> <NONLINEAR-PROBLEM>
@end deftp

@anchor{class-fl.problem-<interpolation-problem>}
@deftp Class <INTERPOLATION-PROBLEM>
@tindex <INTERPOLATION-PROBLEM>
Interpolation problem on a domain.  The function which
is to be interpolated is given as a coefficient with key FUNCTION in the
coefficient list.

Superclasses: <DOMAIN-PROBLEM>
@end deftp

@anchor{class-fl.problem-<ls-evp>}
@deftp Class <LS-EVP>
@tindex <LS-EVP>
Generalized eigenvalue problem for matrices.

Superclasses: <EVP>

Direct slots:
@itemize
@item STIFFNESS-MATRIX: Self-explanatory.
@item MASS-MATRIX: Self-explanatory.
@end itemize
@end deftp

@anchor{class-fl.problem-<lse>}
@deftp Class <LSE>
@tindex <LSE>
Standard form of a linear system of equations.

Superclasses: <PROBLEM>

Direct slots:
@itemize
@item MATRIX: Self-explanatory.
@item RHS: Self-explanatory.
@end itemize
@end deftp

@anchor{class-fl.problem-<nlse>}
@deftp Class <NLSE>
@tindex <NLSE>
Class for nonlinear system of equations.

Superclasses: <NONLINEAR-PROBLEM>
@end deftp

@anchor{class-fl.problem-<nonlinear-problem>}
@deftp Class <NONLINEAR-PROBLEM>
@tindex <NONLINEAR-PROBLEM>
Class for nonlinear problems.  The linearization
contains a function returning a linear problem.

Superclasses: <PROBLEM>

Direct slots:
@itemize
@item LINEARIZATION: A function linearizing the problem.
@item SOLUTION: An approximation to the solution.
@end itemize
@end deftp

@anchor{class-fl.problem-<pde-problem>}
@deftp Class <PDE-PROBLEM>
@tindex <PDE-PROBLEM>
Base-class for a pde-problem.

Superclasses: <DOMAIN-PROBLEM>
@end deftp

@anchor{class-fl.problem-<problem>}
@deftp Class <PROBLEM>
@tindex <PROBLEM>
Base class for all problems.

Superclasses: PROPERTY-MIXIN
@end deftp

@anchor{class-fl.problem-<time-dependent-problem>}
@deftp Class <TIME-DEPENDENT-PROBLEM>
@tindex <TIME-DEPENDENT-PROBLEM>
A mixin which should be used together with a
<PDE-PROBLEM> in a call to MAKE-PROGRAMMATIC-INSTANCE.
@end deftp

@anchor{fun-fl.problem-add-fe-parameters-demand}
@deffn Function ADD-FE-PARAMETERS-DEMAND @var{DEMANDS} @var{NEW-PARAS}
@findex ADD-FE-PARAMETERS-DEMAND
Adds a list of fe-functions to the demands.
@end deffn

@anchor{macro-fl.problem-coeff}
@deffn Macro COEFF @var{NAME} @var{ARGS} &BODY @var{BODY}
@findex COEFF
A local @mac{coeff} defines a coefficient function inside
@mac{setup-coefficients}.  It is defined here at the toplevel such that the
Lisp editor indents the definitions correctly.
@end deffn

@anchor{fun-fl.problem-coefficients-of-cell}
@deffn Function COEFFICIENTS-OF-CELL @var{CELL} @var{MESH} @var{PROBLEM}
@findex COEFFICIENTS-OF-CELL
Returns the coefficients of @arg{problem} on @arg{cell}.
@end deffn

@anchor{fun-fl.problem-coefficients-of-patch}
@deffn Function COEFFICIENTS-OF-PATCH @var{PATCH} @var{PROBLEM}
@findex COEFFICIENTS-OF-PATCH
Reader for the coefficients of @arg{patch} for @arg{problem}.
@end deffn

@anchor{fun-fl.problem-component-position}
@deffn Function COMPONENT-POSITION @var{COMPONENTS} @var{COMP}
@findex COMPONENT-POSITION
Translates a symbol denoting a component to a position.
@end deffn

@anchor{fun-fl.problem-components-of-cell}
@deffn Function COMPONENTS-OF-CELL @var{CELL} @var{MESH} @var{PROBLEM}
@findex COMPONENTS-OF-CELL
Returns the components of @arg{problem} on @arg{cell}.
@end deffn

@anchor{fun-fl.problem-components-of-patch}
@deffn Function COMPONENTS-OF-PATCH @var{PATCH} @var{PROBLEM}
@findex COMPONENTS-OF-PATCH
Reader for the components of @arg{problem} on @arg{patch}.
@end deffn

@anchor{fun-fl.problem-constant-coefficient}
@deffn Function CONSTANT-COEFFICIENT @var{NAME} @var{VALUE} &REST @var{OTHER-VALUES}
@findex CONSTANT-COEFFICIENT
Returns a coefficient which takes the given value.  Several values can
be passed which is needed, for example, for returning also the type of a
boundary condition.
@end deffn

@anchor{fun-fl.problem-constraint-coefficient}
@deffn Function CONSTRAINT-COEFFICIENT @var{COMPONENTS} @var{MULTIPLICITY}
@findex CONSTRAINT-COEFFICIENT
Returns a coefficient function which sets Dirichlet zero boundary
conditions for all components of a PDE system.
@end deffn

@anchor{macro-fl.problem-create-problem}
@deffn Macro CREATE-PROBLEM @var{TYPE} (&KEY @var{DOMAIN} @var{COMPONENTS} (@var{MULTIPLICITY} 1) @var{PROPERTIES}) &BODY @var{BODY}
@findex CREATE-PROBLEM
Creates a PDE problem.  @arg{type} is the type of the problem which
can be the name of a problem class or a list of class names.  @arg{domain}
is the domain for this problem, @arg{multiplicity} is the multiplicity of
the solution, e.g. the number of eigenvectors we search for.  In
@arg{body}, patch-dependent coefficients should be defined with
@mac{setup-coefficients}.  It is also possible to define patch-dependent
components with @mac{setup-components}.
@end deffn

@anchor{fun-fl.problem-dual-problem}
@deffn Function DUAL-PROBLEM @var{PROBLEM} @var{FUNCTIONAL}
@findex DUAL-PROBLEM
Returns the dual problem for @arg{problem} with the
right-hand side given by @arg{functional}.  The solution of this problem
measures the sensitivity of @arg{functional} applied to the solution of
problem with respect to errors in the solution.
@end deffn

@anchor{fun-fl.problem-energy}
@deffn Function ENERGY @var{EVP} @var{X}
@findex ENERGY
Evaluates the energy bilinear form for a generalized eigenvalue problem.
@end deffn

@anchor{fun-fl.problem-ensure-coefficient}
@deffn Function ENSURE-COEFFICIENT @var{NAME} @var{OBJ}
@findex ENSURE-COEFFICIENT
Returns @arg{obj} if it is a coefficient, converts @arg{obj} into a
coefficient depending on the space variable if @arg{obj} is a function;
otherwise, @arg{obj} is made into a constant coefficient.
@end deffn

@anchor{fun-fl.problem-ensure-residual}
@deffn Function ENSURE-RESIDUAL @var{PROBLEM} @var{BLACKBOARD}
@findex ENSURE-RESIDUAL
Ensures that the field :RESIDUAL is computed and that
the flag :RESIDUAL-P is set on the blackboard.
@end deffn

@anchor{fun-fl.problem-ensure-solution}
@deffn Function ENSURE-SOLUTION @var{PROBLEM} @var{BLACKBOARD}
@findex ENSURE-SOLUTION
Ensures that the field :SOLUTION is set on the
blackboard.
@end deffn

@anchor{fun-fl.problem-extract-from}
@deffn Function EXTRACT-FROM @var{SOLUTION} @var{FROM} @var{NCOMPS} &OPTIONAL @var{SCALAR-P} @var{INDEX}
@findex EXTRACT-FROM
Extracts numbers or subvectors from the solution vector.
@end deffn

@anchor{fun-fl.problem-extraction-information}
@deffn Function EXTRACTION-INFORMATION @var{COMPONENTS} @var{COMPONENT}
@findex EXTRACTION-INFORMATION
If @arg{component} is in @arg{components}, a triple consisting of
position, length, and a flag is returned.  The flag is true, if the
component is a scalar.
@end deffn

@anchor{fun-fl.problem-filter-applicable-coefficients}
@deffn Function FILTER-APPLICABLE-COEFFICIENTS @var{COEFFS} @var{CELL} @var{PATCH} &KEY (@var{CONSTRAINTS} @var{T})
@findex FILTER-APPLICABLE-COEFFICIENTS
Filters out the applicable coefficients for the respective cell with the
given patch.
@end deffn

@anchor{fun-fl.problem-fu->coefficient}
@deffn Function FU->COEFFICIENT @var{NAME} @var{FUNC}
@findex FU->COEFFICIENT
The function argument @arg{func} is transformed into a coefficient
depending on the solution.
@end deffn

@anchor{fun-fl.problem-fx->coefficient}
@deffn Function FX->COEFFICIENT @var{NAME} @var{FUNC}
@findex FX->COEFFICIENT
The function argument @arg{func} is transformed into a coefficient
depending on global coordinates.
@end deffn

@anchor{fun-fl.problem-fxu->coefficient}
@deffn Function FXU->COEFFICIENT @var{NAME} @var{FUNC}
@findex FXU->COEFFICIENT
The function argument @arg{func} is transformed into a coefficient
depending on position and solution.
@end deffn

@anchor{fun-fl.problem-get-coefficient}
@deffn Function GET-COEFFICIENT @var{COEFFS} @var{NAME}
@findex GET-COEFFICIENT
Get coefficient @arg{name} from the list @arg{coeffs}.
@end deffn

@anchor{fun-fl.problem-get-property}
@deffn Function GET-PROPERTY @var{OBJECT} @var{PROPERTY}
@findex GET-PROPERTY
Gets @arg{property} for @arg{object}.  Returns NIL also if
@arg{property} is not available.
@end deffn

@anchor{fun-fl.problem-identification-coefficient}
@deffn Function IDENTIFICATION-COEFFICIENT @var{MASTER} @var{MAPPING}
@findex IDENTIFICATION-COEFFICIENT
A special coefficient used for identifying parts of the domain.  The
  coefficient evaluation returns the master coordinates.
@end deffn

@anchor{fun-fl.problem-linear-p}
@deffn Function LINEAR-P @var{PROBLEM}
@findex LINEAR-P
Predicate determining if a problem is linear or nonlinear.
@end deffn

@anchor{fun-fl.problem-linearize}
@deffn Function LINEARIZE @var{PROBLEM} @var{SOLUTION}
@findex LINEARIZE
Linearize the nonlinear problem PROBLEM at the point
SOLUTION.  The result should be a linear problem.
@end deffn

@anchor{fun-fl.problem-lse}
@deffn Function LSE &REST @var{ARGS}
@findex LSE
Constructs a standard LSE.
@end deffn

@anchor{fun-fl.problem-make-coefficients-for}
@deffn Function MAKE-COEFFICIENTS-FOR @var{PROBLEM} @var{NAME} @var{PATCH} @var{DEMANDS} @var{EVALUATOR}
@findex MAKE-COEFFICIENTS-FOR
Generates a coefficient while dispatching on problem and
coefficient name.  May return a single coefficient or a list of several
coefficients.
@end deffn

@anchor{fun-fl.problem-mass}
@deffn Function MASS @var{EVP} @var{X}
@findex MASS
Evaluates the mass bilinear form for a generalized eigenvalue problem.
@end deffn

@anchor{fun-fl.problem-multiplicity}
@deffn Function MULTIPLICITY @var{VEC}
@findex MULTIPLICITY
We allow multiple vectors, for solving linear problems
in parallel.
@end deffn

@anchor{fun-fl.problem-nlse}
@deffn Function NLSE &REST @var{ARGS}
@findex NLSE
Constructs a standard NLSE.
@end deffn

@anchor{fun-fl.problem-nr-of-components}
@deffn Function NR-OF-COMPONENTS @var{PROBLEM}
@findex NR-OF-COMPONENTS
Returns the number of components for @arg{problem}.
@end deffn

@anchor{fun-fl.problem-prepare-coefficient-arguments}
@deffn Function PREPARE-COEFFICIENT-ARGUMENTS @var{COMPONENTS} @var{ARGS}
@findex PREPARE-COEFFICIENT-ARGUMENTS
Prepares arguments for the given coefficient function.
@end deffn

@anchor{fun-fl.problem-required-fe-functions}
@deffn Function REQUIRED-FE-FUNCTIONS @var{COEFFS}
@findex REQUIRED-FE-FUNCTIONS
Returns a list of finite element functions required by the coefficients
in the property list @arg{coeffs}.
@end deffn

@anchor{fun-fl.problem-select-linear-solver}
@deffn Function SELECT-LINEAR-SOLVER @var{OBJECT} @var{BLACKBOARD}
@findex SELECT-LINEAR-SOLVER
Selects a linear solver for OBJECT.  OBJECT is usually a
matrix or a linear problem with certain characteristics.
@end deffn

@anchor{fun-fl.problem-select-solver}
@deffn Function SELECT-SOLVER @var{OBJECT} @var{BLACKBOARD}
@findex SELECT-SOLVER
Selects a solver for OBJECT.  OBJECT is usually a
problem with certain characteristics.
@end deffn

@anchor{fun-fl.problem-self-adjoint-p}
@deffn Function SELF-ADJOINT-P @var{PROBLEM}
@findex SELF-ADJOINT-P
Returns two values.  The first says if @arg{problem} is
self-adjoint, the second says if that value has really been checked.
@end deffn

@anchor{macro-fl.problem-setup-coefficients}
@deffn Macro SETUP-COEFFICIENTS (@var{PATCH}) &BODY @var{PATCH-DEFINITIONS}
@findex SETUP-COEFFICIENTS
Defines coefficients dispatching on @arg{patch}.
@end deffn

@anchor{macro-fl.problem-setup-components}
@deffn Macro SETUP-COMPONENTS (@var{PATCH}) &BODY @var{PATCH-DEFINITIONS}
@findex SETUP-COMPONENTS
Defines components dispatching on @arg{patch}.
@end deffn

@anchor{fun-fl.problem-stationary-problem-class}
@deffn Function STATIONARY-PROBLEM-CLASS @var{TDP}
@findex STATIONARY-PROBLEM-CLASS
Finds the stationary pde problem for the time-dependent problem TDP.
@end deffn

@anchor{fun-fl.problem-zero-constraints}
@deffn Function ZERO-CONSTRAINTS @var{PROBLEM}
@findex ZERO-CONSTRAINTS
Returns a coefficient function which constrains all
system components to zero.
@end deffn

@node Package FL.CDR, Package FL.ELLSYS, Package FL.PROBLEM, Reference manual
@section Package FL.CDR

Defines convection-diffusion-reaction problems

@anchor{class-fl.cdr-<cdr-problem>}
@deftp Class <CDR-PROBLEM>
@tindex <CDR-PROBLEM>
Convection-diffusion-reaction problem.

Superclasses: <ELLSYS-PROBLEM>

Direct slots:
@itemize
@item COMPONENTS: Self-explanatory.
@end itemize
@end deftp

@anchor{fun-fl.cdr-bratu-problem}
@deffn Function BRATU-PROBLEM @var{DIM}
@findex BRATU-PROBLEM
Returns a linearization for the Bratu problem @math{-Delta u +e^u =0}.
@end deffn

@anchor{fun-fl.cdr-cdr-model-problem}
@deffn Function CDR-MODEL-PROBLEM @var{DOMAIN} &KEY (@var{DIFFUSION} @var{NIL} @var{DIFFUSION-P}) (@var{SOURCE} @var{NIL} @var{SOURCE-P}) (@var{DIRICHLET} @var{NIL} @var{DIRICHLET-P}) @var{GAMMA} @var{CONVECTION} @var{REACTION} @var{SIGMA} @var{INITIAL} @var{EVP} (@var{MULTIPLICITY} 1) @var{PROPERTIES}
@findex CDR-MODEL-PROBLEM
Generates a convection-diffusion-reaction model problem.  Defaults are
identity diffusion, right-hand-side equal 1, and Dirichlet zero boundary
conditions.  Ordinary function are converted into coefficient functions
depending on a global coordinate.  The first argument can be either a
domain or an integer n which is interpreted as the n-dimensional unit
cube.
@end deffn

@anchor{fun-fl.cdr-cdr-nonlinear-rhs-problem}
@deffn Function CDR-NONLINEAR-RHS-PROBLEM @var{DOMAIN} @var{F} &REST @var{ARGS} &KEY @var{SOURCE} @var{REACTION} &ALLOW-OTHER-KEYS
@findex CDR-NONLINEAR-RHS-PROBLEM
Returns the Newton linearization @math{-Delta u + F'(u) u = F'(u) u -
F(u)} for the nonlinear problem @math{-Delta u +F(u) =0}.
@end deffn

@node Package FL.ELLSYS, Package FL.ELASTICITY, Package FL.CDR, Reference manual
@section Package FL.ELLSYS

This package contains the problem definition of systems
of convection-diffusion-reaction equations.  The system is given in the
following form which is suited for a fixed-point iteration:

@math{-div(a(x,u_old,nabla u_old) nabla u)
 + div(b(x,u_old,nabla u_old) u) +
 + c(x,u_old,nabla u_old) nabla u +
 + r(x,u_old,nabla u_old) u
= f(x,u_old, nabla u_old) 
- div(g(x,u_old, nabla u_old))
- div(a(x,u_old,nabla u_old) h(x,u_old, nabla u_old)) }

where @math{u:G to R^N}.  Note that the last two terms are introduced in
the variational formulation and imply a natural Neumann boundary condition
@math{derivative{u}{n} = (g+a h) cdot n} at boundaries where no Dirichlet
constraints are posed.

@anchor{class-fl.ellsys-<ellsys-problem>}
@deftp Class <ELLSYS-PROBLEM>
@tindex <ELLSYS-PROBLEM>
Systems of convection-diffusion-reaction equations.  The
coefficients should be vector-valued functions in this case.

Superclasses: <PDE-PROBLEM>
@end deftp

@anchor{fun-fl.ellsys-ellsys-model-problem}
@deffn Function ELLSYS-MODEL-PROBLEM @var{DOMAIN} @var{COMPONENTS} &KEY @var{A} @var{B} @var{C} @var{D} @var{R} @var{F} @var{G} @var{H} (@var{DIRICHLET} @var{NIL} @var{DIRICHLET-P}) @var{INITIAL} @var{SIGMA} @var{EVP} @var{PROPERTIES} @var{DERIVED-CLASS}
@findex ELLSYS-MODEL-PROBLEM
Generates a rather general elliptic problem on the given domain.
@end deffn

@anchor{fun-fl.ellsys-isotropic-diffusion}
@deffn Function ISOTROPIC-DIFFUSION @var{DIM} @var{VALUES}
@findex ISOTROPIC-DIFFUSION
Returns a sparse diagonal diffusion tensor with isotropic diffusion in
each component.  @arg{value} should be a vector or a number and contains
the amount of diffusion in each component.
@end deffn

@anchor{fun-fl.ellsys-linearization}
@deffn Function LINEARIZATION @var{REACTION-JET}
@findex LINEARIZATION
Returns a list of two functions namely @math{u mapsto R(u)-DR(u)u}
and @math{u mapsto -DR(u)} which can be used directly in the
discretization as source and reaction term.
@end deffn

@anchor{fun-fl.ellsys-nr-of-components}
@deffn Function NR-OF-COMPONENTS @var{PROBLEM}
@findex NR-OF-COMPONENTS
Returns the number of components for @arg{problem}.
@end deffn

@node Package FL.ELASTICITY, Package FL.NAVIER-STOKES, Package FL.ELLSYS, Reference manual
@section Package FL.ELASTICITY

Defines elasticity problems.

@anchor{class-fl.elasticity-<elasticity-problem>}
@deftp Class <ELASTICITY-PROBLEM>
@tindex <ELASTICITY-PROBLEM>
An elasticity problem is a special instance of an
elliptic sytems.

Superclasses: <ELLSYS-PROBLEM>
@end deftp

@anchor{fun-fl.elasticity-check-elasticity-tensor}
@deffn Function CHECK-ELASTICITY-TENSOR @var{TENSOR} @var{DIM} &OPTIONAL (@var{THRESHOLD} 1.e-6)
@findex CHECK-ELASTICITY-TENSOR
Checks the symmetries in the elasticity tensor.
@end deffn

@anchor{fun-fl.elasticity-isotropic-elasticity-tensor}
@deffn Function ISOTROPIC-ELASTICITY-TENSOR &KEY @var{DIM} @var{LAMBDA} @var{MU}
@findex ISOTROPIC-ELASTICITY-TENSOR
Returns the tensor corresponding to the Lam'e constants @math{lambda}
and @math{mu}, i.e.:

@math{A_{ij}^{kl} = lambda delta_{ik} delta_{jl} + mu (delta_{ij}
delta_{kl} + delta_{kj} delta_{il})}.
@end deffn

@node Package FL.NAVIER-STOKES, Package FL.DISCRETIZATION, Package FL.ELASTICITY, Reference manual
@section Package FL.NAVIER-STOKES

Defines incompressible Navier-Stokes problems as a
special case of general elliptic systems.

@anchor{class-fl.navier-stokes-<navier-stokes-problem>}
@deftp Class <NAVIER-STOKES-PROBLEM>
@tindex <NAVIER-STOKES-PROBLEM>
Navier-Stokes problem.

Superclasses: <ELLSYS-PROBLEM>
@end deftp

@anchor{fun-fl.navier-stokes-navier-stokes-inertia-coefficients}
@deffn Function NAVIER-STOKES-INERTIA-COEFFICIENTS @var{DIM} @var{REYNOLDS}
@findex NAVIER-STOKES-INERTIA-COEFFICIENTS
Yields a quasi-Newton linearization of the term @math{u . grad u} which
has the form
@math{a Re u0 . grad u + b Re u . grad u0 = (a + b - 1) Re u0 . grad u0}
a and b are given by the values of the special variables @var{*alpha*} and
@var{*beta*}.
@end deffn

@node Package FL.DISCRETIZATION, Package FL.ELLSYS-FE, Package FL.NAVIER-STOKES, Reference manual
@section Package FL.DISCRETIZATION

The @package{FL.DISCRETIZATION} package defines
@class{<discretization>} as an abstract class and
@class{<fe-discretization>} as a concrete derived class.

The key for local assembly is given by the generic function
@function{get-fe}, which yields a suitable finite element for a given cell.
The value of @function{get-fe} is a class @class{<fe>} for scalar problems
or @class{<vector-fe>} for vector-valued problems which contains
information on base functions and node functionals.  Another generic
function @function{quadrature-rule} computes memoized quadrature rules for
those finite elements.

Obviously, also non-standard finite element discretizations like hp-methods
would fit into this scheme.  The key for local assembly is given by the
generic function @function{get-fe}, which yields a suitable finite element
for a given cell.  The value of @function{get-fe} is a class @class{<fe>}
for scalar problems or @class{<vector-fe>} for vector-valued problems which
contains information on base functions and node functionals.  Another
generic function @function{quadrature-rule} computes memoized quadrature
rules for those finite elements.

The file @path{lagrange.lisp} provides Lagrange finite elements of
arbitrary order.  The evaluation points for the node functionals may be
chosen either uniformly distributed or at the Gauss-Lobatto points.  The
latter choice of points yields better stability properties but is
restricted to cube meshes.  Also functions for constructing cell mappings
by pointwise evaluation of the domain boundary are provided here, which may
be used to construct isoparametric domain approximations.

In the file @path{fedisc.lisp}, the function @function{fe-discretize} is
defined.  This function performs the standard steps for finite element
discretization: interior assembly, assembly and elimination of hanging-node
and essential-boundary constraints.  It works on a blackboard as explained
in Section @ref{Blackboards} and can reuse already available matrix-vector
structure.  There is a somewhat less flexible interface provided by the
funtion @function{discretize-globally} which calls
@function{fe-discretize}.

In the files @path{ellsys-fe.lisp}, @path{elasticity-fe.lisp} and
@path{navier-stokes.lisp} one can find methods for local assembly for the
different problems.  They are defined in own packages which use both the
package @package{FL.DISCRETIZATION} and the package for the particular
problem.

@anchor{var-fl.discretization-*quadrature-order*}
@defvr Variable *QUADRATURE-ORDER*
@vindex *QUADRATURE-ORDER*
Quadrature order to be used.  NIL determines the order automatically.
@end defvr

@anchor{var-fl.discretization-*suggested-discretization-order*}
@defvr Variable *SUGGESTED-DISCRETIZATION-ORDER*
@vindex *SUGGESTED-DISCRETIZATION-ORDER*
The suggested order of discretization.  In non-nil, this value should be
taken into account by methods to @arg{select-discretization}.
@end defvr

@anchor{class-fl.discretization-<ansatz-space-automorphism>}
@deftp Class <ANSATZ-SPACE-AUTOMORPHISM>
@tindex <ANSATZ-SPACE-AUTOMORPHISM>
A automorphism of an ansatz space.

Superclasses: <ANSATZ-SPACE-MORPHISM> <ANSATZ-SPACE-OBJECT>
@end deftp

@anchor{class-fl.discretization-<ansatz-space-morphism>}
@deftp Class <ANSATZ-SPACE-MORPHISM>
@tindex <ANSATZ-SPACE-MORPHISM>
A mapping between two ansatz-spaces.
@end deftp

@anchor{class-fl.discretization-<ansatz-space-vector>}
@deftp Class <ANSATZ-SPACE-VECTOR>
@tindex <ANSATZ-SPACE-VECTOR>
A sparse vector which is interpreted as the ansatz-space
for a specific fe-class on a given mesh.

Superclasses: <ANSATZ-SPACE-OBJECT> <HT-SPARSE-VECTOR>
@end deftp

@anchor{class-fl.discretization-<ansatz-space>}
@deftp Class <ANSATZ-SPACE>
@tindex <ANSATZ-SPACE>
A finite element ansatz space is determined by finite
element discretization, mesh and problem.  The constraints are stored in
the slot @var{properties}.

Superclasses: PROPERTY-MIXIN

Direct slots:
@itemize
@item FE-CLASS: The finite element class for this ansatz space.
@item PROBLEM: The proplem for this ansatz space which determines essential constraints.
@item MESH: The mesh for this ansatz space which determines hanging-node constraints.
@end itemize
@end deftp

@anchor{class-fl.discretization-<discretization>}
@deftp Class <DISCRETIZATION>
@tindex <DISCRETIZATION>
Discretization base class.

Superclasses: PROPERTY-MIXIN
@end deftp

@anchor{class-fl.discretization-<fe-discretization>}
@deftp Class <FE-DISCRETIZATION>
@tindex <FE-DISCRETIZATION>
FE discretization base class.

Superclasses: <DISCRETIZATION>
@end deftp

@anchor{class-fl.discretization-<scalar-fe-discretization>}
@deftp Class <SCALAR-FE-DISCRETIZATION>
@tindex <SCALAR-FE-DISCRETIZATION>
Class for scalar fe discretizations.

Superclasses: <STANDARD-FE-DISCRETIZATION>

Direct slots:
@itemize
@item ORDER: Self-explanatory.
@end itemize
@end deftp

@anchor{class-fl.discretization-<scalar-fe>}
@deftp Class <SCALAR-FE>
@tindex <SCALAR-FE>
A finite element <fe> is given for each reference cell,
e.g. <2-simplex>.  dofs are the degrees of freedom associated with the
cell, basis is the dual basis to dofs in some polynomial space.
subcell-ndofs is the number of ndofs on each subcell.  subcell-indices is a
list of indices for all subcells with dofs.  Usually, the <scalar-fe> will occur
as values of a procedure or as values in a hash-table with the reference
cells as keys.

Superclasses: <FE>

Direct slots:
@itemize
@item DOFS: The associated dofs.  These are Lagrange
functionals associated to the basis functions used for interpolating smooth
functions.
@item BASIS: The fe's basis functions.
@item ORDER: Self-explanatory.
@end itemize
@end deftp

@anchor{class-fl.discretization-<standard-fe-discretization>}
@deftp Class <STANDARD-FE-DISCRETIZATION>
@tindex <STANDARD-FE-DISCRETIZATION>
Finite element discretization where the finite element
depends only on the cell (usually via its reference cell).

Superclasses: <FE-DISCRETIZATION>

Direct slots:
@itemize
@item CELL->FE: A function mapping a cell to a finite element. Usually this
will be a closure memoized over the reference cell.
@end itemize
@end deftp

@anchor{class-fl.discretization-<vector-fe-discretization>}
@deftp Class <VECTOR-FE-DISCRETIZATION>
@tindex <VECTOR-FE-DISCRETIZATION>
Vector FE discretization class.

Superclasses: <STANDARD-FE-DISCRETIZATION>

Direct slots:
@itemize
@item COMPONENTS: Either a vector of components or
 the symbol :variable, if the components vary across the domain
 as is the case for hp-FEM.
@end itemize
@end deftp

@anchor{class-fl.discretization-<vector-fe>}
@deftp Class <VECTOR-FE>
@tindex <VECTOR-FE>
Finite element for vector functions.  Components is a
vector of scalar finite elements.  Subcell-offsets is an array consisting
of arrays which yield such an offset for every subcell.

Superclasses: <FE>

Direct slots:
@itemize
@item COMPONENTS: Self-explanatory.
@item DOFS: Self-explanatory.
@item BASIS: Self-explanatory.
@end itemize
@end deftp

@anchor{fun-fl.discretization-assemble-interior}
@deffn Function ASSEMBLE-INTERIOR @var{ANSATZ-SPACE} @var{WHERE} &KEY @var{LEVEL} @var{MATRIX} @var{MASS-MATRIX} @var{RHS} @var{PARALLEL-CLUSTERING} @var{RHS} @var{MATRIX} &ALLOW-OTHER-KEYS
@findex ASSEMBLE-INTERIOR
Assemble the interior, i.e. ignore constraints arising from boundaries
and hanging nodes.  Discretization is done using the ansatz space
@arg{ansatz-space} on level @arg{level}.  The level argument will usually
be @code{NIL} when performing a global assembly, and be equal to some
number when assembling coarse level matrices for multigrid.  The argument
@arg{where} is a flag indicating where assembly is to be done.  It should
be one of the keywords @code{:surface}, @code{:refined}, @code{:all}.  The
arguments @arg{matrix}, @arg{rhs} should contain vectors/matrices where the
local assembly is accumulated.  Boundary conditions and constraints are not
taken into account within this routine.

In general, this function does most of the assembly work.  Other steps like
handling constraints are intricate, but usually of lower computational
complexity.
@end deffn

@anchor{fun-fl.discretization-cell-integrate}
@deffn Function CELL-INTEGRATE @var{CELL} @var{OBJECT} &KEY (@var{QUADRATURE-ORDER} @var{*QUADRATURE-ORDER*}) (@var{COMBINER} (@var{FUNCTION} @var{M+!})) @var{INITIAL-VALUE} @var{COEFF-FUNC} (@var{KEY} (@var{FUNCTION} @var{IDENTITY})) &ALLOW-OTHER-KEYS
@findex CELL-INTEGRATE
Integrates @arg{object} on @arg{cell}.
@end deffn

@anchor{fun-fl.discretization-cell-key}
@deffn Function CELL-KEY @var{CELL} @var{MESH}
@findex CELL-KEY
If cell is identified, its identification is the key.
@end deffn

@anchor{fun-fl.discretization-cell-lagrange-fe}
@deffn Function CELL-LAGRANGE-FE @var{CELL} @var{ORDER} @var{TYPE} &OPTIONAL @var{DISC}
@findex CELL-LAGRANGE-FE
Returns a Lagrange fe depending on reference cell, an order (which
can be number or vector), and a type symbol.
@end deffn

@anchor{fun-fl.discretization-choose-start-vector}
@deffn Function CHOOSE-START-VECTOR @var{ANSATZ-SPACE}
@findex CHOOSE-START-VECTOR
Choose a reasonable start vector for some strategy.
@end deffn

@anchor{fun-fl.discretization-component}
@deffn Function COMPONENT @var{FE} @var{COMP}
@findex COMPONENT
Returns the @arg{comp}-th component of the (vector) finite element @arg{fe}.
@end deffn

@anchor{fun-fl.discretization-constrained-interpolation-matrix}
@deffn Function CONSTRAINED-INTERPOLATION-MATRIX @var{ANSATZ-SPACE} &KEY @var{LEVEL} @var{WHERE} @var{IMAT} (@var{TYPE} @var{LOCAL})
@findex CONSTRAINED-INTERPOLATION-MATRIX
The multigrid algorithm needs an interpolation which satisfies the
constraints like essential or periodic boundary conditions.
@end deffn

@anchor{fun-fl.discretization-construct-coeff-input}
@deffn Function CONSTRUCT-COEFF-INPUT @var{CELL} @var{GLOBAL} @var{DPHI} @var{VALUES} @var{GRADIENTS} @var{FE-PARAMETERS}
@findex CONSTRUCT-COEFF-INPUT
Constructs a coefficient input list from FE data @arg{cell} is the cell,
@arg{global} is the global coordinate of the integration point,
@arg{values} and @arg{gradients} the values and gradients of the shape
functions at the ip, and @arg{fe-parameters} are the corresponding data of
fe-functions to be evalutated.
@end deffn

@anchor{fun-fl.discretization-discretization-order}
@deffn Function DISCRETIZATION-ORDER @var{DISC}
@findex DISCRETIZATION-ORDER
Returns the order of the discretization.
@end deffn

@anchor{fun-fl.discretization-discretize}
@deffn Function DISCRETIZE @var{DISCRETIZATION} @var{PROBLEM} @var{BLACKBOARD}
@findex DISCRETIZE
Calculates matrix and right-hand side for the
@var{discretization} and the @var{problem}.  Further parameters are
provided inside the @var{blackboard}.
@end deffn

@anchor{fun-fl.discretization-discretize-globally}
@deffn Function DISCRETIZE-GLOBALLY @var{PROBLEM} @var{H-MESH} @var{FE-CLASS}
@findex DISCRETIZE-GLOBALLY
Discretize @arg{problem} on the hierarchical mesh @arg{h-mesh} using
finite elments given by @arg{fe-class}.
@end deffn

@anchor{fun-fl.discretization-discretize-locally}
@deffn Function DISCRETIZE-LOCALLY @var{PROBLEM} @var{COEFFS} @var{FE} @var{QRULE} @var{FE-GEOMETRY} &KEY @var{MATRIX} @var{MASS-MATRIX} @var{RHS} @var{LOCAL-U} @var{LOCAL-V} @var{FE-PARAMETERS} @var{LOCAL-U} @var{LOCAL-V} @var{RESIDUAL-P} @var{FE-PARAMETERS} &ALLOW-OTHER-KEYS
@findex DISCRETIZE-LOCALLY
Computes a local stiffness matrix and right-hand side.
The algorithm will usually work as follows:

@enumerate
@item Get coefficient functions for the patch of the cell.
@item Compute geometry information for all ips (values and gradients of the shape functions).
@item Loop over integration points ip:
  @enumerate
    @item If necessary, compute input for coefficient functions.
          This input may contain values of finite element function in the
          property list @arg{fe-parameters}.
    @item Evaluate coefficient functions at ips.
    @item Add the contributions for matrix and right-hand side to @arg{local-mat} and @arg{local-rhs}.
  @end enumerate
@end enumerate

If @arg{local-u} and @arg{local-v} are set, then
@arg{local-v}*@arg{local-mat}*@arg{local-u} and
@arg{local-v}*@arg{local-rhs} is computed.  This feature may be used later
on for implementing matrixless computations.
@end deffn

@anchor{class-fl.discretization-dof}
@deftp Class DOF
@tindex DOF
Degree of freedom in a finite element.  It is defined as a functional
defined by integration over a sub-cell or by evaluation at a local
coordinate of a sub-cell of a reference cell. 

Direct slots:
@itemize
@item INDEX: Index of the dof in the cell-dof array
@item SUBCELL: Reference subcell on which the dof is defined
@item SUBCELL-INDEX: Index of the reference subcell on which the dof is defined
@item IN-VBLOCK-INDEX: Index of the dof in the subcell vblock
@item COORD: Local coordinate of the dof in the reference subcell
@item GCOORD: Global coordinate of the dof on the reference cell
@item FUNCTIONAL: A functional for functions defined on the reference cell
@end itemize
@end deftp

@anchor{fun-fl.discretization-eliminate-constraints}
@deffn Function ELIMINATE-CONSTRAINTS @var{MAT} @var{RHS} @var{CONSTRAINTS-P} @var{CONSTRAINTS-Q} @var{CONSTRAINTS-R} &KEY @var{ASSEMBLE-LOCALLY} @var{INCLUDE-CONSTRAINTS}
@findex ELIMINATE-CONSTRAINTS
Constraints are given by an equation:  P x = Q x + r

Here x in V, P is an orthogonal projection on a subspace V_P of V, Q maps
some other space which may have nonempty intersection with V_P to V_P.
With S we denote the mapping Id-P.  This function returns the matrix for a
Galerkin method on the constrained space.  It is used for treating hanging
nodes and essential boundary conditions.  When assemble-locally is t the
sparse structure of mat is used instead of the sparse structure of the
hanging node interface.  When include-constraints is non-nil, the
constraints are included in matrix and rhs.
@end deffn

@anchor{fun-fl.discretization-essential-boundary-constraints}
@deffn Function ESSENTIAL-BOUNDARY-CONSTRAINTS @var{PROBLEM} @var{ANSATZ-SPACE} &KEY @var{LEVEL} @var{WHERE} @var{INTERFACE} (@var{WHERE} @var{SURFACE})
@findex ESSENTIAL-BOUNDARY-CONSTRAINTS
Computation of essential constraints.  Should probably
be incorporated into the ansatz-space definition.
@end deffn

@anchor{fun-fl.discretization-extended-extract}
@deffn Function EXTENDED-EXTRACT @var{MAT} @var{KEYS} &KEY @var{ROW?} @var{COL?} (@var{ROW?} @var{T}) (@var{COL?} @var{T})
@findex EXTENDED-EXTRACT
Extract a sub-matrix from a sparse matrix for the given keys.
@end deffn

@anchor{fun-fl.discretization-fe-cell-geometry}
@deffn Function FE-CELL-GEOMETRY @var{CELL} @var{SAMPLE-POINTS} &KEY @var{WEIGHTS} @var{METRIC} @var{VOLUME} &AUX (@var{N} (@var{LENGTH} @var{SAMPLE-POINTS}))
@findex FE-CELL-GEOMETRY
Collects cell geometry information at @arg{sample-points} inside a
property list.
@end deffn

@anchor{fun-fl.discretization-fe-discretize}
@deffn Function FE-DISCRETIZE @var{BLACKBOARD}
@findex FE-DISCRETIZE
Finite element discretization for an ansatz space provided on the
blackboard.
@end deffn

@anchor{fun-fl.discretization-fe-extraction-information}
@deffn Function FE-EXTRACTION-INFORMATION @var{FE} @var{INDICES}
@findex FE-EXTRACTION-INFORMATION
Computes information for extracting components out of a vector finite
 element.
@end deffn

@anchor{fun-fl.discretization-fe-extreme-values}
@deffn Function FE-EXTREME-VALUES @var{ASV} &KEY @var{CELLS} @var{SKELETON} @var{COMPONENT}
@findex FE-EXTREME-VALUES
Computes the extreme values of a finite element function over the domain
or some region.  The result is a pair, the car being the minimum values and
the cdr the maximum values.  Each part is a matrix of the format ncomps x
multiplicity.
@end deffn

@anchor{fun-fl.discretization-fe-gradient}
@deffn Function FE-GRADIENT @var{ASV} @var{GLOBAL-POS}
@findex FE-GRADIENT
Evaluates the gradient of the FE ansatz-space-vector @arg{asv} at @arg{global-pos}.
@end deffn

@anchor{fun-fl.discretization-fe-integrate}
@deffn Function FE-INTEGRATE @var{ASV} &KEY @var{CELLS} @var{SKELETON} @var{INITIAL-VALUE} @var{COMBINER} @var{KEY} @var{COEFF-FUNC} (@var{COMBINER} (@var{FUNCTION} @var{M+!})) (@var{KEY} (@var{FUNCTION} @var{IDENTITY}))
@findex FE-INTEGRATE
Integrates a finite element function over the domain.  key is a
transformer function, as always (e.g. #'abs if you want the L1-norm).
@end deffn

@anchor{fun-fl.discretization-fe-local-gradient}
@deffn Function FE-LOCAL-GRADIENT @var{ASV} @var{CELL} @var{LOCAL-POS}
@findex FE-LOCAL-GRADIENT
Evaluates the gradient of a FE ansatz-space-vector on @arg{cell} at @arg{local-pos}.
@end deffn

@anchor{fun-fl.discretization-fe-local-value}
@deffn Function FE-LOCAL-VALUE @var{ASV} @var{CELL} @var{LOCAL-POS}
@findex FE-LOCAL-VALUE
Evaluates a FE ansatz-space-vector in @arg{cell} at @arg{local-pos}.
@end deffn

@anchor{fun-fl.discretization-fe-value}
@deffn Function FE-VALUE @var{ASV} @var{GLOBAL-POS}
@findex FE-VALUE
Evaluates a FE ansatz-space-vector at @arg{global-pos}.
@end deffn

@anchor{fun-fl.discretization-gauss-rule}
@deffn Function GAUSS-RULE @var{FACTOR-DIMS} @var{S}
@findex GAUSS-RULE
Returns an s-point Gauss integration rule.
@end deffn

@anchor{fun-fl.discretization-get-fe}
@deffn Function GET-FE @var{FE-DISC} @var{CELL}
@findex GET-FE
Returns the finite element for the given discretization
and reference cell.
@end deffn

@anchor{fun-fl.discretization-get-local-from-global-mat}
@deffn Function GET-LOCAL-FROM-GLOBAL-MAT @var{GLOBAL-MAT} @var{CELL} &OPTIONAL @var{DOMAIN-CELL}
@findex GET-LOCAL-FROM-GLOBAL-MAT
Maps the region in the global stiffness matrix
determined by cell to a local matrix array.
@end deffn

@anchor{fun-fl.discretization-get-local-from-global-vec}
@deffn Function GET-LOCAL-FROM-GLOBAL-VEC @var{CELL} @var{GLOBAL-VEC}
@findex GET-LOCAL-FROM-GLOBAL-VEC
Maps the region in global-vec determined by cell to a
local vector.
@end deffn

@anchor{fun-fl.discretization-hierarchical-mesh}
@deffn Function HIERARCHICAL-MESH @var{ASO}
@findex HIERARCHICAL-MESH
The hierarchical mesh for the given ansatz-space or ansatz-space object.
@end deffn

@anchor{fun-fl.discretization-increment-global-by-local-mat}
@deffn Function INCREMENT-GLOBAL-BY-LOCAL-MAT @var{GLOBAL-MAT} @var{LOCAL-MAT} @var{CELL} &OPTIONAL @var{DOMAIN-CELL}
@findex INCREMENT-GLOBAL-BY-LOCAL-MAT
Increments the region in global-mat determined by cell
to the values of local-mat.
@end deffn

@anchor{fun-fl.discretization-increment-global-by-local-vec}
@deffn Function INCREMENT-GLOBAL-BY-LOCAL-VEC @var{CELL} @var{GLOBAL-VEC} @var{LOCAL-VEC}
@findex INCREMENT-GLOBAL-BY-LOCAL-VEC
Increments the region in global-vec determined by cell
to the values of the local vector array.
@end deffn

@anchor{fun-fl.discretization-interpolate-on-refcell}
@deffn Function INTERPOLATE-ON-REFCELL @var{FE} @var{FUNCTION}
@findex INTERPOLATE-ON-REFCELL
Interpolates @arg{function} on the reference cell of the finite element
@arg{fe}.  Returns a standard-matrix corresponding to the block in the
sparse vector.
@end deffn

@anchor{fun-fl.discretization-interpolation-matrix}
@deffn Function INTERPOLATION-MATRIX @var{ANSATZ-SPACE} &KEY @var{LEVEL} @var{REGION} @var{IMAT} (@var{TYPE} @var{*INTERPOLATION-TYPE*})
@findex INTERPOLATION-MATRIX
On each cell of the skeleton @arg{region} or on all cells of level
@arg{level} of the mesh of @arg{ansatz-space}, a local interpolation matrix
is collected into an interpolation matrix.  @arg{type} is the interpolation
type having a default value @var{*interpolation-type*}.
@end deffn

@anchor{fun-fl.discretization-ip-gradients}
@deffn Function IP-GRADIENTS @var{FE} @var{OBJ}
@findex IP-GRADIENTS
Returns a vector of local gradient matrices for
@arg{obj} which may be a vector of integration points or a quadrature rule.
Note that this function is memoized using an :around method.
@end deffn

@anchor{fun-fl.discretization-ip-values}
@deffn Function IP-VALUES @var{FE} @var{OBJ}
@findex IP-VALUES
Returns a vector of ip values for @arg{obj} which may
be a vector of integration points or a quadrature rule.  Note that this
function is memoized using an :around method.
@end deffn

@anchor{fun-fl.discretization-lagrange-ansatz-space}
@deffn Function LAGRANGE-ANSATZ-SPACE @var{PROBLEM} @var{MESH} &KEY (@var{ORDER} 1) (@var{TYPE} @var{UNIFORM})
@findex LAGRANGE-ANSATZ-SPACE
A constructor for a problem-dependent Lagrange fe.  Here, the number of
components may vary with the respective patch.
@end deffn

@anchor{fun-fl.discretization-lagrange-fe}
@deffn Function LAGRANGE-FE @var{ORDER} &KEY (@var{NR-COMPS} 1) (@var{TYPE} @var{UNIFORM})
@findex LAGRANGE-FE
Constructor for Lagrange fe.  nr-comps=nil builds a scalar fe-discretization,
otherwise a vector-fe-discretization is built.
@end deffn

@anchor{fun-fl.discretization-lagrange-mapping}
@deffn Function LAGRANGE-MAPPING @var{ORDER} &OPTIONAL (@var{TYPE} @var{UNIFORM})
@findex LAGRANGE-MAPPING
Returns a function which maps a cell by a polynomial which is obtained
by interpolating the boundary map via Lagrange interpolation.
@end deffn

@anchor{fun-fl.discretization-local-imatrix}
@deffn Function LOCAL-IMATRIX @var{RULE} @var{FE} &OPTIONAL (@var{TYPE} @var{LOCAL})
@findex LOCAL-IMATRIX
Memoized call of compute-local-imatrix.
@end deffn

@anchor{fun-fl.discretization-local-pmatrix}
@deffn Function LOCAL-PMATRIX @var{RULE} @var{FE}
@findex LOCAL-PMATRIX
Memoized call of compute-local-pmatrix.
@end deffn

@anchor{fun-fl.discretization-local-transfer-matrix}
@deffn Function LOCAL-TRANSFER-MATRIX @var{FE-FROM} @var{FE-TO}
@findex LOCAL-TRANSFER-MATRIX
Computes a local transfer matrix between different FE spaces.
@end deffn

@anchor{fun-fl.discretization-make-fe-ansatz-space}
@deffn Function MAKE-FE-ANSATZ-SPACE @var{FE-CLASS} @var{PROBLEM} @var{MESH}
@findex MAKE-FE-ANSATZ-SPACE
Constructor of @class{<ansatz-space>}.
@end deffn

@anchor{fun-fl.discretization-make-local-mat}
@deffn Function MAKE-LOCAL-MAT @var{AS1} @var{CELL1} &OPTIONAL @var{AS2} @var{CELL2}
@findex MAKE-LOCAL-MAT
Generates a local matrix discretization for the given ansatz-space(s).
@end deffn

@anchor{fun-fl.discretization-make-local-vec}
@deffn Function MAKE-LOCAL-VEC @var{ANSATZ-SPACE} @var{CELL}
@findex MAKE-LOCAL-VEC
Generates a local vector for local discretization.
@end deffn

@anchor{fun-fl.discretization-multiple-evaluate-local-fe}
@deffn Function MULTIPLE-EVALUATE-LOCAL-FE @var{LOCAL-VEC} @var{SHAPE-VALUES}
@findex MULTIPLE-EVALUATE-LOCAL-FE
Evaluates the vector given in @arg{local-vec} at multiple points.  Here
@arg{local-vec} should be a data vector obtained with
@function{get-local-from-global-vec} and @arg{ip-values} should be a vector
obtained from @function{ip-values}.
@end deffn

@anchor{fun-fl.discretization-nr-of-dofs}
@deffn Function NR-OF-DOFS @var{FE}
@findex NR-OF-DOFS
Number of degrees of freedom for the (vector) finite element.
@end deffn

@anchor{fun-fl.discretization-nr-of-inner-dofs}
@deffn Function NR-OF-INNER-DOFS @var{FE}
@findex NR-OF-INNER-DOFS
Number of inner degrees of freedom for the (vector) finite element.
@end deffn

@anchor{fun-fl.discretization-product-rule}
@deffn Function PRODUCT-RULE &REST @var{QUADRATURE-RULES}
@findex PRODUCT-RULE
Computes a product rule for several lower-dimensional quadrature rules.
@end deffn

@anchor{fun-fl.discretization-projection-matrix}
@deffn Function PROJECTION-MATRIX @var{ANSATZ-SPACE} &KEY @var{LEVEL} @var{REGION} @var{PMAT}
@findex PROJECTION-MATRIX
The algorithm works as follows: On each cell of the provided cell list
or the whole refinement a local projection matrix computed on the reference
finite element is copied into the global projection matrix.
@end deffn

@anchor{fun-fl.discretization-quadrature-rule}
@deffn Function QUADRATURE-RULE @var{FE}
@findex QUADRATURE-RULE
Computes the quadrature rule to be used for the finite
element @arg{fe}.
@end deffn

@anchor{fun-fl.discretization-random-ansatz-space-vector}
@deffn Function RANDOM-ANSATZ-SPACE-VECTOR @var{ANSATZ-SPACE}
@findex RANDOM-ANSATZ-SPACE-VECTOR
Returns a ansatz space vector for @arg{ansatz-space} filled with random
entries.  Essential constraints are satisfied.
@end deffn

@anchor{fun-fl.discretization-representative}
@deffn Function REPRESENTATIVE @var{OBJ}
@findex REPRESENTATIVE
Returns a representative for this object.
@end deffn

@anchor{fun-fl.discretization-select-discretization}
@deffn Function SELECT-DISCRETIZATION @var{PROBLEM} @var{BLACKBOARD}
@findex SELECT-DISCRETIZATION
Select a discretization for the given @var{problem}
depending on the parameters on the @var{blackboard}.
@end deffn

@anchor{fun-fl.discretization-set-global-to-local-mat}
@deffn Function SET-GLOBAL-TO-LOCAL-MAT @var{GLOBAL-MAT} @var{LOCAL-MAT} @var{CELL} &OPTIONAL @var{DOMAIN-CELL}
@findex SET-GLOBAL-TO-LOCAL-MAT
Sets the region in global-mat determined by cell to the
values of the local matrix array.
@end deffn

@anchor{fun-fl.discretization-set-global-to-local-vec}
@deffn Function SET-GLOBAL-TO-LOCAL-VEC @var{CELL} @var{GLOBAL-VEC} @var{LOCAL-VEC}
@findex SET-GLOBAL-TO-LOCAL-VEC
Sets the region in global-vec determined by cell to the
values of the local vector array.
@end deffn

@anchor{fun-fl.discretization-special-ansatz-space-vector}
@deffn Function SPECIAL-ANSATZ-SPACE-VECTOR @var{ANSATZ-SPACE} &OPTIONAL (@var{TYPE} @var{RANDOM}) (@var{VALUE} 1.0)
@findex SPECIAL-ANSATZ-SPACE-VECTOR
Returns a ansatz space vector for @arg{ansatz-space} filled with
constant or random entries.  Essential constraints are satisfied.
@end deffn

@anchor{fun-fl.discretization-subcell-offsets}
@deffn Function SUBCELL-OFFSETS @var{FE}
@findex SUBCELL-OFFSETS
Reader for subcell-offsets.  This is an array of length the number of
components.  Each component is an array giving the offset of this component
in a sparse vector value block corresponding to the subcell.
@end deffn

@anchor{fun-fl.discretization-test-integration-rule}
@deffn Function TEST-INTEGRATION-RULE @var{POINTS} @var{WEIGHTS} &OPTIONAL (@var{OUTPUT} @var{T})
@findex TEST-INTEGRATION-RULE
Tests the given rule against monomials of increasing degree.
As a by-product this determines the order of the rule.
@end deffn

@anchor{fun-fl.discretization-transfer-matrix}
@deffn Function TRANSFER-MATRIX @var{DOMAIN-AS} @var{IMAGE-AS} &KEY @var{NO-SLAVES}
@findex TRANSFER-MATRIX
Builds a transfer matrix from domain-as to image-as.
@end deffn

@anchor{fun-fl.discretization-weights-for-ips}
@deffn Function WEIGHTS-FOR-IPS @var{BETA} @var{IPS}
@findex WEIGHTS-FOR-IPS
Determines weights for the integration points @arg{ips} such
that they integrate
  @math{int_{-1}^{1} (1+y)^beta ... dy}
 with optimal order.
@end deffn

@node Package FL.ELLSYS-FE, Package FL.ELASTICITY-FE, Package FL.DISCRETIZATION, Reference manual
@section Package FL.ELLSYS-FE

Finite element discretization of a general second order
elliptic system, see the description in the ELLSYS package.  The result is
a local matrix A and local rhs b.  They will usually depend on u_old which
is stored in the solution vector.

@node Package FL.ELASTICITY-FE, Package FL.NAVIER-STOKES-FE, Package FL.ELLSYS-FE, Reference manual
@section Package FL.ELASTICITY-FE

This package specializes the discretization for systems
of elasticity.  Since elasticity is a special case of elliptic systems
which are handled in @path{ellsys-fe.lisp}, not much remains to do.

@node Package FL.NAVIER-STOKES-FE, Package FL.ITERATION, Package FL.ELASTICITY-FE, Reference manual
@section Package FL.NAVIER-STOKES-FE

This package specializes the finite element
discretization for Navier-Stokes problems.  Up to now, we use only
generalized Taylor hood elements.

@anchor{fun-fl.navier-stokes-fe-navier-stokes-lagrange-fe}
@deffn Function NAVIER-STOKES-LAGRANGE-FE @var{ORDER} @var{DIM} @var{DELTA}
@findex NAVIER-STOKES-LAGRANGE-FE
Returns a generalized Taylor-Hood element @math{(Q^{k+delta})^d/Q^k} of
order @math{k} in dimension @math{d}.
@end deffn

@node Package FL.ITERATION, Package FL.MULTIGRID, Package FL.NAVIER-STOKES-FE, Reference manual
@section Package FL.ITERATION

The @package{FL.ITERATION} package includes the
definition for the abstract classes @class{<solver>},
@class{<iterative-solver>}, as well as the generic functions
@function{iterate} and @function{solve} which constitutes the interface for
linear and non-linear solving.  Both functions work on a blackboard which
is passed together with the iteration used as argument.

Several instances of iterative solvers are implemented, e.g. Gauss-Seidel,
SOR, ILU (in @file{linit.lisp}) and CG (in @file{krylow.lisp}).  A larger
block of code is contained in a separate package @package{FL.MULTIGRID} and
contains the multigrid iteration.  From this class, an algebraic multigrid
iteration is derived in @file{amg.lisp} and a geometric multigrid iteration
in a separate file @file{geomg.lisp} and package @package{FL.GEOMG}.

@anchor{var-fl.iteration-*discrete-iterative-solver-observe*}
@defvr Variable *DISCRETE-ITERATIVE-SOLVER-OBSERVE*
@vindex *DISCRETE-ITERATIVE-SOLVER-OBSERVE*
Standard observe quantities for iterative solvers.
@end defvr

@anchor{var-fl.iteration-*output-depth*}
@defvr Variable *OUTPUT-DEPTH*
@vindex *OUTPUT-DEPTH*
Maximum iteration depth for which status output is done.
@end defvr

@anchor{var-fl.iteration-*step-observe*}
@defvr Variable *STEP-OBSERVE*
@vindex *STEP-OBSERVE*
Observe step number during an iteration.  This should be used as element in the
observe list of an iteration.
@end defvr

@anchor{var-fl.iteration-*time-observe*}
@defvr Variable *TIME-OBSERVE*
@vindex *TIME-OBSERVE*
Observe time during an iteration.  This should be used as element in the
observe list of an iteration.
@end defvr

@anchor{class-fl.iteration-<bi-cgstab>}
@deftp Class <BI-CGSTAB>
@tindex <BI-CGSTAB>
Preconditioned Bi-CGStab iteration

Superclasses: <LINEAR-ITERATION>

Direct slots:
@itemize
@item PRECONDITIONER: Self-explanatory.
@end itemize
@end deftp

@anchor{class-fl.iteration-<block-iteration>}
@deftp Class <BLOCK-ITERATION>
@tindex <BLOCK-ITERATION>
Subspace correction scheme generated by collecting
overlapping blocks of unknowns.

Superclasses: <LINEAR-ITERATION>

Direct slots:
@itemize
@item INNER-ITERATION: Iteration which is used to solve for each block.
@item ORDERING: Self-explanatory.
@item STORE-P: T if diagonal can be stored.
@end itemize
@end deftp

@anchor{class-fl.iteration-<cg>}
@deftp Class <CG>
@tindex <CG>
Preconditioned conjugate gradient iteration

Superclasses: <LINEAR-ITERATION>

Direct slots:
@itemize
@item PRECONDITIONER: Self-explanatory.
@item RESTART-CYCLE: Self-explanatory.
@end itemize
@end deftp

@anchor{class-fl.iteration-<custom-psc>}
@deftp Class <CUSTOM-PSC>
@tindex <CUSTOM-PSC>
PSC with custom BLOCK-SETUP function slot.

Superclasses: <SETUP-BLOCKS-MIXIN> <PSC>
@end deftp

@anchor{class-fl.iteration-<custom-ssc>}
@deftp Class <CUSTOM-SSC>
@tindex <CUSTOM-SSC>
SSC with custom BLOCK-SETUP function slot.

Superclasses: <SETUP-BLOCKS-MIXIN> <SSC>
@end deftp

@anchor{class-fl.iteration-<function>}
@deftp Class <FUNCTION>
@tindex <FUNCTION>
The <function> class is an abstract class for a general
function.  This function will usually accept vector arguments, the dimensions of
domain and image are fixed when defining the function. If the function is
differentiable, the gradient matrix can be obtained by evaluating the gradient
slot.

Direct slots:
@itemize
@item DOMAIN-DIMENSION: Self-explanatory.
@item IMAGE-DIMENSION: Self-explanatory.
@end itemize
@end deftp

@anchor{class-fl.iteration-<gauss-seidel>}
@deftp Class <GAUSS-SEIDEL>
@tindex <GAUSS-SEIDEL>
The Gauss-Seidel iteration is SOR with omega=1.

Superclasses: <SOR>
@end deftp

@anchor{class-fl.iteration-<gradient-method>}
@deftp Class <GRADIENT-METHOD>
@tindex <GRADIENT-METHOD>
Gradient-method.  Better use CG.

Superclasses: <LINEAR-ITERATION>
@end deftp

@anchor{class-fl.iteration-<ilu>}
@deftp Class <ILU>
@tindex <ILU>
Incomplete LU iteration.  omega is the modification
parameter, eta is the diagonal enhancement.

Superclasses: <LINEAR-ITERATION>

Direct slots:
@itemize
@item OMEGA: Self-explanatory.
@item ETA: Self-explanatory.
@item ORDERING: Self-explanatory.
@end itemize
@end deftp

@anchor{class-fl.iteration-<iteration>}
@deftp Class <ITERATION>
@tindex <ITERATION>
The iteration base class.

Direct slots:
@itemize
@item OBSERVE: The initform depends on the subclass.
@item OUTPUT: A boolean indicating if output is to be done.
@item SUCCESS-IF: A form specifying a success criterion.
@item FAILURE-IF: A form specifying a failure criterion.
@item START-TIME: Start time of the iteration.
@item SUCCESS-IF-FN: Compiled success-if form.
@item FAILURE-IF-FN: Compiled failure-if form.
@end itemize
@end deftp

@anchor{class-fl.iteration-<iterative-solver>}
@deftp Class <ITERATIVE-SOLVER>
@tindex <ITERATIVE-SOLVER>
Base class of all iterative solvers and solution
strategies.

Superclasses: <ITERATION> <SOLVER>
@end deftp

@anchor{class-fl.iteration-<iterator>}
@deftp Class <ITERATOR>
@tindex <ITERATOR>
An <iterator> object contains functions doing iteration
work or flags indicating which work has or has not to be done for calling
that iterator.  It is generated by the generic function make-iterator.

Superclasses: PROPERTY-MIXIN

Direct slots:
@itemize
@item MATRIX: The matrix on which the iterator is working.
@item INITIALIZE: NIL or an initialization function which is called with the
solution, rhs, and residual as arguments.
@item INITIALIZEDP: Flag, if initialization has been done.
@item ITERATE: A function of
the arguments solution, rhs, and residual which performs an update step.
@item RESIDUAL-BEFORE: T if the
residual has to be up-to-date before the iteration step.
@item RESIDUAL-AFTER: T if the
residual is updated through the iteration step.
@end itemize
@end deftp

@anchor{class-fl.iteration-<linear-iteration>}
@deftp Class <LINEAR-ITERATION>
@tindex <LINEAR-ITERATION>
The <linear-iteration> class.  Linear iterations are
e.g. <gauss-seidel> or <multigrid>.

Direct slots:
@itemize
@item DAMP: Self-explanatory.
@item STORE-P: Store decomposition for multiple applications.
@end itemize
@end deftp

@anchor{class-fl.iteration-<linear-solver>}
@deftp Class <LINEAR-SOLVER>
@tindex <LINEAR-SOLVER>
Class for linear iterative solvers.

Superclasses: <DISCRETE-ITERATIVE-SOLVER>

Direct slots:
@itemize
@item ITERATION: The inner iteration.
@end itemize
@end deftp

@anchor{class-fl.iteration-<lu>}
@deftp Class <LU>
@tindex <LU>
A linear iteration interface for the LU exact solver.

Superclasses: <LINEAR-ITERATION>

Direct slots:
@itemize
@item STORE-P: Store decomposition for multiple applications.
@end itemize
@end deftp

@anchor{class-fl.iteration-<multi-iteration>}
@deftp Class <MULTI-ITERATION>
@tindex <MULTI-ITERATION>
One step of this iteration performs nr-steps of the base
iteration.

Superclasses: <LINEAR-ITERATION>

Direct slots:
@itemize
@item BASE: Base iteration.
@item NR-STEPS: Number of steps with which the base iteration
is performed.
@end itemize
@end deftp

@anchor{class-fl.iteration-<newton>}
@deftp Class <NEWTON>
@tindex <NEWTON>
Class for the Newton iteration.

Superclasses: <NONLINEAR-SOLVER>
@end deftp

@anchor{class-fl.iteration-<parallel-sor>}
@deftp Class <PARALLEL-SOR>
@tindex <PARALLEL-SOR>
A parallel version of SOR.

Superclasses: <SOR>
@end deftp

@anchor{class-fl.iteration-<psc>}
@deftp Class <PSC>
@tindex <PSC>
Parallel subspace correction scheme.

Superclasses: <BLOCK-ITERATION>
@end deftp

@anchor{class-fl.iteration-<safe-linear-solver>}
@deftp Class <SAFE-LINEAR-SOLVER>
@tindex <SAFE-LINEAR-SOLVER>
If failure occurs, object of this class try an
alternative iteration.  Usually this will be a direct decomposition.

Superclasses: <LINEAR-SOLVER>

Direct slots:
@itemize
@item FALLBACK: The fallback iteration.
@item FALLBACK-P: Self-explanatory.
@end itemize
@end deftp

@anchor{class-fl.iteration-<solver>}
@deftp Class <SOLVER>
@tindex <SOLVER>
The base class of linear, nonlinear and whatever
iterative solvers.

Direct slots:
@itemize
@item OUTPUT: Self-explanatory.
@end itemize
@end deftp

@anchor{class-fl.iteration-<special-solver>}
@deftp Class <SPECIAL-SOLVER>
@tindex <SPECIAL-SOLVER>
If you happen to have a problem-adapted solver given as
a function, you may use this base class.

Superclasses: <ITERATIVE-SOLVER>

Direct slots:
@itemize
@item SOLVER-FUNCTION: Self-explanatory.
@end itemize
@end deftp

@anchor{class-fl.iteration-<ssc>}
@deftp Class <SSC>
@tindex <SSC>
Successive subspace correction scheme.

Superclasses: <BLOCK-ITERATION>

Direct slots:
@itemize
@item OMEGA: Self-explanatory.
@end itemize
@end deftp

@anchor{fun-fl.iteration-blocks}
@deffn Function BLOCKS @var{VEC}
@findex BLOCKS
Returns a dictionary mapping keys to entries for @arg{vec}.
@end deffn

@anchor{fun-fl.iteration-compute-residual}
@deffn Function COMPUTE-RESIDUAL @var{A} @var{X} @var{B} @var{R}
@findex COMPUTE-RESIDUAL
Compute the residual r=b-Ax.
@end deffn

@anchor{fun-fl.iteration-evaluate}
@deffn Function EVALUATE @var{F} @var{X}
@findex EVALUATE
Generic evaluation of functions on an argument.  Numbers and
arrays are treated as constants.  Special evaluation is defined for multivariate
polynomials on vectors and for <function> objects.
@end deffn

@anchor{fun-fl.iteration-evaluate-gradient}
@deffn Function EVALUATE-GRADIENT @var{F} @var{X}
@findex EVALUATE-GRADIENT
Generic evaluation of gradients of differentiable functions.
@end deffn

@anchor{fun-fl.iteration-finally}
@deffn Function FINALLY @var{ITER} @var{BLACKBOARD}
@findex FINALLY
Performs final operations.
@end deffn

@anchor{fun-fl.iteration-initially}
@deffn Function INITIALLY @var{ITER} @var{BLACKBOARD}
@findex INITIALLY
Performs initial operations.
@end deffn

@anchor{fun-fl.iteration-intermediate}
@deffn Function INTERMEDIATE @var{ITER} @var{BLACKBOARD}
@findex INTERMEDIATE
Is called after initialization and after each step.
@end deffn

@anchor{fun-fl.iteration-interval-method}
@deffn Function INTERVAL-METHOD @var{FUNC} @var{A} @var{B} @var{ACCURACY}
@findex INTERVAL-METHOD
Finds zeros of functions in 1d by the interval method.
@end deffn

@anchor{fun-fl.iteration-iterate}
@deffn Function ITERATE @var{ITER} @var{BLACKBOARD}
@findex ITERATE
Iterates on the data in the blackboard according to the
iteration iter.
@end deffn

@anchor{fun-fl.iteration-linsolve}
@deffn Function LINSOLVE @var{MAT} @var{RHS} &KEY @var{SOL} @var{RES} @var{OUTPUT} @var{ITERATION} (@var{RESIDUAL-NORM} (@var{FUNCTION} @var{L2-NORM})) (@var{THRESHOLD} 1.e-12) @var{REDUCTION} (@var{MAXSTEPS} 100) @var{SUCCESS-IF} @var{FAILURE-IF} &ALLOW-OTHER-KEYS
@findex LINSOLVE
Old and deprecated interface for solving linear problems.
@end deffn

@anchor{fun-fl.iteration-lu-solver}
@deffn Function LU-SOLVER &KEY (@var{OUTPUT} @var{NIL} @var{OUTPUT-P})
@findex LU-SOLVER
LU decomposition without pivoting.
@end deffn

@anchor{fun-fl.iteration-make-iterator}
@deffn Function MAKE-ITERATOR @var{LINIT} @var{MAT}
@findex MAKE-ITERATOR
Constructs an iterator object given a linear iteration
and a matrix.
@end deffn

@anchor{fun-fl.iteration-next-step}
@deffn Function NEXT-STEP @var{ITER} @var{BLACKBOARD}
@findex NEXT-STEP
Does a step of the iteration.
@end deffn

@anchor{fun-fl.iteration-product-iterator}
@deffn Function PRODUCT-ITERATOR @var{ITERATOR} @var{NR-STEPS}
@findex PRODUCT-ITERATOR
Returns an iterator which does several steps of the given iterator.
@end deffn

@anchor{fun-fl.iteration-setup-blocks}
@deffn Function SETUP-BLOCKS @var{BLOCKIT} @var{MATRIX}
@findex SETUP-BLOCKS
Setup routine for determining the blocking of unknowns.
Returns a list of blocks where each block is a vector of keys.  May return
a second value which is a list of pair.  Each pair is of the form
start-index/end-index and can be used to filter out different fe
components.
@end deffn

@anchor{fun-fl.iteration-solve}
@deffn Function SOLVE @var{SOLVER} &OPTIONAL @var{BLACKBOARD}
@findex SOLVE
Solve a problem specified on the blackboard.  Returns a
modified blackboard.  The returned blackboard is guaranteed to contain at
least the fields :solution and :status.  :status is one of the values
:success or :failure.

SOLVE can also be called as (SOLVE blackboard) and will then try to figure
out a suitable solver itself.
@end deffn

@anchor{fun-fl.iteration-terminate-p}
@deffn Function TERMINATE-P @var{ITER} @var{BLACKBOARD}
@findex TERMINATE-P
Tests terminating conditions.  Returns either NIL or
:success or :failure.
@end deffn

@node Package FL.MULTIGRID, Package FL.GEOMG, Package FL.ITERATION, Reference manual
@section Package FL.MULTIGRID

This package contains the definition of the multigrid
iteration including algebraic multigrid (AMG).

@anchor{class-fl.multigrid-<correction-scheme>}
@deftp Class <CORRECTION-SCHEME>
@tindex <CORRECTION-SCHEME>
This is a mixin-class which yields the correction
scheme.  It should be merged !before! <mg-iteration> for standard CLOS
class precedence.
@end deftp

@anchor{class-fl.multigrid-<fas>}
@deftp Class <FAS>
@tindex <FAS>
This is a mixin-class for <mg-iteration> which yields
the behaviour of Brandt's FAS scheme.  It should be merged !before!
<mg-iteration> or the derived class <geometric-mg> when using standard CLOS
class precedence.
@end deftp

@anchor{class-fl.multigrid-<mg-iteration>}
@deftp Class <MG-ITERATION>
@tindex <MG-ITERATION>
The multigrid iteration is a linear iteration specially
suited for the solution of systems of equations with elliptic terms.  In
ideal situations, it solves such systems with optimal complexity.  It is a
complicated linear iteration, which consists of applying simple linear
iterators as smoothers on a hierarchy of grids.  This grid hierarchy is
obtained either by discretizing on successively refined meshes (geometric
multigrid) or it is constructed from matrix information alone (algebraic
multigrid).

The <mg-iteration> is not intended to be used directly.  Only incorporating
mixins like <correction-scheme> or <fas> results in concrete classes like
<algebraic-mg>.

Superclasses: <LINEAR-ITERATION>

Direct slots:
@itemize
@item PRE-SMOOTHER: Self-explanatory.
@item PRE-STEPS: Self-explanatory.
@item POST-SMOOTHER: Self-explanatory.
@item POST-STEPS: Self-explanatory.
@item GAMMA: Self-explanatory.
@item BASE-LEVEL: Self-explanatory.
@item COARSE-GRID-ITERATION: Self-explanatory.
@item FMG: Self-explanatory.
@item COMBINATION: Switch between additive and multiplicative
combination of corrections from different levels.  The additive version
should be used as a preconditioner.
@end itemize
@end deftp

@anchor{class-fl.multigrid-<selection-amg>}
@deftp Class <SELECTION-AMG>
@tindex <SELECTION-AMG>
This variant of algebraic multigrid coarsens in a
special way by selecting coarse-grid nodes from the fine-grid nodes.  This
selection is kept in a table, which is then used by the method build-ip to
build the actual interpolation matrix.

Superclasses: <ALGEBRAIC-MG>
@end deftp

@anchor{class-fl.multigrid-<stueben>}
@deftp Class <STUEBEN>
@tindex <STUEBEN>
This provides something like Stueben's variant for
selection amg.  The original Ruge-Stueben algorithm was developed further
since 1987 by Klaus Stueben and collaborators.  These developments are
published in ....  The algorithm implemented here uses their ideas, but
does not claim to be equivalent to their code which can be bought at SCAI,
St. Augustin, Germany.  At this point, I want to thank Tanja Clees
for several discussions on AMG.

Superclasses: <SELECTION-AMG>

Direct slots:
@itemize
@item THETA: Self-explanatory.
@end itemize
@end deftp

@anchor{fun-fl.multigrid-coarse-grid-matrix}
@deffn Function COARSE-GRID-MATRIX @var{AMG} @var{MAT} @var{PROLONGATION} @var{RESTRICTION}
@findex COARSE-GRID-MATRIX
Computes a coarse-grid matrix from amg, mat,
prolongation and restriction.
@end deffn

@anchor{fun-fl.multigrid-coarsen}
@deffn Function COARSEN @var{AMG} @var{MAT}
@findex COARSEN
Given AMG and matrix, this generic function returns
coarse-grid matrix, interpolation and restriction matrices for one coarsening
step.
@end deffn

@anchor{fun-fl.multigrid-dirichlet-dof-p}
@deffn Function DIRICHLET-DOF-P @var{KEY} @var{MAT}
@findex DIRICHLET-DOF-P
Checks if key does not depend on other keys, so that it can be kept on
the fine grid.
@end deffn

@anchor{fun-fl.multigrid-galerkin-product}
@deffn Function GALERKIN-PRODUCT @var{R} @var{A} @var{P}
@findex GALERKIN-PRODUCT
Builds the Galerkin product R A P.  This function works for every type
of matrices for which the row- and column-loop macros are defined.  This
procedure should be inlined into an environment where types are known for
avoiding generic arithmetic.
@end deffn

@anchor{fun-fl.multigrid-multilevel-decomposition}
@deffn Function MULTILEVEL-DECOMPOSITION @var{MG-IT} @var{A}
@findex MULTILEVEL-DECOMPOSITION
The central generic function constructing the multilevel
hierarchy.
@end deffn

@anchor{fun-fl.multigrid-preprocess-matrix}
@deffn Function PREPROCESS-MATRIX @var{AMG} @var{MAT}
@findex PREPROCESS-MATRIX
Eliminates Dirichlet or slave degrees of freedom which
can be handled well by smoothing.
@end deffn

@anchor{fun-fl.multigrid-prolongation}
@deffn Function PROLONGATION @var{AMG} @var{MAT}
@findex PROLONGATION
Computes a prolongation matrix from amg and mat.  This
is often the essence of an AMG method.
@end deffn

@anchor{fun-fl.multigrid-restriction}
@deffn Function RESTRICTION @var{AMG} @var{MAT} @var{PROL}
@findex RESTRICTION
Compute a restriction matrix from amg, mat and
prolongation.
@end deffn

@anchor{fun-fl.multigrid-select-smoother}
@deffn Function SELECT-SMOOTHER @var{MG-IT} @var{MATRIX}
@findex SELECT-SMOOTHER
Select a suitable smoother depending on multigrid
iteration and matrix.
@end deffn

@anchor{fun-fl.multigrid-slave-dof-p}
@deffn Function SLAVE-DOF-P @var{KEY} @var{MAT}
@findex SLAVE-DOF-P
Checks if nothing depends on key and if key depends on other keys.
@end deffn

@anchor{fun-fl.multigrid-slave-or-dirichlet-dof-p}
@deffn Function SLAVE-OR-DIRICHLET-DOF-P @var{KEY} @var{MAT}
@findex SLAVE-OR-DIRICHLET-DOF-P
Checks if key is a hanging node or a Dirichlet node.
@end deffn

@node Package FL.GEOMG, Package FL.STRATEGY, Package FL.MULTIGRID, Reference manual
@section Package FL.GEOMG

The @package{FL.GEOMG} package contains iterations which
depend on geometric information, obtained for example from the
discretization.  At the moment, these are the geometric multigrid
iteration, an AMG-like scheme for preconditioning high-order
discretizations with low-order ones, and some block smoothers with
overlapping blocks.

@anchor{class-fl.geomg-<geometric-cs>}
@deftp Class <GEOMETRIC-CS>
@tindex <GEOMETRIC-CS>
Geometric multigrid of correction scheme type.

Superclasses: <CORRECTION-SCHEME> <GEOMETRIC-MG>
@end deftp

@anchor{class-fl.geomg-<geometric-fas>}
@deftp Class <GEOMETRIC-FAS>
@tindex <GEOMETRIC-FAS>
Brandt's FAS scheme approximates the unknowns on every
level instead of using corrections.  This requires slightly more work, but
is better suited for handling nonlinear problems and local refinements.

Superclasses: <FAS> <GEOMETRIC-MG>
@end deftp

@anchor{class-fl.geomg-<geometric-psc>}
@deftp Class <GEOMETRIC-PSC>
@tindex <GEOMETRIC-PSC>
PSC with geometry-based block choice.

Superclasses: <GEOMETRIC-BLOCKING-MIXIN> <PSC>
@end deftp

@anchor{class-fl.geomg-<geometric-ssc>}
@deftp Class <GEOMETRIC-SSC>
@tindex <GEOMETRIC-SSC>
SSC with geometry-based block choice.

Superclasses: <GEOMETRIC-BLOCKING-MIXIN> <SSC>
@end deftp

@anchor{class-fl.geomg-<s1-coarse-grid-iterator>}
@deftp Class <S1-COARSE-GRID-ITERATOR>
@tindex <S1-COARSE-GRID-ITERATOR>
Calls LU directly, if the matrix was not reduced to S1
which may happen if there are only Dirichlet vertices.

Superclasses: <LINEAR-ITERATION>
@end deftp

@anchor{class-fl.geomg-<s1-reduction>}
@deftp Class <S1-REDUCTION>
@tindex <S1-REDUCTION>
This class is useful for reducing a higher-order FE
discretization to a first-order FE discretization.  This can afterwards be
treated by ordinary AMG steps.  Even if it has the structure of a
<selection-amg>, it is far from being a pure algebraic multigrid.

Superclasses: <SELECTION-AMG>
@end deftp

@anchor{class-fl.geomg-<vanka>}
@deftp Class <VANKA>
@tindex <VANKA>
Vanka-like smoother for @math{Q^{k+1}/Q^k}
discretizations of Navier-Stokes.

Superclasses: <GEOMETRIC-SSC>
@end deftp

@anchor{fun-fl.geomg-fas}
@deffn Function FAS &REST @var{KEY-ARGS}
@findex FAS
Constructor of a geometric multigrid iteration of FAS type.
@end deffn

@anchor{fun-fl.geomg-geometric-cs}
@deffn Function GEOMETRIC-CS &REST @var{KEY-ARGS}
@findex GEOMETRIC-CS
Constructor of a geometric multigrid iteration of correction scheme
type.
@end deffn

@anchor{fun-fl.geomg-geometric-psc}
@deffn Function GEOMETRIC-PSC &REST @var{REST}
@findex GEOMETRIC-PSC
Constructor of a geometric parallel subspace correction.
@end deffn

@anchor{fun-fl.geomg-geometric-ssc}
@deffn Function GEOMETRIC-SSC &REST @var{REST}
@findex GEOMETRIC-SSC
Constructor of a geometric successive subspace correction.
@end deffn

@anchor{fun-fl.geomg-s1-reduction-amg-solver}
@deffn Function S1-REDUCTION-AMG-SOLVER @var{ORDER} &KEY @var{OUTPUT} @var{REDUCTION} (@var{MAXSTEPS} 100)
@findex S1-REDUCTION-AMG-SOLVER
This is an AMG solver which works also for Lagrange fe of order p by
reducing them to P^1 first.
@end deffn

@node Package FL.STRATEGY, Package FL.GRAPHIC, Package FL.GEOMG, Reference manual
@section Package FL.STRATEGY

This package provides methods for solving problems by
adaptive FEM.

@anchor{var-fl.strategy-*eta-observe*}
@defvr Variable *ETA-OBSERVE*
@vindex *ETA-OBSERVE*
Observe an estimate of the global error.
@end defvr

@anchor{var-fl.strategy-*mentries-observe*}
@defvr Variable *MENTRIES-OBSERVE*
@vindex *MENTRIES-OBSERVE*
Observe entries for the size of the matrix.
@end defvr

@anchor{var-fl.strategy-*stationary-fe-strategy-observe*}
@defvr Variable *STATIONARY-FE-STRATEGY-OBSERVE*
@vindex *STATIONARY-FE-STRATEGY-OBSERVE*
Standard observe quantities for stationary finite element strategies.
@end defvr

@anchor{class-fl.strategy-<duality-error-estimator>}
@deftp Class <DUALITY-ERROR-ESTIMATOR>
@tindex <DUALITY-ERROR-ESTIMATOR>
Estimates the error by testing the difference z-IPz
against the residual.  Here z is the solution of a dual problem in an
enriched finite element space.

Superclasses: <SETUP-ENRICHED-ANSATZ-SPACE> <SOLVE-DUAL-PROBLEM> <LOCAL-TEST-WITH-DUAL> <STANDARD-ERROR-ESTIMATOR>
@end deftp

@anchor{class-fl.strategy-<fe-approximation>}
@deftp Class <FE-APPROXIMATION>
@tindex <FE-APPROXIMATION>
This class describes iterative finite element
appoximation strategies.

Superclasses: <STRATEGY>

Direct slots:
@itemize
@item OBSERVE: Providing initform for <iteration> slot.
@item PLOT-MESH: Plot the mesh at the beginning and after changes.  Can
be a function in which case it is called on the mesh to do the plotting.
@item FE-CLASS: The class of finite element.  If it is not set, it is
automatically chosen.
@item ESTIMATOR: The error estimator, which computes information on the error
distribution in a hash-table in the :ETA-field on the blackboard, as well
as a global estimate in :GLOBAL-ETA which can be used to terminate the
iteration.
@item INDICATOR: The error indicator which marks cells for local refinement.
Usually, this procedure will be based on the error distribution
approximated in the :ETA-field on the blackboard.
@end itemize
@end deftp

@anchor{class-fl.strategy-<fe-interpolation>}
@deftp Class <FE-INTERPOLATION>
@tindex <FE-INTERPOLATION>
This class implements adaptive finite element
interpolation of the given coefficient function as a variant of finite
element approximation.

Superclasses: <FE-APPROXIMATION>

Direct slots:
@itemize
@item COEFFICIENT: A coefficient determining the function to be interpolated.
@end itemize
@end deftp

@anchor{class-fl.strategy-<largest-eta-indicator>}
@deftp Class <LARGEST-ETA-INDICATOR>
@tindex <LARGEST-ETA-INDICATOR>
Puts the fraction of the cells with the largest error
contributions in the refinement table.  Note that a fraction of 1.0 yields
uniform refinement.  Below from-level, global refinement is used.  block-p
indicates that all children of a parent cell have to be refined at once.

Superclasses: <REFINEMENT-INDICATOR>

Direct slots:
@itemize
@item FRACTION: Self-explanatory.
@item PIVOT-FACTOR: Self-explanatory.
@item FROM-LEVEL: Self-explanatory.
@item BLOCK-P: Self-explanatory.
@end itemize
@end deftp

@anchor{class-fl.strategy-<projection-error-estimator>}
@deftp Class <PROJECTION-ERROR-ESTIMATOR>
@tindex <PROJECTION-ERROR-ESTIMATOR>
Estimates the error by measuring the difference between
the solution and a projected solution in a hierarchical mesh by a certain
norm given by local-p and global-p.

Superclasses: <DIFFERENCE-WITH-PROJECTION> <GLOBAL-AND-LOCAL-NORM> <STANDARD-ERROR-ESTIMATOR>
@end deftp

@anchor{class-fl.strategy-<refinement-indicator>}
@deftp Class <REFINEMENT-INDICATOR>
@tindex <REFINEMENT-INDICATOR>
An indicator is used as first argument in the generic
functions indicate which works on a blackboard.  Based on the
quantities computed by an error estimator, i.e. eta, indicate puts a list
of elements to be refined on the blackboard.  When ensure-mesh-quality
is t, the indicator ensures that the difference of mesh widths of
neighboring cells does not become larger than a factor of 4.

Direct slots:
@itemize
@item ENSURE-MESH-QUALITY: Self-explanatory.
@end itemize
@end deftp

@anchor{class-fl.strategy-<region-indicator>}
@deftp Class <REGION-INDICATOR>
@tindex <REGION-INDICATOR>
Marks all cells in a region for refinement.

Superclasses: <REFINEMENT-INDICATOR>

Direct slots:
@itemize
@item IN-REGION: Self-explanatory.
@end itemize
@end deftp

@anchor{class-fl.strategy-<rothe>}
@deftp Class <ROTHE>
@tindex <ROTHE>
Rothe strategy for time-dependent problems.  The idea of
the Rothe method for solving @math{U_t +A U =f} is to do an ODE
time-stepping scheme in an infinite-dimensional function space.  Therefore,
in every time-step, the solution has to be approximated sufficiently well
in the space variable.

Superclasses: <ITERATION>

Direct slots:
@itemize
@item MODEL-TIME: Current time in the time-stepping scheme.
@item TIME-STEP: Self-explanatory.
@item SCHEME: Time-stepping scheme,
e.g. @code{:implicit-euler} or @code{:crank-nicolson}.
@item STATIONARY-SUCCESS-IF: Self-explanatory.
@item STATIONARY-FAILURE-IF: Self-explanatory.
@item PLOT: Self-explanatory.
@item OBSERVE: Providing initform for <iteration> slot.
@end itemize
@end deftp

@anchor{class-fl.strategy-<stationary-fe-strategy>}
@deftp Class <STATIONARY-FE-STRATEGY>
@tindex <STATIONARY-FE-STRATEGY>
This class describes some iterative finite element
solution strategies for continuous, stationary PDE problems.

Superclasses: <FE-APPROXIMATION>

Direct slots:
@itemize
@item OBSERVE: Self-explanatory.
@item SOLVER: The solver for solving the discretized systems.
@end itemize
@end deftp

@anchor{class-fl.strategy-<strategy>}
@deftp Class <STRATEGY>
@tindex <STRATEGY>
A strategy is an iteration for solving a problem defined
on a blackboard.

Superclasses: <ITERATIVE-SOLVER>
@end deftp

@anchor{class-fl.strategy-<uniform-refinement-indicator>}
@deftp Class <UNIFORM-REFINEMENT-INDICATOR>
@tindex <UNIFORM-REFINEMENT-INDICATOR>
Marks all cells for refinement.

Superclasses: <REFINEMENT-INDICATOR>
@end deftp

@anchor{fun-fl.strategy-estimate}
@deffn Function ESTIMATE @var{ERROR-ESTIMATOR} @var{BLACKBOARD}
@findex ESTIMATE
Yields both local and global estimate.
@end deffn

@anchor{fun-fl.strategy-indicate}
@deffn Function INDICATE @var{INDICATOR} @var{BLACKBOARD}
@findex INDICATE
Puts a list of elements to be refined on the blackboard.
@end deffn

@node Package FL.GRAPHIC, Package FL.PLOT, Package FL.STRATEGY, Reference manual
@section Package FL.GRAPHIC

This package provides a low-level interface to external
graphic software; at the moment both IBM's @code{OpenDX} and @code{Gnuplot}
are supported.

@anchor{var-fl.graphic-*default-graphic-program*}
@defvr Variable *DEFAULT-GRAPHIC-PROGRAM*
@vindex *DEFAULT-GRAPHIC-PROGRAM*
Default graphics program.
@end defvr

@anchor{fun-fl.graphic-graphic-commands}
@deffn Function GRAPHIC-COMMANDS @var{OBJECT} @var{PROGRAM} &REST @var{REST} &KEY @var{RANGE} @var{SHAPE} @var{DIMENSION} (@var{FOREGROUND} @var{WHITE}) @var{BACKGROUND} @var{GLYPH-SCALE} (@var{GLYPHS} @var{T}) @var{TUBES} (@var{LINEWIDTH} 1) &ALLOW-OTHER-KEYS
@findex GRAPHIC-COMMANDS
Returns commands for plotting to be sent to the graphics
program.
@end deffn

@anchor{fun-fl.graphic-graphic-file-name}
@deffn Function GRAPHIC-FILE-NAME @var{OBJECT} @var{PROGRAM} &REST @var{REST} &KEY @var{SYSTEM-P} &ALLOW-OTHER-KEYS
@findex GRAPHIC-FILE-NAME
Return a filename for the data of this plot.
@end deffn

@anchor{fun-fl.graphic-graphic-output}
@deffn Function GRAPHIC-OUTPUT @var{OBJECT} @var{PROGRAM} &ALLOW-OTHER-KEYS
@findex GRAPHIC-OUTPUT
Writes the graphic commands for @arg{object}
as needed by the graphic program @arg{program}.
@end deffn

@anchor{fun-fl.graphic-graphic-write-data}
@deffn Function GRAPHIC-WRITE-DATA @var{STREAM} @var{OBJECT} @var{PROGRAM} &REST @var{REST} &KEY @var{TRANSFORMATION} (@var{DEPTH} 0) @var{SHAPE} (@var{RANK} 0) @var{CELL->VALUES} @var{CELLS} @var{DIMENSION} @var{PART} &ALLOW-OTHER-KEYS
@findex GRAPHIC-WRITE-DATA
Write the data file for @arg{program} to
@arg{stream}.
@end deffn

@anchor{fun-fl.graphic-send-graphic-commands}
@deffn Function SEND-GRAPHIC-COMMANDS @var{OBJECT} @var{PROGRAM} &REST @var{REST} &KEY (@var{WINDOW} "femlisp-image") @var{FILENAME} @var{FORMAT} (@var{HEIGHT} 480) (@var{WIDTH} 480) (@var{RESOLUTION} 480) (@var{BACKGROUND} @var{BLACK}) @var{DIMENSION} @var{LEFT} @var{RIGHT} @var{TOP} @var{BOTTOM} (@var{BORDER} @var{T}) (@var{TICS} @var{T}) (@var{TERMINAL} "x11") (@var{OUTPUT} "gnuplot.ps") @var{MESSAGE} &ALLOW-OTHER-KEYS
@findex SEND-GRAPHIC-COMMANDS
Routine for sending commands to the graphics server.
@end deffn

@node Package FL.PLOT, Package FL.DOMAINS, Package FL.GRAPHIC, Reference manual
@section Package FL.PLOT

This package provides a high-level interface to
plotting.  It defines a generic function @code{PLOT} which can be used to
plot several types of objects, e.g. cells, meshes, finite element and
coefficient functions.

@anchor{fun-fl.plot-plot}
@deffn Function PLOT @var{OBJECT} &KEY @var{TRANSFORMATION} @var{PART} @var{SHAPE} (@var{RANK} 0) @var{KEY} (@var{COMPONENT} 0) (@var{INDEX} 0) @var{DEPTH} @var{CELLS} @var{COEFFICIENT} (@var{REFINEMENTS} 0) @var{PARAMETRIC} @var{DOMAIN} @var{MESH} (@var{PROGRAM} @var{*DEFAULT-GRAPHIC-PROGRAM*}) &ALLOW-OTHER-KEYS
@findex PLOT
Plot is a generic function which dispatches depending on
the type of object it receives.  Its behaviour can additionally be modified
by keyword parameters.
@end deffn

@node Package FL.DOMAINS, Package FL.APPLICATION, Package FL.PLOT, Reference manual
@section Package FL.DOMAINS

Femlisp package for domain definitions.

@anchor{fun-fl.domains-bl-patch-on-artificial-boundary}
@deffn Function BL-PATCH-ON-ARTIFICIAL-BOUNDARY @var{BL-DOMAIN} @var{PATCH}
@findex BL-PATCH-ON-ARTIFICIAL-BOUNDARY
Returns the artificial boundary on which the distributional source
acts.
@end deffn

@anchor{fun-fl.domains-bl-patch-on-lower-boundary}
@deffn Function BL-PATCH-ON-LOWER-BOUNDARY @var{BL-DOMAIN} @var{PATCH}
@findex BL-PATCH-ON-LOWER-BOUNDARY
Returns T if the patch is on the lower oscillating boundary.
@end deffn

@anchor{fun-fl.domains-bl-patch-on-pellet-boundary}
@deffn Function BL-PATCH-ON-PELLET-BOUNDARY @var{BL-DOMAIN} @var{PATCH}
@findex BL-PATCH-ON-PELLET-BOUNDARY
Returns T if the patch is on the pellet.
@end deffn

@anchor{fun-fl.domains-bl-patch-on-upper-boundary}
@deffn Function BL-PATCH-ON-UPPER-BOUNDARY @var{BL-DOMAIN} @var{PATCH}
@findex BL-PATCH-ON-UPPER-BOUNDARY
Returns T if the patch is on the upper boundary.
@end deffn

@anchor{fun-fl.domains-n-cell-with-ball-hole}
@deffn Function N-CELL-WITH-BALL-HOLE @var{DIM} &KEY (@var{RADIUS} 0.25)
@findex N-CELL-WITH-BALL-HOLE
Generates an n-dimensional cell domain with an n-ball hole.
@end deffn

@anchor{fun-fl.domains-n-cell-with-ball-inlay}
@deffn Function N-CELL-WITH-BALL-INLAY @var{DIM} &KEY (@var{RADIUS} 0.25)
@findex N-CELL-WITH-BALL-INLAY
Generates an n-dimensional cell domain with an n-ball inlay.
@end deffn

@anchor{fun-fl.domains-n-cell-with-cubic-hole}
@deffn Function N-CELL-WITH-CUBIC-HOLE @var{DIM}
@findex N-CELL-WITH-CUBIC-HOLE
Generates an n-dimensional cell domain with an n-cube hole.
@end deffn

@anchor{fun-fl.domains-n-cell-with-cubic-inlay}
@deffn Function N-CELL-WITH-CUBIC-INLAY @var{DIM}
@findex N-CELL-WITH-CUBIC-INLAY
Generates an n-dimensional cell domain with an n-cube hole.
@end deffn

@anchor{fun-fl.domains-n-cell-with-ellipsoidal-hole}
@deffn Function N-CELL-WITH-ELLIPSOIDAL-HOLE @var{DIM} &KEY @var{A}
@findex N-CELL-WITH-ELLIPSOIDAL-HOLE
Generates an n-dimensional cell domain with an ellipsoidal hole.
@end deffn

@anchor{fun-fl.domains-n-cube-with-ball-hole}
@deffn Function N-CUBE-WITH-BALL-HOLE @var{DIM} &KEY (@var{RADIUS} 0.25)
@findex N-CUBE-WITH-BALL-HOLE
Generates an n-cube-domain with an n-ball hole using n-cube patches.
@end deffn

@anchor{fun-fl.domains-n-cube-with-ball-inlay}
@deffn Function N-CUBE-WITH-BALL-INLAY @var{DIM} &KEY (@var{RADIUS} 0.25)
@findex N-CUBE-WITH-BALL-INLAY
Generates an n-cube-domain with an n-ball inlay using n-cube patches.
@end deffn

@anchor{fun-fl.domains-n-cube-with-cubic-hole}
@deffn Function N-CUBE-WITH-CUBIC-HOLE @var{DIM}
@findex N-CUBE-WITH-CUBIC-HOLE
Generates an n-cube-domain with an n-cube hole.
@end deffn

@anchor{fun-fl.domains-n-cube-with-cubic-inlay}
@deffn Function N-CUBE-WITH-CUBIC-INLAY @var{DIM}
@findex N-CUBE-WITH-CUBIC-INLAY
Generates an n-cube-domain with an n-cube inlay.
@end deffn

@anchor{fun-fl.domains-n-cube-with-ellipsoidal-hole}
@deffn Function N-CUBE-WITH-ELLIPSOIDAL-HOLE @var{DIM} &KEY @var{A}
@findex N-CUBE-WITH-ELLIPSOIDAL-HOLE
Generates an n-cube-domain with an ellipsoidal hole satisfying (Ax,x)=1
using n-cube patches.
@end deffn

@anchor{fun-fl.domains-oscillating-boundary-domain}
@deffn Function OSCILLATING-BOUNDARY-DOMAIN @var{DIM} @var{F} &KEY @var{GRAD-F} (@var{UPPER} @var{T})
@findex OSCILLATING-BOUNDARY-DOMAIN
Returns a domain with an oscillating lower boundary at $x_n=-1$ where
the oscillation is defined by a scaling function $f$ with values in $R^+$.
Usually, also $grad-f$ should be provided, because it makes possible an
enhanced domain approximation.
@end deffn

@anchor{fun-fl.domains-patch-in-inlay-p}
@deffn Function PATCH-IN-INLAY-P @var{PATCH}
@findex PATCH-IN-INLAY-P
Checks if the patch is part of the inlay including its boundary.  This
is done by checking if all corners lie in the interior of the unit cell.
@end deffn

@anchor{fun-fl.domains-patch-on-inner-boundary-p}
@deffn Function PATCH-ON-INNER-BOUNDARY-P @var{PATCH}
@findex PATCH-ON-INNER-BOUNDARY-P
Checks if the patch is part of the hole boundary.
@end deffn

@anchor{fun-fl.domains-patch-on-n-cube-boundary-p}
@deffn Function PATCH-ON-N-CUBE-BOUNDARY-P @var{PATCH}
@findex PATCH-ON-N-CUBE-BOUNDARY-P
Returns T, if the patch is on the boundary of the n-cube.
@end deffn

@anchor{fun-fl.domains-sinusoidal-bl-cell}
@deffn Function SINUSOIDAL-BL-CELL @var{DIM} &REST @var{REST} &KEY (@var{AMPLITUDE} 0.15) (@var{SHIFT} 1.0) &ALLOW-OTHER-KEYS
@findex SINUSOIDAL-BL-CELL
Returns a boundary layer cell with a sinusoidally oscillating lower
boundary.
@end deffn

@anchor{fun-fl.domains-spline-interpolated-bl-cell}
@deffn Function SPLINE-INTERPOLATED-BL-CELL @var{HEIGHTS}
@findex SPLINE-INTERPOLATED-BL-CELL
Boundary which is interpolated from heights.
@end deffn

@node Package FL.APPLICATION, Package DDO, Package FL.DOMAINS, Reference manual
@section Package FL.APPLICATION

This package uses most other Femlisp packages.  It is
meant to be the package a Femlisp user works in.

@anchor{var-fl.application-*result*}
@defvr Variable *RESULT*
@vindex *RESULT*
Special variable used for storing the blackbboard of the last
computation.
@end defvr

@anchor{fun-fl.application-quit}
@deffn Function QUIT 
@findex QUIT
Quits Femlisp.
@end deffn

@anchor{macro-fl.application-storing}
@deffn Macro STORING &BODY @var{BODY}
@findex STORING
Stores the result of @arg{body} in @var{*result*}.
@end deffn

@node Package DDO, Package DDO-FEMLISP, Package FL.APPLICATION, Reference manual
@section Package DDO

This package provides distributed objects.

@anchor{var-ddo-*communication-real-time*}
@defvr Variable *COMMUNICATION-REAL-TIME*
@vindex *COMMUNICATION-REAL-TIME*
When non-nil, communication time is recorded.
@end defvr

@anchor{var-ddo-*communication-size*}
@defvr Variable *COMMUNICATION-SIZE*
@vindex *COMMUNICATION-SIZE*
When non-nil, communication size is recorded.
@end defvr

@anchor{var-ddo-*debug-show-data*}
@defvr Variable *DEBUG-SHOW-DATA*
@vindex *DEBUG-SHOW-DATA*
When T show all data communicated between processors.  This is only reasonable for
toy problems.
@end defvr

@anchor{var-ddo-*synchronization-merger*}
@defvr Variable *SYNCHRONIZATION-MERGER*
@vindex *SYNCHRONIZATION-MERGER*
Merger for the synchronization which can be a generic function
  dispatching on the class of object.  An example is provided by the
  generic function #'minimum-id-merger.  Usually this dynamic variable will
  be bound around a call to @func{synchronize}.
@end defvr

@anchor{var-ddo-*synchronization-real-time*}
@defvr Variable *SYNCHRONIZATION-REAL-TIME*
@vindex *SYNCHRONIZATION-REAL-TIME*
When non-nil, communication time is recorded.
@end defvr

@anchor{macro-ddo-ddo}
@deffn Macro DDO &BODY @var{COMMANDS}
@findex DDO
Broadcast the given commands
@end deffn

@anchor{macro-ddo-ddo-}
@deffn Macro DDO- &BODY @var{COMMANDS}
@findex DDO-
Call workers sequentially, mainly for debugging purposes if separate
output is desired.  Of course, this should only be called with commands
which do not require synchronization!
@end deffn

@anchor{class-ddo-ddo-container-mixin}
@deftp Class DDO-CONTAINER-MIXIN
@tindex DDO-CONTAINER-MIXIN
Mixin for a ddo container which may contain distributed
and non-distributed objects.  Not used at the moment!

Direct slots:
@itemize
@item DISTRIBUTED-SLOTS: This determines a list of slots for which changes are
propagated.  This is a list consisting of items that are either a symbol or
a pair of the form (symbol . combiner).  Here, the symbol is the name of a
slot and the combiner is a certain function which is called when combining
distributed values.
@end itemize
@end deftp

@anchor{fun-ddo-ddo-performance-check}
@deffn Function DDO-PERFORMANCE-CHECK 
@findex DDO-PERFORMANCE-CHECK
Checks how much time the relation handling alone, that is without any
communication, needs on the currently active distributed objects.
@end deffn

@anchor{macro-ddo-ddox}
@deffn Macro DDOX &BODY @var{COMMANDS}
@findex DDOX
Perform the commands serially on the controller
@end deffn

@anchor{fun-ddo-distributed-data}
@deffn Function DISTRIBUTED-DATA 
@findex DISTRIBUTED-DATA
Only for debugging purposes: return all distributed data in a property list
@end deffn

@anchor{fun-ddo-ensure-distributed-class}
@deffn Function ENSURE-DISTRIBUTED-CLASS @var{CLASS} &OPTIONAL (@var{TYPE} @var{OBJECT})
@findex ENSURE-DISTRIBUTED-CLASS
Generates for @arg{class} a distributed object/container variant.
@end deffn

@anchor{fun-ddo-make-distributed-container}
@deffn Function MAKE-DISTRIBUTED-CONTAINER @var{OBJECT} &OPTIONAL @var{DISTRIBUTED-SLOTS}
@findex MAKE-DISTRIBUTED-CONTAINER
Turn the container @arg{object} into a distributed container.
@end deffn

@anchor{fun-ddo-make-distributed-object}
@deffn Function MAKE-DISTRIBUTED-OBJECT @var{OBJECT} @var{PROCESSORS} &OPTIONAL @var{CONTAINER-OR-SLOTS}
@findex MAKE-DISTRIBUTED-OBJECT
Make OBJECT into a distributed object belonging to PROCESSORS.
The change will become active only after the next synchronization!
@end deffn

@anchor{fun-ddo-masterp}
@deffn Function MASTERP @var{OBJECT-OR-LOCAL-ID}
@findex MASTERP
The master of a distributed object is simply as the processor with
minimal rank.  Note that using this function somehow works against the
whole DDO concept, so that its use should be avoided whenever possible.
@end deffn

@anchor{fun-ddo-minimum-id-merger}
@deffn Function MINIMUM-ID-MERGER @var{OBJECT} @var{ID-VALUE-PAIRS}
@findex MINIMUM-ID-MERGER
In principle, this function should look up up the
 minimal id and set all distributed slots accordingly.
@end deffn

@anchor{fun-ddo-neighbors-for}
@deffn Function NEIGHBORS-FOR @var{OBJECT-OR-LOCAL-ID}
@findex NEIGHBORS-FOR
All processors for a distributed object
@end deffn

@anchor{fun-ddo-reset-distributed-objects}
@deffn Function RESET-DISTRIBUTED-OBJECTS 
@findex RESET-DISTRIBUTED-OBJECTS
For testing purposes!  Resets all distributed-object tables.
@end deffn

@anchor{fun-ddo-synchronize}
@deffn Function SYNCHRONIZE &OPTIONAL @var{LABEL} &REST @var{ARGS}
@findex SYNCHRONIZE
Synchronize distributed objects across the MPI kernel.
@end deffn

@node Package DDO-FEMLISP,  , Package DDO, Reference manual
@section Package DDO-FEMLISP

This package contains Femlisp parallelization stuff.

@anchor{fun-ddo-femlisp-aso-make-distributed}
@deffn Function ASO-MAKE-DISTRIBUTED @var{ASO} &KEY @var{CONSISTENT-P} @var{MERGER} (@var{MERGER} (@var{FUNCTION} @var{ADDITION-MERGER})) &ALLOW-OTHER-KEYS
@findex ASO-MAKE-DISTRIBUTED
Turns aso into a distributed aso
@end deffn

