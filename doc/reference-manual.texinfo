@node Reference manual, Copyright, Overview, Top
@chapter Reference manual

@menu
* Package FL.UTILITIES::        
* Package FL.MACROS::           
* Package FL.DEBUG::            
* Package FL.DEMO::             
* Package FL.TESTS::            
* Package FL.PORT::             
* Package FL.AMOP::             
* Package FL.ALIEN::            
* Package FL.MULTIPROCESSING::  
* Package FL.MATLISP::          
* Package FL.ALGEBRA::          
* Package FL.FUNCTION::         
* Package FL.MESH::             
* Package FL.PROBLEM::          
* Package FL.CDR::              
* Package FL.ELLSYS::           
* Package FL.ELASTICITY::       
* Package FL.NAVIER-STOKES::    
* Package FL.CDRSYS::           
* Package FL.DISCRETIZATION::   
* Package FL.CDR-FE::           
* Package FL.ELLSYS-FE::        
* Package FL.ELASTICITY-FE::    
* Package FL.NAVIER-STOKES-FE::  
* Package FL.ITERATION::        
* Package FL.MULTIGRID::        
* Package FL.GEOMG::            
* Package FL.STRATEGY::         
* Package FL.GRAPHIC::          
* Package FL.PLOT::             
* Package FL.DOMAINS::          
* Package FL.APPLICATION::      
@end menu

@node Package FL.UTILITIES, Package FL.MACROS, Reference manual, Reference manual
@section Package FL.UTILITIES

This package contains generally useful utility functions.  Several of
those functions were taken from @cite{(Graham 1996)}, the SANS function was
contributed to the @cite{comp.lang.lisp} newsgroup by Erik Naggum.

@anchor{fun-fl.utilities-array-for-each}
@deffn Function ARRAY-FOR-EACH @var{FUNC} &REST @var{ARRAYS}
@findex ARRAY-FOR-EACH
Calls @arg{func} on all element tuples of the array arguments.
@end deffn

@anchor{fun-fl.utilities-blackboard}
@deffn Function BLACKBOARD &REST @var{ITEMS}
@findex BLACKBOARD
Make the property list supplied in @arg{items} into a blackboard.
Copies @arg{items} to make sure that no literal list is modified.
@end deffn

@anchor{class-fl.utilities-blackboard}
@deftp Class BLACKBOARD
@tindex BLACKBOARD
A blackboard where data items can be put and extracted using the
function @code{GETBB}.

Direct slots:
@itemize
@item ITEMS: A property list of items on the blackboard.
@end itemize
@end deftp

@anchor{fun-fl.utilities-box}
@deffn Function BOX @var{OBJECT}
@findex BOX
Boxes an object.
@end deffn

@anchor{fun-fl.utilities-check-properties}
@deffn Function CHECK-PROPERTIES @var{PLACE} @var{PROPERTIES}
@findex CHECK-PROPERTIES
Checks if all of the @arg{properties} are in the property list
@arg{place}.
@end deffn

@anchor{fun-fl.utilities-common-lisp-speed}
@deffn Function COMMON-LISP-SPEED &KEY (@var{CACHE} 0.5) (@var{MEMORY} 0.5)
@findex COMMON-LISP-SPEED
Returns the speed which should be characteristic for the setting
determined by the keyword arguments.
@end deffn

@anchor{fun-fl.utilities-concept-documentation}
@deffn Function CONCEPT-DOCUMENTATION @var{DOCSTRING}
@findex CONCEPT-DOCUMENTATION
Documents a certain concept.
@end deffn

@anchor{fun-fl.utilities-copy-hash-table}
@deffn Function COPY-HASH-TABLE @var{HASH-TABLE}
@findex COPY-HASH-TABLE
Copy @arg{hash-table}.
@end deffn

@anchor{fun-fl.utilities-curry}
@deffn Function CURRY @var{FUNC} &REST @var{ARGS}
@findex CURRY
Supplies @arg{args} to @arg{func} from the left.
@end deffn

@anchor{fun-fl.utilities-dequeue}
@deffn Function DEQUEUE @var{PQ}
@findex DEQUEUE
Pops an object from @arg{queue}.
@end deffn

@anchor{fun-fl.utilities-dic-ref}
@deffn Function DIC-REF @var{DIC} @var{KEY}
@findex DIC-REF
Returns the value of the entry for @arg{key} in
@arg{dictionary}.
@end deffn

@anchor{fun-fl.utilities-display-ht}
@deffn Function DISPLAY-HT @var{HASH-TABLE}
@findex DISPLAY-HT
Display @arg{hash-table} in the form key1 -> value1 ...
@end deffn

@anchor{macro-fl.utilities-dohash}
@deffn Macro DOHASH (@var{LOOPING-VAR} @var{HASH-TABLE}) &BODY @var{BODY}
@findex DOHASH
Loops through @arg{hash-table}.  If @arg{looping-var} is an atom
@emph{key}, loop through the keys; if it is a list of the form
@emph{(value)} loop through the values; if it is a list of the form
@emph{(key value)} loop through key and value.
@end deffn

@anchor{macro-fl.utilities-dotuple}
@deffn Macro DOTUPLE (@var{INDEX} @var{LIMITS} &OPTIONAL @var{RESULT}) &BODY @var{BODY}
@findex DOTUPLE
Loops through each tuple below @arg{limits}.
@end deffn

@anchor{fun-fl.utilities-enqueue}
@deffn Function ENQUEUE @var{OBJ} @var{PQ}
@findex ENQUEUE
Puts @arg{object} into the @arg{queue}.
@end deffn

@anchor{fun-fl.utilities-factorial}
@deffn Function FACTORIAL @var{N}
@findex FACTORIAL
Compute the factorial of @arg{n}.  @arg{n} can also be a list of
numbers in which case the product of the factorials of the components is
computed.
@end deffn

@anchor{fun-fl.utilities-file-documentation}
@deffn Function FILE-DOCUMENTATION @var{DOCSTRING}
@findex FILE-DOCUMENTATION
If the manual is sorted by file, the string handed to this function
describes the use of the respective file.
@end deffn

@anchor{fun-fl.utilities-fixnum-vec}
@deffn Function FIXNUM-VEC &REST @var{ELEMENTS}
@findex FIXNUM-VEC
Returns a @symbol{FIXNUM-VEC} constructed from the parameters.
@end deffn

@anchor{type-fl.utilities-fixnum-vec}
@deftp Type FIXNUM-VEC
@tindex FIXNUM-VEC
Vector with elements of type @code{fixnum}.
@end deftp

@anchor{fun-fl.utilities-flatten}
@deffn Function FLATTEN @var{TREE}
@findex FLATTEN
Flatten a tree.  Example:
@lisp
  (flatten '((1 2) (3) ((4))))  @result{}  (1 2 3 4)
@end lisp
@end deffn

@anchor{fun-fl.utilities-for-each}
@deffn Function FOR-EACH @var{FUNC} @var{SEQ}
@findex FOR-EACH
Applies @arg{func} to each element of @arg{collection}.
@end deffn

@anchor{fun-fl.utilities-for-each-tuple}
@deffn Function FOR-EACH-TUPLE @var{FUNC} @var{LIMITS}
@findex FOR-EACH-TUPLE
Calls @arg{func} on each tuple greater or equal to (0 ... 0) and below
@arg{dims}.
@end deffn

@anchor{fun-fl.utilities-get-arbitrary-key-from-hash-table}
@deffn Function GET-ARBITRARY-KEY-FROM-HASH-TABLE @var{HASH-TABLE}
@findex GET-ARBITRARY-KEY-FROM-HASH-TABLE
Get an arbitrary key from @arg{hash-table}.
@end deffn

@anchor{fun-fl.utilities-get-property}
@deffn Function GET-PROPERTY @var{OBJECT} @var{PROPERTY}
@findex GET-PROPERTY
Gets @arg{property} for @arg{object}.
@end deffn

@anchor{fun-fl.utilities-geta}
@deffn Function GETA @var{ALIST} @var{KEY}
@findex GETA
An analog to @code{GETF} for association lists.
@end deffn

@anchor{setf-expander-fl.utilities-geta}
@deffn {Setf Expander} GETA
@findex GETA
An analog to @code{(SETF GETF)} for association lists.
@end deffn

@anchor{fun-fl.utilities-getbb}
@deffn Function GETBB @var{BLACKBOARD} @var{KEY} &OPTIONAL @var{DEFAULT}
@findex GETBB
Get the item for @arg{key} from @arg{blackboard}.  If there is no such
@arg{key} return @arg{default}.
@end deffn

@anchor{fun-fl.utilities-hash-table-keys}
@deffn Function HASH-TABLE-KEYS @var{HASH-TABLE}
@findex HASH-TABLE-KEYS
Collect the keys of @arg{hash-table} into a list.
@end deffn

@anchor{fun-fl.utilities-hash-table-values}
@deffn Function HASH-TABLE-VALUES @var{HASH-TABLE}
@findex HASH-TABLE-VALUES
Collect the values of @arg{hash-table} into a list.
@end deffn

@anchor{fun-fl.utilities-identity-permutation-p}
@deffn Function IDENTITY-PERMUTATION-P @var{PERM}
@findex IDENTITY-PERMUTATION-P
Checks if the permutation is the identity.
@end deffn

@anchor{fun-fl.utilities-iterator}
@deffn Function ITERATOR @var{X}
@findex ITERATOR
Returns an iterator for @arg{x}.
@end deffn

@anchor{fun-fl.utilities-iterator-next}
@deffn Function ITERATOR-NEXT @var{RANGE} @var{I}
@findex ITERATOR-NEXT
Returns an incremented @arg{iterator}.
@end deffn

@anchor{fun-fl.utilities-k->l-subsets}
@deffn Function K->L-SUBSETS @var{SET} @var{K} @var{L}
@findex K->L-SUBSETS
Returns all subsets of @arg{set} with length between @arg{k} and
@arg{l}.  Example:
@lisp
  (k->l-subsets '(1 2 3) 1 2) @result{}
  ((1) (2) (3) (1 2) (1 3) (2 3))
@end lisp
@end deffn

@anchor{fun-fl.utilities-k-subsets}
@deffn Function K-SUBSETS @var{SET} @var{K}
@findex K-SUBSETS
Returns all subsets of @arg{set} with length @arg{k}.  Example:
@lisp
  (k-subsets '(1 2 3) 2)
  @result{} ((1 2) (1 3) (2 3))
@end lisp
@end deffn

@anchor{fun-fl.utilities-list->queue}
@deffn Function LIST->QUEUE @var{LIST}
@findex LIST->QUEUE
Transforms @arg{list} to a queue.
@end deffn

@anchor{macro-fl.utilities-loop+}
@deffn Macro LOOP+ @var{ITEMS} &BODY @var{BODY}
@findex LOOP+
Iterates @arg{body} over @arg{items}.  Example:
@lisp
  (let ((x (make-array 10))
	(y (make-list 10 :initial-element 1)))
    (loop+ ((xc x) (yc y) i) doing
       (setf xc (+ i yc))
       finally (return x)))
@end lisp
@end deffn

@anchor{fun-fl.utilities-make-analog}
@deffn Function MAKE-ANALOG @var{PICTURE}
@findex MAKE-ANALOG
Generate an analogous but empty data structure.
@end deffn

@anchor{fun-fl.utilities-make-fixnum-vec}
@deffn Function MAKE-FIXNUM-VEC @var{DIM} &OPTIONAL (@var{INIT} 0)
@findex MAKE-FIXNUM-VEC
Construct a @symbol{FIXNUM-VEC} of size @arg{dim} initialized by
@arg{init}.
@end deffn

@anchor{fun-fl.utilities-map-hash-table}
@deffn Function MAP-HASH-TABLE @var{FUNC} @var{HASH-TABLE}
@findex MAP-HASH-TABLE
Call @arg{func} given in the first argument on each key of
@arg{hash-table}.  @arg{func} must return the new key and the new value as
two values.  Those pairs are stored in a new hash-table.
@end deffn

@anchor{fun-fl.utilities-map-product}
@deffn Function MAP-PRODUCT @var{FUNC} @var{LIST} &REST @var{REST-LISTS}
@findex MAP-PRODUCT
Applies @arg{func} to a product of lists.  Example:
@lisp
  (map-product #'cons '(2 3) '(1 4))
  @result{} ((2 . 1) (2 . 4) (3 . 1) (3 . 4))
@end lisp
@end deffn

@anchor{fun-fl.utilities-map-tree}
@deffn Function MAP-TREE @var{FUNC} @var{TREE}
@findex MAP-TREE
Maps @arg{tree} using @arg{func}.  Example:
@lisp
  (map-tree #'1+ '((1 (2)))) @result{} ((2 (3)))
@end lisp
@end deffn

@anchor{fun-fl.utilities-mappend}
@deffn Function MAPPEND @var{FUNC} &REST @var{LISTS}
@findex MAPPEND
Map @function{func} over @arg{lists} while appending the results.
@end deffn

@anchor{fun-fl.utilities-maximally-connected}
@deffn Function MAXIMALLY-CONNECTED @var{CONNECTED} @var{DISCONNECTED} &KEY (@var{TEST} (@var{FUNCTION} @var{EQL})) (@var{COMBINE} (@var{FUNCTION} @var{ADJOIN}))
@findex MAXIMALLY-CONNECTED
Finds a maximally connected set by taking the union of the elements in
connected with the sets of disconnected-sets.  Returns the maximally
connected sets and the remaining disconnected ones.  Example:

@lisp
  (maximally-connected '(1 2) '((3 4) (2 3) (5 6))
                       :test #'intersection :combine #'union)
  @result{} (1 2 3 4), ((5 6))
@end lisp
@end deffn

@anchor{fun-fl.utilities-memoize-1}
@deffn Function MEMOIZE-1 @var{FUNC} &KEY (@var{TEST} (@var{QUOTE} @var{EQL}))
@findex MEMOIZE-1
Memoizes the function @arg{func} which should be a non-recursive
function of one argument.
@end deffn

@anchor{fun-fl.utilities-memoize-symbol}
@deffn Function MEMOIZE-SYMBOL @var{FUNSYM} &KEY (@var{TEST} (@var{QUOTE} @var{EQUAL}))
@findex MEMOIZE-SYMBOL
Memoizes multi-argument functions named by the symbol @arg{funsym}.
@end deffn

@anchor{macro-fl.utilities-memoizing-let}
@deffn Macro MEMOIZING-LET @var{BINDINGS} &BODY @var{BODY}
@findex MEMOIZING-LET
The @arg{body} is memoized for the keys given as a list of
@arg{bindings}.
@end deffn

@anchor{fun-fl.utilities-mklist}
@deffn Function MKLIST @var{OBJ}
@findex MKLIST
Wraps @arg{obj} in a list, if it is not already a list.
@end deffn

@anchor{fun-fl.utilities-n-partitions-of-k}
@deffn Function N-PARTITIONS-OF-K @var{N} @var{K}
@findex N-PARTITIONS-OF-K
Returns a list of all ordered partitions of @arg{k} into @arg{n} natural
numbers.  Example:
@lisp
  (n-partitions-of-k 2 3)
   @result{} ((0 3) (1 2) (2 1) (3 0))
@end lisp
@end deffn

@anchor{fun-fl.utilities-nonempty-subsets}
@deffn Function NONEMPTY-SUBSETS @var{SET}
@findex NONEMPTY-SUBSETS
Returns a list of all nonempty subsets of @arg{set}.
@end deffn

@anchor{fun-fl.utilities-on-leaves}
@deffn Function ON-LEAVES @var{FUNC} @var{TREE}
@findex ON-LEAVES
Executes @arg{func} on the leaves of @arg{tree}.
@end deffn

@anchor{fun-fl.utilities-partial-sums}
@deffn Function PARTIAL-SUMS @var{SEQ}
@findex PARTIAL-SUMS
Returns a sequence of the same type as @arg{seq} consisting of its
partial sums.
@end deffn

@anchor{fun-fl.utilities-permutation-inverse}
@deffn Function PERMUTATION-INVERSE @var{PERM-VEC}
@findex PERMUTATION-INVERSE
Returns the inverse of the permutation given by @arg{perm-vec}.
@end deffn

@anchor{fun-fl.utilities-permutation-p}
@deffn Function PERMUTATION-P @var{PERM}
@findex PERMUTATION-P
Checks if @arg{perm} is a possible permutation vector.  A permutation pi
is characterized by a vector containing the indices from 0,...,
@function{length}(@arg{perm})-1 in some order.
@end deffn

@anchor{fun-fl.utilities-permutation-signum}
@deffn Function PERMUTATION-SIGNUM @var{PERM}
@findex PERMUTATION-SIGNUM
Returns the sign of @arg{perm}.
@end deffn

@anchor{fun-fl.utilities-permute}
@deffn Function PERMUTE @var{PERM} @var{INDEX}
@findex PERMUTE
Functional version of @function{permute-into}.
@end deffn

@anchor{fun-fl.utilities-permute-into}
@deffn Function PERMUTE-INTO @var{PERM} @var{V} @var{RESULT}
@findex PERMUTE-INTO
A permutation @arg{perm} acts on the vector @arg{v} by permuting it
according to @math{result[i] = v[perm[i]]}.
@end deffn

@anchor{type-fl.utilities-positive-fixnum}
@deftp Type POSITIVE-FIXNUM
@tindex POSITIVE-FIXNUM
Positive fixnum tpye.
@end deftp

@anchor{fun-fl.utilities-positive-n-partitions-of-k}
@deffn Function POSITIVE-N-PARTITIONS-OF-K @var{N} @var{K}
@findex POSITIVE-N-PARTITIONS-OF-K
Returns a list of all positive ordered partitions of @arg{k} into
@arg{n} natural numbers.  Example:
@lisp
  (positive-n-partitions-of-k 2 3)
  @result{} ((1 2) (2 1))
@end lisp
@end deffn

@anchor{fun-fl.utilities-positive-partitions-of-k}
@deffn Function POSITIVE-PARTITIONS-OF-K @var{K}
@findex POSITIVE-PARTITIONS-OF-K
Returns a list of all positive ordered partitions of @arg{k}.
Example:
@lisp
  (positive-partitions-of-k 3) @result{} ((1 2) (2 1))
@end lisp
@end deffn

@anchor{class-fl.utilities-property-mixin}
@deftp Class PROPERTY-MIXIN
@tindex PROPERTY-MIXIN
A mixin which adds a slot of properties to the class.

Direct slots:
@itemize
@item PROPERTIES: A property list which is used to store unstructured information about
this object.
@end itemize
@end deftp

@anchor{fun-fl.utilities-property-set-p}
@deffn Function PROPERTY-SET-P @var{OBJECT} @var{PROPERTY}
@findex PROPERTY-SET-P
Returns T if @arg{property} is found in the object's properties.
@end deffn

@anchor{class-fl.utilities-queue}
@deftp Class QUEUE
@tindex QUEUE
Queue class accessed with @function{enqueue} and
@function{dequeue}.

Direct slots:
@itemize
@item HEAD: NIL
@item TAIL: NIL
@end itemize
@end deftp

@anchor{fun-fl.utilities-queue->list}
@deffn Function QUEUE->LIST @var{QUEUE}
@findex QUEUE->LIST
Transforms @arg{queue} to a list.
@end deffn

@anchor{fun-fl.utilities-range}
@deffn Function RANGE &REST @var{ARGS} &KEY @var{TO} @var{BELOW}
@findex RANGE
Constructor for a range of numbers.
@end deffn

@anchor{class-fl.utilities-range}
@deftp Class RANGE
@tindex RANGE
Range of numbers for iteration.

Direct slots:
@itemize
@item FROM: Start of range, defaults to 0.
@item TO: Inclusive end of range, defaults to infinity.
@item BELOW: Exclusive end of range, defaults to infinity.
@item BY: Step size.
@end itemize
@end deftp

@anchor{fun-fl.utilities-rcurry}
@deffn Function RCURRY @var{FUNC} &REST @var{ARGS}
@findex RCURRY
Supplies @arg{args} to @arg{func} from the right.
@end deffn

@anchor{fun-fl.utilities-reference}
@deffn Function REFERENCE @var{RANGE} @var{I}
@findex REFERENCE
Reader for the element of @arg{vec} referenced by @arg{iterator}.
@end deffn

@anchor{fun-fl.utilities-required-argument}
@deffn Function REQUIRED-ARGUMENT 
@findex REQUIRED-ARGUMENT
Calling this function results in an error.  Such a call may be used as
default form when an argument should be supplied.
@end deffn

@anchor{fun-fl.utilities-runtime-compile}
@deffn Function RUNTIME-COMPILE @var{SOURCE}
@findex RUNTIME-COMPILE
Calls compile on the provided @arg{source}.  When :compile is activated
for debugging, the source code is printed.
@end deffn

@anchor{fun-fl.utilities-same-p}
@deffn Function SAME-P @var{SEQUENCE} &KEY (@var{TEST} (@var{FUNCTION} @var{EQL})) (@var{KEY} (@var{FUNCTION} @var{IDENTITY}))
@findex SAME-P
Returns t if @arg{sequence} consists of equal elements.
@end deffn

@anchor{fun-fl.utilities-sans}
@deffn Function SANS @var{PLIST} &REST @var{KEYS}
@findex SANS
Removes the items marked by @arg{keys} from the property list
@arg{plist}.  This function was posted at 2.12.2002 to the
@emph{comp.lang.lisp} newsgroup by Erik Naggum.
@end deffn

@anchor{fun-fl.utilities-set-p}
@deffn Function SET-P @var{LIST}
@findex SET-P
Checks if @arg{list} is a set, i.e. if no members occur twice.
@end deffn

@anchor{fun-fl.utilities-splice}
@deffn Function SPLICE @var{ITEMS} @var{LENGTHS}
@findex SPLICE
Breaks the list @arg{items} in pieces of lengths determined by
@arg{nrins}.  Example:
@lisp
  (splice '(1 2 3 4) '(1 3)) @result{} ((1) (2 3 4))
@end lisp
@end deffn

@anchor{fun-fl.utilities-square}
@deffn Function SQUARE @var{X}
@findex SQUARE
Return the square of @arg{x}.
@end deffn

@anchor{fun-fl.utilities-subsets}
@deffn Function SUBSETS @var{SET}
@findex SUBSETS
Returns a list of all subsets of @arg{set}.
@end deffn

@anchor{fun-fl.utilities-transfer-bb}
@deffn Function TRANSFER-BB @var{FROM-BB} @var{TO-BB} @var{ITEMS} &KEY @var{ENSURE}
@findex TRANSFER-BB
Transfer @arg{items} between the blackboards @arg{from-bb} and
@arg{to-bb}.  When @arg{ensure} is set, an existing item is not modified.
@end deffn

@anchor{fun-fl.utilities-unbox}
@deffn Function UNBOX @var{BOX}
@findex UNBOX
Getter for a boxed object.
@end deffn

@anchor{fun-fl.utilities-vector-last}
@deffn Function VECTOR-LAST @var{VEC}
@findex VECTOR-LAST
Returns the last element of @arg{vec}.
@end deffn

@anchor{fun-fl.utilities-vector-map}
@deffn Function VECTOR-MAP @var{FUNC} &REST @var{VECS}
@findex VECTOR-MAP
Map @arg{vec} with @arg{func} to a vector of the same type.
@end deffn

@anchor{macro-fl.utilities-with-items}
@deffn Macro WITH-ITEMS @var{PROPERTIES} @var{BLACKBOARD-FORM} &BODY @var{BODY}
@findex WITH-ITEMS
Work with the items on @arg{blackboard} corresponding to
@arg{properties}.  If some property is a list, the second element is the
default value and the third is an alias to be used to refer to this
parameter.  Example:
@lisp
  (with-items (&key sol (rhs nil rhs-high)) blackboard
     (setq sol rhs-high))
@end lisp
@end deffn

@anchor{macro-fl.utilities-with-memoization}
@deffn Macro WITH-MEMOIZATION (&KEY (@var{TYPE} @var{GLOBAL}) @var{SIZE} @var{ID} (@var{DEBUG} @var{T}) (@var{TEST} (@var{QUOTE} (@var{QUOTE} @var{EQUAL})))) &BODY @var{BODY}
@findex WITH-MEMOIZATION
Sets up a memoization environment consisting of a table, and a captured
symbol @symbol{memoizing-let} memoizing its body depending on the
arguments.  Example of usage:
@lisp
  (with-memoization (:type :local :id 'test)
    (defun test (n)
      (memoizing-let ((k (* 2 n)))
	(sleep 1)
	(* k k))))
@end lisp
If @arg{type} is :global, the table is thread-safe and the same for all
threads, if @arg{type} is :local, it is special for each thread.
@end deffn

@anchor{macro-fl.utilities-with-properties}
@deffn Macro WITH-PROPERTIES @var{PROPERTIES} @var{OBJECT} &BODY @var{BODY}
@findex WITH-PROPERTIES
Work with @arg{properties} on the property list of @arg{object}.
@end deffn

@anchor{fun-fl.utilities-zero-vector}
@deffn Function ZERO-VECTOR @var{DIM} @var{ELEMENT-TYPE}
@findex ZERO-VECTOR
Returns a uniform vector for the given element type filled with zeros.
@end deffn

@node Package FL.MACROS, Package FL.DEBUG, Package FL.UTILITIES, Reference manual
@section Package FL.MACROS

This package contains some basic macro definitions used in Femlisp.

@anchor{macro-fl.macros-?1}
@deffn Macro ?1 &REST @var{ARGS}
@findex ?1
A macro returning the first of its arguments.
@end deffn

@anchor{macro-fl.macros-?2}
@deffn Macro ?2 &REST @var{ARGS}
@findex ?2
A macro returning the second of its arguments.
@end deffn

@anchor{macro-fl.macros-?3}
@deffn Macro ?3 &REST @var{ARGS}
@findex ?3
A macro returning the third of its arguments.
@end deffn

@anchor{macro-fl.macros-aand}
@deffn Macro AAND &REST @var{ARGS}
@findex AAND
Anaphoric macro from @cite{(Graham 1993)}.
@end deffn

@anchor{macro-fl.macros-acond}
@deffn Macro ACOND &REST @var{CLAUSES}
@findex ACOND
Anaphoric macro from @cite{(Graham 1993)}.
@end deffn

@anchor{macro-fl.macros-awhen}
@deffn Macro AWHEN @var{TEST-FORM} &BODY @var{BODY}
@findex AWHEN
Anaphoric macro from @cite{(Graham 1993)}.
@end deffn

@anchor{macro-fl.macros-definline}
@deffn Macro DEFINLINE @var{NAME} &REST @var{REST}
@findex DEFINLINE
Short form for defining an inlined function.  It should probably be
deprecated, because it won't be recognized by default by editors.
@end deffn

@anchor{macro-fl.macros-delay}
@deffn Macro DELAY @var{FORM}
@findex DELAY
Delays the evaluation of @arg{form}.
@end deffn

@anchor{macro-fl.macros-ensure}
@deffn Macro ENSURE @var{G137} &REST @var{ARGS} &ENVIRONMENT @var{G136}
@findex ENSURE
Ensures that some place is set.  It expands as follows:
@lisp
  (ensure place value) @expansion{} (or place (setf place value))
@end lisp
It is not clear if the implementation used here works everywhere.  If not,
the workaround below the macro definition should be used.
@end deffn

@anchor{macro-fl.macros-fluid-let}
@deffn Macro FLUID-LET @var{BINDINGS} &BODY @var{BODY}
@findex FLUID-LET
Sets temporary bindings.
@end deffn

@anchor{macro-fl.macros-for}
@deffn Macro FOR (@var{VAR} @var{START} @var{END}) &BODY @var{BODY}
@findex FOR
Loops for @arg{var} from @arg{start} upto @arg{end}.
@end deffn

@anchor{macro-fl.macros-for<}
@deffn Macro FOR< (@var{VAR} @var{START} @var{END}) &BODY @var{BODY}
@findex FOR<
Loops for @arg{var} from @arg{start} below @arg{end}.
@end deffn

@anchor{macro-fl.macros-force}
@deffn Macro FORCE @var{DELAYED-FORM}
@findex FORCE
Forces the value of a @arg{delayed-form}.
@end deffn

@anchor{macro-fl.macros-multi-for}
@deffn Macro MULTI-FOR (@var{VAR} @var{START} @var{STOP}) &BODY @var{BODY}
@findex MULTI-FOR
Loops for @arg{var} being an integer vector starting from @arg{start}
upto @arg{end}.  Example:
@lisp
  (multi-for (x #(1 1) #(3 3)) (princ x) (terpri))
@end lisp
@end deffn

@anchor{macro-fl.macros-remove-this-method}
@deffn Macro REMOVE-THIS-METHOD @var{GF-NAME} &REST @var{REST}
@findex REMOVE-THIS-METHOD
Removes the method for the generic function @arg{gf-name} which is
specified by @arg{qualifiers} and @arg{specializers}.  Example:
@lisp
  (remove-this-method m* :before ((mat <matrix>) (x <vector>)))
@end lisp
It should be possible to use this directly on a copied first line of a
DEFMETHOD definition.
@end deffn

@anchor{macro-fl.macros-show-call}
@deffn Macro SHOW-CALL @var{FUNC} &OPTIONAL @var{NAME}
@findex SHOW-CALL
Wraps a function object inside a trace form.
@end deffn

@anchor{fun-fl.macros-symconc}
@deffn Function SYMCONC &REST @var{ARGS}
@findex SYMCONC
This function builds a symbol from its arguments and interns it.  This
is used in some macros.
@end deffn

@anchor{macro-fl.macros-whereas}
@deffn Macro WHEREAS @var{CLAUSES} &REST @var{BODY}
@findex WHEREAS
Own implementation of the macro @function{whereas} suggested by Erik
Naggum (c.l.l., 4.12.2002).
@end deffn

@anchor{macro-fl.macros-with-gensyms}
@deffn Macro WITH-GENSYMS @var{SYMS} &BODY @var{BODY}
@findex WITH-GENSYMS
Standard macro providing the freshly generated symbols @arg{syms} to the
code in @arg{body}.
@end deffn

@anchor{macro-fl.macros-_f}
@deffn Macro _F @var{OP} @var{PLACE} &REST @var{ARGS}
@findex _F
Macro from @cite{(Graham 1993)}.  Turns the operator @arg{op} into a
modifying form, e.g. @code{(_f + a b) @equiv{} (incf a b)}.
@end deffn

@node Package FL.DEBUG, Package FL.DEMO, Package FL.MACROS, Reference manual
@section Package FL.DEBUG

This package adds debugging tools to Femlisp.  This is a
slightly modified version of the debugging suite proposed in @cite{(Norvig
1992)}.

@anchor{fun-fl.debug-dbg}
@deffn Function DBG @var{ID} @var{FORMAT-STRING} &REST @var{ARGS}
@findex DBG
When debugging on @arg{id} print out the arguments @arg{args} using the
format in @arg{format-string}.
@end deffn

@anchor{fun-fl.debug-dbg-indent}
@deffn Function DBG-INDENT @var{ID} @var{INDENT} @var{FORMAT-STRING} &REST @var{ARGS}
@findex DBG-INDENT
When debugging @arg{id}, print out the arguments @arg{args} using the
format in @arg{format-string} with indentation given by @arg{indent}.
@end deffn

@anchor{fun-fl.debug-dbg-off}
@deffn Function DBG-OFF &REST @var{IDS}
@findex DBG-OFF
Stop debugging on the passed symbols.  With no arguments, stop debugging
altogether.
@end deffn

@anchor{fun-fl.debug-dbg-on}
@deffn Function DBG-ON &REST @var{IDS}
@findex DBG-ON
Register ids for dbg.
@end deffn

@anchor{fun-fl.debug-dbg-p}
@deffn Function DBG-P @var{ID}
@findex DBG-P
Returns T if @arg{id} is in the debug list, NIL otherwise.
@end deffn

@anchor{macro-fl.debug-dbg-when}
@deffn Macro DBG-WHEN @var{ID} &BODY @var{BODY}
@findex DBG-WHEN
Perform a check only if debugging @arg{id}.
@end deffn

@node Package FL.DEMO, Package FL.TESTS, Package FL.DEBUG, Reference manual
@section Package FL.DEMO

This package provides routines for building a
demo suite.  Wherever something interesting can be demonstrated,
a small demo node should be generated with the
@function{make-demo} and added to the tree of all demos with
@function{adjoin-demo}.  After loading @femlisp{}, the whole
demo suite is available and can be run with the command
@function{femlisp-demo}.

@anchor{var-fl.demo-*demo-time*}
@defvr Variable *DEMO-TIME*
@vindex *DEMO-TIME*
Suggested time for a demo which should be used as a
termination criterion in demo iterations.
@end defvr

@anchor{fun-fl.demo-adjoin-demo}
@deffn Function ADJOIN-DEMO @var{DEMO} @var{PARENT}
@findex ADJOIN-DEMO
Adjoins the demo @arg{demo} to @arg{parent}.
@end deffn

@anchor{fun-fl.demo-extract-demo-strings}
@deffn Function EXTRACT-DEMO-STRINGS @var{STRING} &OPTIONAL @var{TRANSLATIONS}
@findex EXTRACT-DEMO-STRINGS
Extract demo information from the documentation string of the
generating function.
@end deffn

@anchor{fun-fl.demo-femlisp-demo}
@deffn Function FEMLISP-DEMO &OPTIONAL (@var{DEMO} @var{*DEMO-ROOT*})
@findex FEMLISP-DEMO
Shows all demos below the given demo root.
@end deffn

@anchor{fun-fl.demo-remove-demo}
@deffn Function REMOVE-DEMO @var{DEMO} @var{PARENT}
@findex REMOVE-DEMO
Remove @arg{demo} from @arg{parent}.
@end deffn

@anchor{fun-fl.demo-test-all-demos}
@deffn Function TEST-ALL-DEMOS &OPTIONAL (@var{DEMO} @var{*DEMO-ROOT*})
@findex TEST-ALL-DEMOS
Performs all demos reachable from @arg{demo}.
@end deffn

@anchor{fun-fl.demo-user-input}
@deffn Function USER-INPUT @var{PROMPT} &OPTIONAL (@var{CONVERTER} (@var{FUNCTION} @var{IDENTITY})) (@var{TEST-P} (@var{CONSTANTLY} @var{T}))
@findex USER-INPUT
User input for demo functions.  Reads lines until
@arg{test-p} returns t on the item read.
@end deffn

@node Package FL.TESTS, Package FL.PORT, Package FL.DEMO, Reference manual
@section Package FL.TESTS

This package provides routines for building a simple
regression test suite.  Most files in @femlisp{} contain a test function at
the end which checks several critical features which the file or module
provides.  By calling the function @function{adjoin-test} at load time,
this function is added to a list of functions to be checked.  After loading
@femlisp{}, all functions in this list can be executed one after the other
by calling the function @function{test-femlisp}.  Errors and exceptions are
registered and finally reported.  It is very much recommended to run this
test suite before a release.

@anchor{fun-fl.tests-adjoin-test}
@deffn Function ADJOIN-TEST @var{FSYM}
@findex ADJOIN-TEST
Adjoins a test to the Femlisp test suite.
@end deffn

@anchor{fun-fl.tests-remove-test}
@deffn Function REMOVE-TEST @var{FSYM}
@findex REMOVE-TEST
Adjoins a test to the Femlisp test suite.
@end deffn

@anchor{fun-fl.tests-test-femlisp}
@deffn Function TEST-FEMLISP &KEY @var{CONTINUE} @var{PACKAGE} (@var{LOGFILE} @path{fltest}) (@var{DEMO} @var{T})
@findex TEST-FEMLISP
Runs the Femlisp test suite.  The result is printed to
*standard-output*.
@end deffn

@node Package FL.PORT, Package FL.AMOP, Package FL.TESTS, Reference manual
@section Package FL.PORT

This package should contain the implementation-dependent
parts of Femlisp with the exception of the MOP.  It serves a similar
purpose as the PORT module in CLOCC and is somewhat inspired by this
module.  It will be dropped when there is a portable and easily installable
alternative in all CL implementations we are interested in

@anchor{macro-fl.port-def-function}
@deffn Macro DEF-FUNCTION &REST @var{ARGS}
@findex DEF-FUNCTION
Defines a foreign function.  See examples in
@path{alien;src;superlu.lisp}.
@end deffn

@anchor{fun-fl.port-finalize}
@deffn Function FINALIZE @var{OBJ} @var{FUNC}
@findex FINALIZE
Sets up @arg{func} as finalizer for @arg{obj}.
@end deffn

@anchor{fun-fl.port-find-executable}
@deffn Function FIND-EXECUTABLE @var{NAME}
@findex FIND-EXECUTABLE
Finds an executable in the current path.
@end deffn

@anchor{macro-fl.port-foreign-call-wrapper}
@deffn Macro FOREIGN-CALL-WRAPPER &REST @var{BODY}
@findex FOREIGN-CALL-WRAPPER
Ensures a safe environment for a foreign function call, especially so
that no GC changes array pointers obtained by @function{vector-sap}.
@end deffn

@anchor{fun-fl.port-getenv}
@deffn Function GETENV @var{VAR}
@findex GETENV
Return the value of the environment variable.
@end deffn

@anchor{fun-fl.port-load-foreign-library}
@deffn Function LOAD-FOREIGN-LIBRARY @var{FILE}
@findex LOAD-FOREIGN-LIBRARY
Loads the foreign library @arg{file}.
@end deffn

@anchor{fun-fl.port-make-weak-pointer}
@deffn Function MAKE-WEAK-POINTER @var{OBJ}
@findex MAKE-WEAK-POINTER
Creates a weak pointer pointing to @arg{obj}.
@end deffn

@anchor{fun-fl.port-process-close}
@deffn Function PROCESS-CLOSE @var{PROCESS}
@findex PROCESS-CLOSE
Closes @arg{process}.
@end deffn

@anchor{fun-fl.port-process-input}
@deffn Function PROCESS-INPUT @var{PROCESS}
@findex PROCESS-INPUT
Process-input for @arg{process}.
@end deffn

@anchor{fun-fl.port-process-output}
@deffn Function PROCESS-OUTPUT @var{PROCESS}
@findex PROCESS-OUTPUT
Process-output for @arg{process}.
@end deffn

@anchor{fun-fl.port-process-status}
@deffn Function PROCESS-STATUS @var{PROCESS}
@findex PROCESS-STATUS
Returns the status of @arg{process}.
@end deffn

@anchor{fun-fl.port-run-program}
@deffn Function RUN-PROGRAM @var{PROGRAM} @var{ARGS} &KEY @var{WAIT} @var{INPUT} @var{OUTPUT} @var{ERROR-OUTPUT} @var{DIRECTORY}
@findex RUN-PROGRAM
Runs @arg{program} with arguments @arg{args}.
@end deffn

@anchor{fun-fl.port-save-femlisp-core-and-die}
@deffn Function SAVE-FEMLISP-CORE-AND-DIE @var{CORE-FILE-NAME}
@findex SAVE-FEMLISP-CORE-AND-DIE
Saves Femlisp core and quits.
@end deffn

@anchor{fun-fl.port-unix-chdir}
@deffn Function UNIX-CHDIR @var{PATH}
@findex UNIX-CHDIR
Change the directory to @arg{path}.
@end deffn

@anchor{fun-fl.port-vector-sap}
@deffn Function VECTOR-SAP @var{PTR}
@findex VECTOR-SAP
Returns an array pointer which can be used in a foreign call.
@end deffn

@anchor{fun-fl.port-weak-pointer-value}
@deffn Function WEAK-POINTER-VALUE @var{WP}
@findex WEAK-POINTER-VALUE
Returns the value of the weak pointer @arg{wp}.
@end deffn

@node Package FL.AMOP, Package FL.ALIEN, Package FL.PORT, Reference manual
@section Package FL.AMOP

This package provides some MOP functionality.  These functions are
non-ANSI and may represent a problem when porting Femlisp.

@anchor{fun-fl.amop-compile-and-eval}
@deffn Function COMPILE-AND-EVAL @var{SOURCE}
@findex COMPILE-AND-EVAL
Compiles and evaluates the given @arg{source}.  This should be an ANSI
compatible way of ensuring method compilation.
@end deffn

@anchor{fun-fl.amop-find-programmatic-class}
@deffn Function FIND-PROGRAMMATIC-CLASS @var{SUPERCLASSES} &OPTIONAL @var{NAME}
@findex FIND-PROGRAMMATIC-CLASS
Finds and, if necessary, generates a class from the given superclasses.
@end deffn

@anchor{fun-fl.amop-make-programmatic-instance}
@deffn Function MAKE-PROGRAMMATIC-INSTANCE @var{SUPERCLASS-ES} &REST @var{INITARGS}
@findex MAKE-PROGRAMMATIC-INSTANCE
Makes an instance of a class denoted by a list of the names of its
superclasses.  This class is generated automatically, if necessary.
@end deffn

@anchor{fun-fl.amop-remove-subclass-methods}
@deffn Function REMOVE-SUBCLASS-METHODS @var{GF} @var{TEMPLATE-ARGS}
@findex REMOVE-SUBCLASS-METHODS
Removes all methods dispatching on subclasses of the template
arguments.
@end deffn

@node Package FL.ALIEN, Package FL.MULTIPROCESSING, Package FL.AMOP, Reference manual
@section Package FL.ALIEN

This package loads some foreign libraries and does set
up a Lisp interface for it.

@node Package FL.MULTIPROCESSING, Package FL.MATLISP, Package FL.ALIEN, Reference manual
@section Package FL.MULTIPROCESSING

This package provides an interface for allowing parallel execution in
Femlisp.  It abstracts also from the underlying Lisp's threading features.
Unfortunately, these features somewhat differ (e.g. the waitqueue concept
in SBCL and gates in Allegro), although one can usually achieve the same
effects.

@anchor{var-fl.multiprocessing-*thread-local-memoization-table*}
@defvr Variable *THREAD-LOCAL-MEMOIZATION-TABLE*
@vindex *THREAD-LOCAL-MEMOIZATION-TABLE*
Dynamic variable specialized for each worker thread separately.  Should
not be used globally.
@end defvr

@anchor{var-fl.multiprocessing-*threads*}
@defvr Variable *THREADS*
@vindex *THREADS*
The number of threads in which Femlisp tries to split the work for some
computationally intensive tasks.  If NIL, no threading is used.
@end defvr

@anchor{fun-fl.multiprocessing-condition-notify}
@deffn Function CONDITION-NOTIFY @var{WAITQUEUE}
@findex CONDITION-NOTIFY
Notifies on the waitqueue.
@end deffn

@anchor{fun-fl.multiprocessing-condition-wait}
@deffn Function CONDITION-WAIT @var{WAITQUEUE} @var{MUTEX}
@findex CONDITION-WAIT
Registers on the waitqueue, releases mutex, and waits for a notification
on the waitqueue.
@end deffn

@anchor{fun-fl.multiprocessing-make-thread}
@deffn Function MAKE-THREAD @var{FUNC} &KEY @var{NAME} @var{INITIAL-BINDINGS}
@findex MAKE-THREAD
Execute @arg{func} as a thread with name @arg{name} within dynamic
bindings given by @arg{initial-bindings}.
@end deffn

@anchor{fun-fl.multiprocessing-make-waitqueue}
@deffn Function MAKE-WAITQUEUE 
@findex MAKE-WAITQUEUE
Generates a waitqueue.
@end deffn

@anchor{class-fl.multiprocessing-mutex-mixin}
@deftp Class MUTEX-MIXIN
@tindex MUTEX-MIXIN
A mixin which adds a mutex to every instance of the
class.

Direct slots:
@itemize
@item MUTEX: A mutex for excluding access of other threads.
@end itemize
@end deftp

@anchor{class-fl.multiprocessing-parqueue}
@deftp Class PARQUEUE
@tindex PARQUEUE
A thread-safe queue waiting for input.

Superclasses: QUEUE WAITQUEUE-MIXIN

Direct slots:
@itemize
@item FINISHED-P: Indicator for end-of-input.
@end itemize
@end deftp

@anchor{macro-fl.multiprocessing-with-mutual-exclusion}
@deffn Macro WITH-MUTUAL-EXCLUSION (@var{OBJ}) &BODY @var{BODY}
@findex WITH-MUTUAL-EXCLUSION
Execute @arg{body} on the waitqueue @arg{obj} without other threads
interfering.
@end deffn

@anchor{macro-fl.multiprocessing-with-workers}
@deffn Macro WITH-WORKERS (@var{FUNC}) &BODY @var{BODY}
@findex WITH-WORKERS
This macro distributes work generated in body with calling the locally
bound function @function{work-on} on some arguments to several working
threads which call @arg{func} on those arguments.
@end deffn

@node Package FL.MATLISP, Package FL.ALGEBRA, Package FL.MULTIPROCESSING, Reference manual
@section Package FL.MATLISP

This package provides a Common Lisp version of full
matrices with elements being numbers of a given type.  Those classes are
automatically generated when needed.  It provides also part of the BLAS and
LAPACK operations for those matrices.  The corresponding methods are
automatically compiled for the given matrix classes.  The interface is very
similar to the library Matlisp @cite{(Matlisp)}, which provides a CLOS
interface to the Fortran BLAS and LAPACK routines.

@anchor{var-fl.matlisp-*print-matrix*}
@defvr Variable *PRINT-MATRIX*
@vindex *PRINT-MATRIX*
Maximum number of columns and/or rows to print. NIL: no elements, T: all
elements.
@end defvr

@anchor{var-fl.matlisp-*print-tensor*}
@defvr Variable *PRINT-TENSOR*
@vindex *PRINT-TENSOR*
Maximum number of columns and/or rows to print.  Set this to NIL to
  print no cells (same as *PRINT-ARRAY* set to NIL).  Set this to T
  to print all cells of the tensor.
@end defvr

@anchor{class-fl.matlisp-<matrix>}
@deftp Class <MATRIX>
@tindex <MATRIX>
General matrix class.

Superclasses: <VECTOR>
@end deftp

@anchor{class-fl.matlisp-<submatrix>}
@deftp Class <SUBMATRIX>
@tindex <SUBMATRIX>
Describes an ordered submatrix of a matrix.  Only a
restricted set of operations is allowed for these matrices and element
access is slow.  They are indexed with ordinary integers.

Superclasses: <MATRIX>

Direct slots:
@itemize
@item MATRIX: The "supermatrix".
@item ROW-KEYS: The row indices of the submatrix.
@item COL-KEYS: The column indices of the submatrix.
@end itemize
@end deftp

@anchor{class-fl.matlisp-<vector>}
@deftp Class <VECTOR>
@tindex <VECTOR>
General vector class.
@end deftp

@anchor{fun-fl.matlisp-area-of-span}
@deffn Function AREA-OF-SPAN @var{MAT}
@findex AREA-OF-SPAN
Computes the volume spanned by the columns of @arg{mat}.
@end deffn

@anchor{fun-fl.matlisp-axpy}
@deffn Function AXPY @var{ALPHA} @var{X} @var{Y}
@findex AXPY
Returns alpha X + Y.  Uses AXPY! and COPY.
@end deffn

@anchor{fun-fl.matlisp-axpy!}
@deffn Function AXPY! @var{ALPHA} @var{X} @var{Y}
@findex AXPY!
Y <- alpha*X + Y
@end deffn

@anchor{fun-fl.matlisp-ccs-matrix}
@deffn Function CCS-MATRIX @var{TYPE}
@findex CCS-MATRIX
Construct a CCS matrix with entries of @arg{type}.
@end deffn

@anchor{class-fl.matlisp-ccs-matrix}
@deftp Class CCS-MATRIX
@tindex CCS-MATRIX
A CCS (compressed column storage) matrix.  This is an
abstract class which is made concrete by mixing it with a store-vector.

Superclasses: <MATRIX>

Direct slots:
@itemize
@item PATTERN: CCS pattern.
@end itemize
@end deftp

@anchor{class-fl.matlisp-ccs-pattern}
@deftp Class CCS-PATTERN
@tindex CCS-PATTERN
A CCS (compressed column storage) pattern.  Note: if you
use integer vectors for @slot{column-starts} and @slot{row-indices} they do
not have to be copied for a call to the alien sparse solvers.

Direct slots:
@itemize
@item NROWS: Number of rows in the pattern.
@item NCOLS: Number of columns in the pattern.
@item COLUMN-STARTS: Vector with start indices of columns.
@item ROW-INDICES: Vector with row indices.
@end itemize
@end deftp

@anchor{fun-fl.matlisp-copy}
@deffn Function COPY @var{POLY}
@findex COPY
Returns a deep copy of X.
@end deffn

@anchor{fun-fl.matlisp-copy!}
@deffn Function COPY! @var{X} @var{Y}
@findex COPY!
Y <- X
@end deffn

@anchor{fun-fl.matlisp-det}
@deffn Function DET @var{MAT}
@findex DET
Returns the determinant of the square matrix @arg{mat}.
@end deffn

@anchor{fun-fl.matlisp-det-from-lr}
@deffn Function DET-FROM-LR @var{LR} @var{PIVOT}
@findex DET-FROM-LR
This routine computes the determinant using a given LR decomposition.
@end deffn

@anchor{fun-fl.matlisp-dot}
@deffn Function DOT @var{X} @var{Y}
@findex DOT
Returns the dot product of X and Y.
@end deffn

@anchor{fun-fl.matlisp-dot-abs}
@deffn Function DOT-ABS @var{X} @var{Y}
@findex DOT-ABS
Returns the dot product between |X| and |Y|.
@end deffn

@anchor{macro-fl.matlisp-dotensor}
@deffn Macro DOTENSOR (@var{ARGS} @var{TENSOR} &KEY @var{DEPTH}) &BODY @var{BODY}
@findex DOTENSOR
Usage:
(dotensor (entry tensor :depth 1) ...)
(dotensor ((index1 ... . entry) tensor :depth 1) ...)
(dotensor ((index1 ...) tensor :depth 1) ...)
@end deffn

@anchor{fun-fl.matlisp-double-vec}
@deffn Function DOUBLE-VEC &REST @var{COMPS}
@findex DOUBLE-VEC
Returns a @class{double-vec} with the entries in @arg{comps}.
@end deffn

@anchor{type-fl.matlisp-double-vec}
@deftp Type DOUBLE-VEC
@tindex DOUBLE-VEC
Uniform @type{double-float} vector.
@end deftp

@anchor{macro-fl.matlisp-dovec}
@deffn Macro DOVEC (@var{LOOP-VARS} @var{VEC}) &BODY @var{BODY}
@findex DOVEC
Loops on indices and entries of a vector.  Examples:
@lisp
  (dovec ((key) vec) ...)
  (dovec (entry vec) ...)
  (dovec ((key entry) vec) ...)
@end lisp
@end deffn

@anchor{fun-fl.matlisp-element-type}
@deffn Function ELEMENT-TYPE @var{VECTOR}
@findex ELEMENT-TYPE
Type of the elements of the vector/matrix.
@end deffn

@anchor{fun-fl.matlisp-extend-matlisp-function}
@deffn Function EXTEND-MATLISP-FUNCTION @var{FUNC}
@findex EXTEND-MATLISP-FUNCTION
If @package{MATLISP} is available, and the argument @arg{func} is a
generic function in this package, this function is extended to be
applicable to matrices in @arg{FL.MATLISP}.  This is done by defining a
method for @function{no-applicable-method} which converts the arguments,
calls @arg{func} and reconverts the returned values.  If @package{MATLISP}
is not available, NIL is returned.
@end deffn

@anchor{fun-fl.matlisp-fill!}
@deffn Function FILL! @var{X} @var{S}
@findex FILL!
Fills X with element s.
@end deffn

@anchor{fun-fl.matlisp-fill-random!}
@deffn Function FILL-RANDOM! @var{X} @var{S}
@findex FILL-RANDOM!
Fills X with random values (obtained by (random s)).
@end deffn

@anchor{fun-fl.matlisp-for-each-col-key}
@deffn Function FOR-EACH-COL-KEY @var{FN} @var{SMAT}
@findex FOR-EACH-COL-KEY
Loop through column keys.
@end deffn

@anchor{fun-fl.matlisp-for-each-entry}
@deffn Function FOR-EACH-ENTRY @var{FN} @var{SMAT}
@findex FOR-EACH-ENTRY
Calls @arg{func} on all entries of @arg{vec}.
@end deffn

@anchor{fun-fl.matlisp-for-each-entry-in-col}
@deffn Function FOR-EACH-ENTRY-IN-COL @var{FN} @var{SMAT} @var{KEY}
@findex FOR-EACH-ENTRY-IN-COL
Loop through entries in column col.
@end deffn

@anchor{fun-fl.matlisp-for-each-entry-in-row}
@deffn Function FOR-EACH-ENTRY-IN-ROW @var{FN} @var{SMAT} @var{KEY}
@findex FOR-EACH-ENTRY-IN-ROW
Loop through col-keys in row.
@end deffn

@anchor{fun-fl.matlisp-for-each-key}
@deffn Function FOR-EACH-KEY @var{FN} @var{SMAT}
@findex FOR-EACH-KEY
Calls @arg{func} on all indices/keys of @arg{vec}.
@end deffn

@anchor{fun-fl.matlisp-for-each-key-and-entry}
@deffn Function FOR-EACH-KEY-AND-ENTRY @var{FN} @var{SMAT}
@findex FOR-EACH-KEY-AND-ENTRY
Calls @arg{func} on all keys and associated entries of
@arg{vec}.
@end deffn

@anchor{fun-fl.matlisp-for-each-key-and-entry-in-col}
@deffn Function FOR-EACH-KEY-AND-ENTRY-IN-COL @var{FN} @var{SMAT} @var{KEY}
@findex FOR-EACH-KEY-AND-ENTRY-IN-COL
Loop through row-keys and entries in col.
@end deffn

@anchor{fun-fl.matlisp-for-each-key-and-entry-in-row}
@deffn Function FOR-EACH-KEY-AND-ENTRY-IN-ROW @var{FN} @var{SMAT} @var{KEY}
@findex FOR-EACH-KEY-AND-ENTRY-IN-ROW
Loop through col-keys and entries in row.
@end deffn

@anchor{fun-fl.matlisp-for-each-key-in-col}
@deffn Function FOR-EACH-KEY-IN-COL @var{FN} @var{SMAT} @var{KEY}
@findex FOR-EACH-KEY-IN-COL
Loop through row-keys in column col.
@end deffn

@anchor{fun-fl.matlisp-for-each-key-in-row}
@deffn Function FOR-EACH-KEY-IN-ROW @var{FN} @var{SMAT} @var{KEY}
@findex FOR-EACH-KEY-IN-ROW
Loop through col-keys in row.
@end deffn

@anchor{fun-fl.matlisp-for-each-row-key}
@deffn Function FOR-EACH-ROW-KEY @var{FN} @var{SMAT}
@findex FOR-EACH-ROW-KEY
Loop through row keys.
@end deffn

@anchor{fun-fl.matlisp-full-ccs-pattern}
@deffn Function FULL-CCS-PATTERN @var{NROWS} @var{NCOLS}
@findex FULL-CCS-PATTERN
Returns trivial rectangular ccs-patterns.
@end deffn

@anchor{fun-fl.matlisp-full-tensor}
@deffn Function FULL-TENSOR @var{TYPE}
@findex FULL-TENSOR
Construct a full tensor with entries of @arg{type}.
@end deffn

@anchor{class-fl.matlisp-full-tensor}
@deftp Class FULL-TENSOR
@tindex FULL-TENSOR
Mixin for full tensors.

Direct slots:
@itemize
@item DIMENSIONS: The dimensions of the tensor.
@item OFFSET0: An initial offset into the store-vector which
defaults to 0.
@item OFFSETS: The offsets for the different dimensions.  This
is internal information computed at tensor construction time.
@end itemize
@end deftp

@anchor{fun-fl.matlisp-gemm}
@deffn Function GEMM @var{ALPHA} @var{X} @var{Y} @var{BETA} @var{Z} &OPTIONAL (@var{JOB} @var{NN})
@findex GEMM
Rewriting of GEMM in terms of GEMM!.
@end deffn

@anchor{fun-fl.matlisp-gemm!}
@deffn Function GEMM! @var{ALPHA} @var{X} @var{Y} @var{BETA} @var{Z} &OPTIONAL (@var{JOB} @var{NN})
@findex GEMM!
Dispatches on the optional job argument (member :nn :tn :nt :tt) and
calls the corresponding generic function, e.g. GEMM-NN!.
@end deffn

@anchor{fun-fl.matlisp-gemm-nn!}
@deffn Function GEMM-NN! @var{ALPHA} @var{X} @var{Y} @var{BETA} @var{Z}
@findex GEMM-NN!
General matrix-matrix multiplication: Z <- alpha * X * Y
+ beta * Z
@end deffn

@anchor{fun-fl.matlisp-gemm-nt!}
@deffn Function GEMM-NT! @var{ALPHA} @var{X} @var{Y} @var{BETA} @var{Z}
@findex GEMM-NT!
General matrix-matrix multiplication: Z <- alpha * X * Y'
+ beta * Z
@end deffn

@anchor{fun-fl.matlisp-gemm-tn!}
@deffn Function GEMM-TN! @var{ALPHA} @var{A} @var{Y} @var{BETA} @var{X}
@findex GEMM-TN!
General matrix-matrix multiplication: Z <- alpha * X' * Y
+ beta * Z
@end deffn

@anchor{fun-fl.matlisp-gemm-tt!}
@deffn Function GEMM-TT! @var{ALPHA} @var{A} @var{Y} @var{BETA} @var{X}
@findex GEMM-TT!
General matrix-matrix multiplication: Z <- alpha * X' * Y'
+ beta * Z
@end deffn

@anchor{fun-fl.matlisp-gesv}
@deffn Function GESV @var{X} @var{B}
@findex GESV
Rewriting for GESV in terms of GESV!.
@end deffn

@anchor{fun-fl.matlisp-getrf}
@deffn Function GETRF @var{X} &OPTIONAL @var{IPIV}
@findex GETRF
Rewriting for GETRF  in terms of GETRF!.
@end deffn

@anchor{fun-fl.matlisp-getrf!}
@deffn Function GETRF! @var{MAT} &OPTIONAL @var{IPIV}
@findex GETRF!
Computes the PLU decomposition of X (overwriting X).
Returns X and as a second value the permuations vector.
@end deffn

@anchor{fun-fl.matlisp-getrs}
@deffn Function GETRS @var{LU} @var{B} &OPTIONAL @var{IPIV}
@findex GETRS
Rewriting for GETRS in terms of GETRS!.
@end deffn

@anchor{fun-fl.matlisp-getrs!}
@deffn Function GETRS! @var{LR} @var{B} &OPTIONAL @var{IPIV}
@findex GETRS!
Solves the given PLU decomposition for the rhs b while
overwriting b.
@end deffn

@anchor{fun-fl.matlisp-int-vec}
@deffn Function INT-VEC &REST @var{COMPS}
@findex INT-VEC
Returns a @class{int-vec} with the entries in @arg{comps}.
@end deffn

@anchor{type-fl.matlisp-int-vec}
@deftp Type INT-VEC
@tindex INT-VEC
Uniform @type{int} vector.
@end deftp

@anchor{fun-fl.matlisp-join}
@deffn Function JOIN @var{X} @var{Y} &OPTIONAL (@var{ORIENTATION} @var{HORIZONTAL})
@findex JOIN
Joins X and Y horizontally or vertically depending on the
value of orientation.
@end deffn

@anchor{fun-fl.matlisp-l2-norm}
@deffn Function L2-NORM @var{X}
@findex L2-NORM
Returns the 2-norm of @arg{x}.
@end deffn

@anchor{fun-fl.matlisp-laplace-full-matrix}
@deffn Function LAPLACE-FULL-MATRIX @var{N}
@findex LAPLACE-FULL-MATRIX
Generates the matrix for a 1-dimensional Laplace problem discretized
with the 3-point stencil on a structured mesh.
@end deffn

@anchor{fun-fl.matlisp-linf-norm}
@deffn Function LINF-NORM @var{X}
@findex LINF-NORM
Returns the maximum norm of @arg{x}.
@end deffn

@anchor{fun-fl.matlisp-lp-norm}
@deffn Function LP-NORM @var{X} @var{P}
@findex LP-NORM
Returns the @arg{p}-norm of @arg{x}.
@end deffn

@anchor{fun-fl.matlisp-m*-product-instance}
@deffn Function M*-PRODUCT-INSTANCE @var{A} @var{Y}
@findex M*-PRODUCT-INSTANCE
Returns a zero matrix for storing the product of X and Y.
@end deffn

@anchor{fun-fl.matlisp-m*-tn}
@deffn Function M*-TN @var{X} @var{Y}
@findex M*-TN
By default M*-TN is rewritten in terms of GEMM-TN!.
@end deffn

@anchor{fun-fl.matlisp-m+}
@deffn Function M+ @var{X} @var{Y}
@findex M+
Returns @math{X} + @math{Y}.
@end deffn

@anchor{fun-fl.matlisp-m+!}
@deffn Function M+! @var{X} @var{Y}
@findex M+!
Y <- X + Y
@end deffn

@anchor{fun-fl.matlisp-m-}
@deffn Function M- @var{X} @var{Y}
@findex M-
Returns X-Y.  Uses AXPY.
@end deffn

@anchor{fun-fl.matlisp-m-!}
@deffn Function M-! @var{X} @var{Y}
@findex M-!
Y - X -> Y.  Uses AXPY!.
@end deffn

@anchor{macro-fl.matlisp-m-incf}
@deffn Macro M-INCF @var{RESULT} @var{INCREMENT}
@findex M-INCF
Adds increment to result which should be a symbol.  If its value is nil
then result is set to increment.
@end deffn

@anchor{fun-fl.matlisp-m.*}
@deffn Function M.* @var{X} @var{Y}
@findex M.*
Returns X .* Y.  Uses M.*! and COPY.
@end deffn

@anchor{fun-fl.matlisp-m/}
@deffn Function M/ @var{X}
@findex M/
Returns the inverse of X.
@end deffn

@anchor{fun-fl.matlisp-make-double-vec}
@deffn Function MAKE-DOUBLE-VEC @var{DIM} &OPTIONAL (@var{INIT} 0.0)
@findex MAKE-DOUBLE-VEC
Returns a @class{double-vec} of length @arg{dim} and initial value
@arg{init}.
@end deffn

@anchor{fun-fl.matlisp-make-real-matrix}
@deffn Function MAKE-REAL-MATRIX &REST @var{ARGS}
@findex MAKE-REAL-MATRIX
Generates a real matrix as specified by its arguments.  If two arguments
are provided, they should be numbers which are interpreted as rows and
columns.  If only one argument is provided, it should be either a number
meaning the rows and columns of a square matrix or a nested list or vector
structure defining the contents matrix.
@end deffn

@anchor{fun-fl.matlisp-make-real-tensor}
@deffn Function MAKE-REAL-TENSOR @var{DIMENSIONS}
@findex MAKE-REAL-TENSOR
Generates an instance of a tensor with DOUBLE-FLOAT entries and the
given @arg{dimensions}.
@end deffn

@anchor{fun-fl.matlisp-make-real-vector}
@deffn Function MAKE-REAL-VECTOR @var{DIM} &OPTIONAL (@var{VALUE} 0.0)
@findex MAKE-REAL-VECTOR
Generates a real matrix of dimension @arg{dim} x 1.
@end deffn

@anchor{fun-fl.matlisp-matrix-slice}
@deffn Function MATRIX-SLICE @var{MAT} &KEY (@var{FROM-ROW} 0) (@var{FROM-COL} 0) (@var{NROWS} (@var{-} (@var{NROWS} @var{MAT}) @var{FROM-ROW})) (@var{NCOLS} (@var{-} (@var{NCOLS} @var{MAT}) @var{FROM-COL}))
@findex MATRIX-SLICE
Extract a submatrix of size @arg{nrows} @math{times}
@arg{ncols} out of @arg{x} starting from position
@arg{from-row}/@arg{from-col}.
@end deffn

@anchor{fun-fl.matlisp-matrix-transpose-instance}
@deffn Function MATRIX-TRANSPOSE-INSTANCE @var{SMAT}
@findex MATRIX-TRANSPOSE-INSTANCE
Returns a zero matrix for storing the transpose of X.
@end deffn

@anchor{fun-fl.matlisp-mequalp}
@deffn Function MEQUALP @var{X} @var{Y}
@findex MEQUALP
Returns T if X and Y have equal entries, otherwise NIL.
@end deffn

@anchor{fun-fl.matlisp-mextract}
@deffn Function MEXTRACT @var{X} @var{Y} @var{ROW-OFF} @var{COL-OFF}
@findex MEXTRACT
Extract matrix Y out of matrix X from the position given
by ROW-OFFSET and COL-OFFSET.
@end deffn

@anchor{fun-fl.matlisp-minject}
@deffn Function MINJECT @var{X} @var{Y} @var{ROW-OFF} @var{COL-OFF}
@findex MINJECT
Inject matrix X in matrix Y at the position given by
ROW-OFFSET and COL-OFFSET.
@end deffn

@anchor{fun-fl.matlisp-mref}
@deffn Function MREF @var{SMAT} @var{ROW-KEY} @var{COL-KEY}
@findex MREF
Returns the matrix element @code{A[i,j]}.
@end deffn

@anchor{fun-fl.matlisp-multiplicity}
@deffn Function MULTIPLICITY @var{<ANSATZ-SPACE>}
@findex MULTIPLICITY
We allow multiple vectors, for solving linear problems
in parallel.
@end deffn

@anchor{fun-fl.matlisp-mzerop}
@deffn Function MZEROP @var{SMAT} &OPTIONAL (@var{THRESHOLD} 0.0)
@findex MZEROP
Returns T if each entry of @arg{x} is smaller or equal
than @arg{threshold}.
@end deffn

@anchor{fun-fl.matlisp-ncols}
@deffn Function NCOLS @var{MAT}
@findex NCOLS
Number of matrix rows.
@end deffn

@anchor{fun-fl.matlisp-norm}
@deffn Function NORM @var{X} &OPTIONAL (@var{P} 2)
@findex NORM
Returns the @arg{p}-norm of @arg{x}.
@end deffn

@anchor{fun-fl.matlisp-normalize}
@deffn Function NORMALIZE @var{X} &OPTIONAL (@var{P} 2)
@findex NORMALIZE
Scales @arg{x} to have @arg{p}-norm equal to 1.
@end deffn

@anchor{fun-fl.matlisp-normalize!}
@deffn Function NORMALIZE! @var{X} &OPTIONAL (@var{P} 2)
@findex NORMALIZE!
Scales @arg{x} destructively to have @arg{p}-norm equal to 1.
@end deffn

@anchor{fun-fl.matlisp-nrows}
@deffn Function NROWS @var{MAT}
@findex NROWS
Number of matrix rows.
@end deffn

@anchor{fun-fl.matlisp-scal}
@deffn Function SCAL @var{ALPHA} @var{X}
@findex SCAL
Returns alpha * X.  Uses SCAL! and COPY.
@end deffn

@anchor{fun-fl.matlisp-scal!}
@deffn Function SCAL! @var{ALPHA} @var{X}
@findex SCAL!
X <- alpha X
@end deffn

@anchor{fun-fl.matlisp-scalar-type}
@deffn Function SCALAR-TYPE @var{VECTOR}
@findex SCALAR-TYPE
Type of the scalars for the vector class.
@end deffn

@anchor{fun-fl.matlisp-standard-matrix}
@deffn Function STANDARD-MATRIX @var{TYPE}
@findex STANDARD-MATRIX
Defines the programmatic class @class{standard-matrix} for element type
@arg{type} as extensions of the programmatic class @class{store-vector}.
@end deffn

@anchor{class-fl.matlisp-standard-matrix}
@deftp Class STANDARD-MATRIX
@tindex STANDARD-MATRIX
Mixin for dense matrices.

Superclasses: <MATRIX>

Direct slots:
@itemize
@item NROWS: Number of rows in the matrix
@item NCOLS: Number of columns in the matrix
@end itemize
@end deftp

@anchor{class-fl.matlisp-store-vector}
@deftp Class STORE-VECTOR
@tindex STORE-VECTOR
This mixin yields vector behaviour for a class
containing a store.  The store is a unifom array with elements of a certain
type which can be determined by the funtion @function{element-type}.  It
often is but does not have to be equal to the type of scalars for this
vector which can be obtained by calling the function
@function{scalar-type}.

Superclasses: <VECTOR>

Direct slots:
@itemize
@item STORE: The vector entries.
@end itemize
@end deftp

@anchor{fun-fl.matlisp-total-entries}
@deffn Function TOTAL-ENTRIES @var{MAT}
@findex TOTAL-ENTRIES
Total number of entries for block vectors.
@end deffn

@anchor{fun-fl.matlisp-transpose}
@deffn Function TRANSPOSE @var{X}
@findex TRANSPOSE
Rewriting for TRANSPOSE.
@end deffn

@anchor{fun-fl.matlisp-transpose!}
@deffn Function TRANSPOSE! @var{X} @var{Y}
@findex TRANSPOSE!
Sets Y to the transpose of X.
@end deffn

@anchor{fun-fl.matlisp-uint-vec}
@deffn Function UINT-VEC &REST @var{COMPS}
@findex UINT-VEC
Returns a @class{uint-vec} with the entries in @arg{comps}.
@end deffn

@anchor{type-fl.matlisp-uint-vec}
@deftp Type UINT-VEC
@tindex UINT-VEC
Uniform @type{uint} vector.
@end deftp

@anchor{fun-fl.matlisp-unit-vector}
@deffn Function UNIT-VECTOR @var{DIM} @var{I}
@findex UNIT-VECTOR
Returns a freshly created copy of the @arg{i}-th carthesian unit vector
in dimension @arg{dim}.
@end deffn

@anchor{fun-fl.matlisp-vector-slice}
@deffn Function VECTOR-SLICE @var{VEC} @var{OFFSET} @var{SIZE}
@findex VECTOR-SLICE
Extract a subvector of size @arg{size} out of @arg{x}
starting from position @arg{offset}.
@end deffn

@anchor{fun-fl.matlisp-vlength}
@deffn Function VLENGTH @var{MAT}
@findex VLENGTH
Length of vector.
@end deffn

@anchor{fun-fl.matlisp-vref}
@deffn Function VREF @var{SVEC} @var{KEY}
@findex VREF
Reader for @math{x_i}.
@end deffn

@anchor{fun-fl.matlisp-x<-0}
@deffn Function X<-0 @var{X}
@findex X<-0
X <- 0 X.  Uses SCAL!.
@end deffn

@node Package FL.ALGEBRA, Package FL.FUNCTION, Package FL.MATLISP, Reference manual
@section Package FL.ALGEBRA

This package defines classes for sparse matrices and
methods operating on them.  The interface is mostly the one used in the
package @package{FL.MATLISP} extended suitably.

This module contains definitions for doing linear algebra in @femlisp{} and
consists of several files.  Besides others, these are @path{vector.lisp}
and @path{matrix.lisp}, where an abstract interface for linear algebra on
vectors and matrices is defined.  In @path{matlisp.lisp}, this interface is
realised for Matlisp matrices, and in addition the Matlisp operations are
partially extended to arrays.  In @path{crs.lisp}, the well-known compact
row-ordered storage is defined for storing sparse matrices, and
@path{tensor.lisp} and @path{sparse-tensor.lisp} contain class and method
definitions for full and sparse tensors of arbitrary rank.

The file @path{sparse.lisp} then introduces a sparse storage scheme for
block vectors and block matrices over arbitrary index sets.  This is very
convenient for functions and linear operators defined on unstructured grids
because the geometric grid objects themselves can index their degrees of
freedom.  It also allows for local updates when advanced adaptive schemes
like the one proposed in @cite{(Ruede 1993)} are used.

At the moment, the classes @class{<sparse-matrix>} and
@class{<sparse-matrix>} which are defined in @file{sparse.lisp} are used
almost exclusively.  Those classes are hash-table based, which implies that
almost every index set can be used.  Basic methods for those classes are
also defined in @path{sparse.lisp}.  An LU decomposition for
@class{<sparse-matrix>} is implemented in @file{sparselu.lisp}.

Unfortunately, the use of hash-tables instead of arrays is much slower than
working with, for example, compact row-ordered storage.  Thus, good
performance can only be expected if the inner blocks are relatively large.
This is the case for systems of equations and/or approximations of higher
order.  Future versions of @femlisp{} will probably improve on that by
using an array-based scheme similar to the one in
@path{sparse-tensor.lisp}.

@anchor{class-fl.algebra-<sparse-matrix>}
@deftp Class <SPARSE-MATRIX>
@tindex <SPARSE-MATRIX>
The <sparse-matrix> represents an unordered matrix graph
indexed by general keys.

Superclasses: <MATRIX> MUTEX-MIXIN

Direct slots:
@itemize
@item ROW-TABLE: Table of rows.
@item COLUMN-TABLE: Table of columns.
@item PRINT-ROW-KEY: Print function for row keys.
@item PRINT-COL-KEY: Print function for column keys.
@item ROW-KEY->SIZE: Function determining the number of rows of a block.
@item COL-KEY->SIZE: Function determining the number of columns of a block.
@item KEYS->PATTERN: Function determining the pattern of a block.
@end itemize
@end deftp

@anchor{class-fl.algebra-<sparse-tensor>}
@deftp Class <SPARSE-TENSOR>
@tindex <SPARSE-TENSOR>
A general sparse tensor class which is implemented as a
sparse vector containing full-or sparse tensor entries.

Direct slots:
@itemize
@item RANK: Tensor rank.
@item INDICES: The (nonzero) indices of the first slot.
@item ENTRIES: The (nonzero) entries of the first slot.
@end itemize
@end deftp

@anchor{class-fl.algebra-<sparse-vector>}
@deftp Class <SPARSE-VECTOR>
@tindex <SPARSE-VECTOR>
Sparse block vector class indexed with general keys.

Superclasses: MUTEX-MIXIN

Direct slots:
@itemize
@item BLOCKS: Table of blocks.
@item KEY->SIZE: Function determining the dimension of a block.
@item PRINT-KEY: Print function for a key.
@item MULTIPLICITY: Multiplicity of the sparse vector.  A
multiplicity different from 1 is used when handling multiple right-hand
sides and solutions simultaneously.
@end itemize
@end deftp

@anchor{fun-fl.algebra-combined-projection}
@deffn Function COMBINED-PROJECTION @var{P1} @var{P2}
@findex COMBINED-PROJECTION
Returns a projection to the range of the given projections.
@end deffn

@anchor{fun-fl.algebra-crs-matrix}
@deffn Function CRS-MATRIX @var{TYPE}
@findex CRS-MATRIX
Construct a CRS matrix with entries of @arg{type}.
@end deffn

@anchor{class-fl.algebra-crs-matrix}
@deftp Class CRS-MATRIX
@tindex CRS-MATRIX
This is an abstract class @class{crs-matrix} which is
made concrete by combining it with a store-vector.

Superclasses: <MATRIX>

Direct slots:
@itemize
@item PATTERN: The pattern of the CRS matrix.  This is kept
separate such that the same pattern can be used for many matrices.
@end itemize
@end deftp

@anchor{class-fl.algebra-crs-pattern}
@deftp Class CRS-PATTERN
@tindex CRS-PATTERN
A CRS (compact row-ordered storage) pattern allowing for
identification, see @cite{(Neuss 1998)}, for use within a
@class{crs-matrix}.

Direct slots:
@itemize
@item NROWS: Number of rows in the pattern.
@item NCOLS: Number of columns in the pattern.
@item NR-OF-ENTRIES: NIL
@item STORE-SIZE: NIL
@item ROW-STARTS: NIL
@item COL-INDS: NIL
@item OFFSETS: NIL
@end itemize
@end deftp

@anchor{fun-fl.algebra-diagonal-sparse-tensor}
@deffn Function DIAGONAL-SPARSE-TENSOR @var{VALUES} &OPTIONAL @var{NCOMPS}
@findex DIAGONAL-SPARSE-TENSOR
Constructs a sparse tensor of rank 2 where @arg{values} are the diagonal
entries.  If @arg{ncomps} is given then the tensor dimension is nxn with
each diagonal entry being @arg{values}.
@end deffn

@anchor{fun-fl.algebra-extend-by-identity}
@deffn Function EXTEND-BY-IDENTITY @var{MAT} @var{EXTEND} &KEY @var{IGNORE} (@var{COPY} @var{T})
@findex EXTEND-BY-IDENTITY
Extends A such that the keys in extend which are not in ignore are
mapped to identity.
@end deffn

@anchor{fun-fl.algebra-extended-extract}
@deffn Function EXTENDED-EXTRACT @var{ASA} @var{SKEL} &KEY (@var{ROW?} @var{T}) (@var{COL?} @var{T}) &ALLOW-OTHER-KEYS
@findex EXTENDED-EXTRACT
Extracts a sub-matrix from a sparse matrix.
@end deffn

@anchor{fun-fl.algebra-full-crs-pattern}
@deffn Function FULL-CRS-PATTERN @var{NROWS} @var{NCOLS}
@findex FULL-CRS-PATTERN
Returns trivial rectangular crs-patterns.
@end deffn

@anchor{fun-fl.algebra-in-pattern-p}
@deffn Function IN-PATTERN-P @var{TENSOR} &REST @var{INDICES}
@findex IN-PATTERN-P
Returns a getter/setter pair for the specified location.
@end deffn

@anchor{fun-fl.algebra-index-range-disjoint-p}
@deffn Function INDEX-RANGE-DISJOINT-P @var{MAT1} @var{MAT2}
@findex INDEX-RANGE-DISJOINT-P
Checks if the range of indices of two sparse matrices is disjoint.
@end deffn

@anchor{fun-fl.algebra-laplace-sparse-matrix}
@deffn Function LAPLACE-SPARSE-MATRIX @var{N}
@findex LAPLACE-SPARSE-MATRIX
Generates a sparse matrix for a 1-dimensional Laplace problem
discretized with the 3-point stencil on a structured mesh.
@end deffn

@anchor{fun-fl.algebra-multiplicity}
@deffn Function MULTIPLICITY @var{<ANSATZ-SPACE>}
@findex MULTIPLICITY
We allow multiple vectors, for solving linear problems
in parallel.
@end deffn

@anchor{fun-fl.algebra-range-and-domain-disjoint-p}
@deffn Function RANGE-AND-DOMAIN-DISJOINT-P @var{MAT}
@findex RANGE-AND-DOMAIN-DISJOINT-P
Checks if index range and index domain of some matrix are disjoint.
@end deffn

@anchor{fun-fl.algebra-shift-diagonal-inverter}
@deffn Function SHIFT-DIAGONAL-INVERTER @var{ETA}
@findex SHIFT-DIAGONAL-INVERTER
Can be used for obtainint a diagonal modification to get ILU_mod.
@end deffn

@anchor{fun-fl.algebra-shift-pattern}
@deffn Function SHIFT-PATTERN @var{PATTERN} @var{SHIFT}
@findex SHIFT-PATTERN
shift-pattern: This function shifts a pattern to
its actual offsets in the sparse graph.
@end deffn

@anchor{fun-fl.algebra-sparse-m*}
@deffn Function SPARSE-M* @var{A} @var{B} &KEY (@var{SPARSITY} @var{A}) (@var{JOB} @var{NN})
@findex SPARSE-M*
Sparse matrix-matrix or matrix-vector multiplication.
Usually, m* should be used.  But in situations, where A or B are very
sparse, the complexity of this routine is much lower.
@end deffn

@anchor{fun-fl.algebra-sparse-matrix->ccs}
@deffn Function SPARSE-MATRIX->CCS @var{A} &KEY @var{KEYS} @var{ROW-KEYS} @var{COL-KEYS} @var{RANGES} @var{ROW-RANGES} @var{COL-RANGES}
@findex SPARSE-MATRIX->CCS
Converts the sparse matrix @arg{A} to CCS format.  @arg{row-keys} and
@arg{col-keys} may denote a submatrix, @arg{col-ranges} and
@arg{row-ranges} may be used for extracting even subblocks of the entries.
This is a rather difficult routine, which might suggest switching to CCS
completely.
@end deffn

@anchor{fun-fl.algebra-total-entries}
@deffn Function TOTAL-ENTRIES @var{MAT}
@findex TOTAL-ENTRIES
Total number of entries for block vectors.
@end deffn

@node Package FL.FUNCTION, Package FL.MESH, Package FL.ALGEBRA, Reference manual
@section Package FL.FUNCTION

NIL

@anchor{class-fl.function-<constant-function>}
@deftp Class <CONSTANT-FUNCTION>
@tindex <CONSTANT-FUNCTION>
For a <constant-function> evaluation and derivative
computation are trivial.

Superclasses: <FUNCTION>

Direct slots:
@itemize
@item VALUE: NIL
@end itemize
@end deftp

@anchor{class-fl.function-<function>}
@deftp Class <FUNCTION>
@tindex <FUNCTION>
The <function> class is an abstract class for a general
function.  This function will usually accept vector arguments, the dimensions of
domain and image are fixed when defining the function. If the function is
differentiable, the gradient matrix can be obtained by evaluating the gradient
slot.

Direct slots:
@itemize
@item DOMAIN-DIMENSION: NIL
@item IMAGE-DIMENSION: NIL
@end itemize
@end deftp

@anchor{class-fl.function-<linear-function>}
@deftp Class <LINEAR-FUNCTION>
@tindex <LINEAR-FUNCTION>
A <linear-function> is determined by a matrix A and a
vector b.  It represents the map @math{x -> Ax+b}.

Superclasses: <FUNCTION>

Direct slots:
@itemize
@item A: NIL
@item B: NIL
@end itemize
@end deftp

@anchor{class-fl.function-<periodic-polygon>}
@deftp Class <PERIODIC-POLYGON>
@tindex <PERIODIC-POLYGON>
This class implements a periodic polygon.

Superclasses: <POLYGON>
@end deftp

@anchor{class-fl.function-<polygon>}
@deftp Class <POLYGON>
@tindex <POLYGON>
This class implements a function which maps the unit
interval to a polygon.

Superclasses: <FUNCTION>

Direct slots:
@itemize
@item POINTS: A vector of points for the polygon.
@end itemize
@end deftp

@anchor{class-fl.function-<special-function>}
@deftp Class <SPECIAL-FUNCTION>
@tindex <SPECIAL-FUNCTION>
A <special-function> provides its own evaluation and gradient
computation.

Superclasses: <FUNCTION>

Direct slots:
@itemize
@item EVALUATOR: NIL
@item GRADIENT: NIL
@item JET: NIL
@end itemize
@end deftp

@anchor{fun-fl.function-circle-function}
@deffn Function CIRCLE-FUNCTION &OPTIONAL (@var{RADIAL-DISTANCE} 1.0) (@var{MIDPOINT} (@var{COERCE} (@var{QUOTE} (0.0 0.0)) (@var{QUOTE} @var{DOUBLE-VEC}))) (@var{OMEGA} 1.0) (@var{PHI0} 0.0)
@findex CIRCLE-FUNCTION
Returns a special function drawing a polar around @arg{midpoint} with
distance given by the function or number @arg{radial-distance} with angular
velocity omega.  Without arguments it yields a function mapping @math{R^1}
isometrically to @math{S^1}.
@end deffn

@anchor{fun-fl.function-compose}
@deffn Function COMPOSE &REST @var{FUNCTIONS}
@findex COMPOSE
Returns the composition of @arg{functions}.
@end deffn

@anchor{fun-fl.function-cubic-spline}
@deffn Function CUBIC-SPLINE @var{Y}
@findex CUBIC-SPLINE
On a regular partition of the unit interval interpolating values y are
given.  This function returns an interpolating spline.
@end deffn

@anchor{fun-fl.function-differentiable-p}
@deffn Function DIFFERENTIABLE-P @var{F} &OPTIONAL (@var{K} 1)
@findex DIFFERENTIABLE-P
Returns t if f is differentiable or differentiable of the
given degree.
@end deffn

@anchor{fun-fl.function-ellipse-matrix}
@deffn Function ELLIPSE-MATRIX @var{RADIUS} @var{EXCENTRICITY} @var{PHI}
@findex ELLIPSE-MATRIX
Returns a matrix A suitable for describing the ellipse as (Ax,x)=1.
@end deffn

@anchor{fun-fl.function-evaluate}
@deffn Function EVALUATE @var{DOF} @var{FE-FUNC}
@findex EVALUATE
Generic evaluation of functions on an argument.  Numbers and
arrays are treated as constants.  Special evaluation is defined for multivariate
polynomials on vectors and for <function> objects.
@end deffn

@anchor{fun-fl.function-evaluate-gradient}
@deffn Function EVALUATE-GRADIENT @var{POLYGON} @var{S}
@findex EVALUATE-GRADIENT
Generic evaluation of gradients of differentiable functions.
@end deffn

@anchor{fun-fl.function-homotopy}
@deffn Function HOMOTOPY @var{FUNC1} @var{FUNC2}
@findex HOMOTOPY
Returns a function which uses its first coordinate as a homotopy
parameter.
@end deffn

@anchor{fun-fl.function-interval-method}
@deffn Function INTERVAL-METHOD @var{FUNC} @var{A} @var{B} @var{ACCURACY}
@findex INTERVAL-METHOD
Finds zeros of functions in 1d by the interval method.
@end deffn

@anchor{fun-fl.function-make-polynomial}
@deffn Function MAKE-POLYNOMIAL @var{COEFFS}
@findex MAKE-POLYNOMIAL
Constructor which simplifies the coefficient list.
@end deffn

@anchor{fun-fl.function-multiple-evaluate}
@deffn Function MULTIPLE-EVALUATE @var{FUNC} @var{POSITIONS}
@findex MULTIPLE-EVALUATE
Multiple evaluations of @arg{func} may be optimized.
@end deffn

@anchor{fun-fl.function-multiple-evaluate-gradient}
@deffn Function MULTIPLE-EVALUATE-GRADIENT @var{F} @var{POSITIONS}
@findex MULTIPLE-EVALUATE-GRADIENT
Multiple evaluations may be optimized.
@end deffn

@anchor{fun-fl.function-n-variate-monomials-of-degree}
@deffn Function N-VARIATE-MONOMIALS-OF-DEGREE @var{N} @var{DEGREE} &OPTIONAL (@var{TYPE} (@var{QUOTE} @var{=}))
@findex N-VARIATE-MONOMIALS-OF-DEGREE
Returns n-variate monomials of degree being equal or being lower or
equal than deg.
Examples:
 (n-variate-monomials-of-degree 2 2) -> (x2^2 x1*x2 x1^2)
 (n-variate-monomials-of-degree 2 2 '<=)  -> (1 x2 x1 x2^2 x1*x2 x1^2)
@end deffn

@anchor{fun-fl.function-numerical-complex-derivative}
@deffn Function NUMERICAL-COMPLEX-DERIVATIVE @var{F}
@findex NUMERICAL-COMPLEX-DERIVATIVE
Computes a very accurate real derivative for functions which can be
applied to complex arguments.
@end deffn

@anchor{fun-fl.function-numerical-gradient}
@deffn Function NUMERICAL-GRADIENT @var{FUNC} &KEY (@var{SHIFT} 1.e-8)
@findex NUMERICAL-GRADIENT
Computes the numerical gradient of func at pos.
@end deffn

@anchor{class-fl.function-polynomial}
@deftp Class POLYNOMIAL
@tindex POLYNOMIAL
Multivariate polynomial.  The coefficients are
represented as nested lists.

Superclasses: <VECTOR>

Direct slots:
@itemize
@item COEFFS: NIL
@end itemize
@end deftp

@anchor{fun-fl.function-project-to-ellipsoid}
@deffn Function PROJECT-TO-ELLIPSOID @var{MIDPOINT} @var{A}
@findex PROJECT-TO-ELLIPSOID
Returns a function which projects to the ellipsoid given by
Q(x-midpoint)=1 where Q is the quadratic form associated with the matrix
A.
@end deffn

@anchor{fun-fl.function-project-to-sphere}
@deffn Function PROJECT-TO-SPHERE @var{MIDPOINT} @var{RADIUS}
@findex PROJECT-TO-SPHERE
Returns a function which projects to the sphere with given midpoint and
radius.
@end deffn

@anchor{fun-fl.function-shift-polynomial}
@deffn Function SHIFT-POLYNOMIAL @var{POLY} @var{DIM}
@findex SHIFT-POLYNOMIAL
Shifts a polynomial in dimension, e.g. x_1 becomes x_2.
@end deffn

@anchor{fun-fl.function-special-1d-function}
@deffn Function SPECIAL-1D-FUNCTION @var{F} &OPTIONAL @var{DF}
@findex SPECIAL-1D-FUNCTION
Constructs a special function between 1D-spaces from ordinary Lisp
functions.
@end deffn

@anchor{fun-fl.function-xn-distortion-function}
@deffn Function XN-DISTORTION-FUNCTION @var{F} @var{GRAD-F} @var{DIM}
@findex XN-DISTORTION-FUNCTION
Returns a function which distorts the xn-coordinate by a factor f(x').
Also grad-f has to be provided.
@end deffn

@node Package FL.MESH, Package FL.PROBLEM, Package FL.FUNCTION, Reference manual
@section Package FL.MESH

This module contains the definitions of meshes and
routines for mesh management.  The meshes allowed in @femlisp{} are more
general than those of most other software for solving PDEs.  In @femlisp{},
both mesh, domain and problem definitions are defined over an underlying
abstraction, the so-called @class{<skeleton>}.  A @class{<skeleton>}
captures the mathematical idea of a "cell complex" which builds a
topological space by mapping from standard cells @class{<cell>}.  Now, a
@class{<skeleton>} can be seen as mapping the cells of such a cell complex
to arbitrary values.  Then, a @class{<domain>} is a @class{<skeleton>}
where each cell (which we call "patch" in this case) is mapped to
geometric properties, and a @class{<mesh>} is a @class{<skeleton>} where
each cell is mapped to the patch to which it belongs.

The basic entities are the class @class{<cell>}, the subclass
@class{<simplex>} which in turn contains subclasses for arbitrarily
dimensional simplices generated on demand, and the subclass
@class{<product-cell>} containing arbitrary products of simplices, e.g. square
or cube.

Meshes can be refined either uniformly or locally using the Freudenthal
algorithm as presented in @cite{JBey_2000a} and generalized to product
elements.  When local refinement is used, hanging nodes may occur.  In
contrast to most other finite element software, in @femlisp{} the
difference of refinement levels of adjacent cells may be arbitrarily large.
Up to now, anisotropic refinement of product cells has not yet been
implemented.

@anchor{var-fl.mesh-*reference-vertex*}
@defvr Variable *REFERENCE-VERTEX*
@vindex *REFERENCE-VERTEX*
The reference vertex.
@end defvr

@anchor{class-fl.mesh-<boundary-cell>}
@deftp Class <BOUNDARY-CELL>
@tindex <BOUNDARY-CELL>
This cell is only fuzzily defined.  Its use is mostly
for defining domains by their boundary.  The slot @slot{midpoint} can be
useful for the graphical output of the cell, the slot @slot{holes} contains
a list of points lying inside holes.  This is intended as help for
triangulation programs.

Superclasses: <STANDARD-CELL>

Direct slots:
@itemize
@item DIMENSION: NIL
@item MIDPOINT: NIL
@item HOLES: NIL
@end itemize
@end deftp

@anchor{class-fl.mesh-<cell>}
@deftp Class <CELL>
@tindex <CELL>
The basic cell class.
@end deftp

@anchor{class-fl.mesh-<domain>}
@deftp Class <DOMAIN>
@tindex <DOMAIN>
A @class{<domain>} is a special @class{<skeleton>}.  We
call its cells @emph{patches}, and the properties of a patch carries
geometric information.  Properties supported up to now are:

@itemize
@item @code{IDENTIFIED}: @emph{list of identified patches}
@item @code{EXTENSION}: @emph{extender}
@item @code{METRIC}: @emph{metric tensor function}
@item @code{VOLUME}: @emph{volume function}
@end itemize

Metric and volume should be functions depending on keyword arguments like
@code{:LOCAL} and @code{:GLOBAL} and allowing arbitrary other keys.

Superclasses: <SKELETON> PROPERTY-MIXIN

Direct slots:
@itemize
@item BOUNDARY: A skeleton containing all boundary patches which is used for
classification of patches.
@item CLASSIFIERS: A list of functions of two arguments -patch and classifications so
far- which are called from the right to classify the patch.
@end itemize
@end deftp

@anchor{class-fl.mesh-<hierarchical-mesh>}
@deftp Class <HIERARCHICAL-MESH>
@tindex <HIERARCHICAL-MESH>
Hierarchical-meshes are those meshes which will be used
most often, because they remember the refinement history and therefore
allow for refinement and coarsening.  The slot levels is an array of
skeletons containing the cells for different levels.

Superclasses: <MESH>

Direct slots:
@itemize
@item LEVELS: NIL
@end itemize
@end deftp

@anchor{class-fl.mesh-<mapped-cell>}
@deftp Class <MAPPED-CELL>
@tindex <MAPPED-CELL>
A mixin which distinguishes cells which are mapped by a
special mapping.

Direct slots:
@itemize
@item MAPPING: NIL
@end itemize
@end deftp

@anchor{class-fl.mesh-<mesh>}
@deftp Class <MESH>
@tindex <MESH>
A <mesh> is a special <skeleton> mapping cells to
property lists with properties of the cell.  The most important property of
a cell is its patch in the domain.  Another one could be a list of possibly
identified cells.  The slot parametric determines which kind of cell
mappings are used for approximating the domain.  These can be the nonlinear
mappings used in the domain definition, but also arbitrary approximations,
to those mappings, e.g. isoparametric mappings.  The special value NIL
means that multilinear mappings are used for all cells outside the
boundaries.

Superclasses: <SKELETON>

Direct slots:
@itemize
@item DOMAIN: The domain of the mesh.
@item PARAMETRIC: NIL
@end itemize
@end deftp

@anchor{class-fl.mesh-<product-cell>}
@deftp Class <PRODUCT-CELL>
@tindex <PRODUCT-CELL>
A mixin for simplex-product cells.
@end deftp

@anchor{class-fl.mesh-<simplex>}
@deftp Class <SIMPLEX>
@tindex <SIMPLEX>
A mixin for simplicial cells.
@end deftp

@anchor{class-fl.mesh-<skeleton>}
@deftp Class <SKELETON>
@tindex <SKELETON>
A skeleton is a vector of hash-tables containing the
cells of a certain dimension as keys.  The information stored in the
values is different depending on the subclass derived from skeleton.

Direct slots:
@itemize
@item DIM: NIL
@item ETABLES: NIL
@end itemize
@end deftp

@anchor{class-fl.mesh-<vertex>}
@deftp Class <VERTEX>
@tindex <VERTEX>
The vertex class.

Superclasses: <CELL>

Direct slots:
@itemize
@item POSITION: NIL
@end itemize
@end deftp

@anchor{fun-fl.mesh-boundary-identifications}
@deffn Function BOUNDARY-IDENTIFICATIONS @var{IDENTIFICATIONS}
@findex BOUNDARY-IDENTIFICATIONS
Returns an identification list for the boundaries of the cells in
identifications.
@end deffn

@anchor{fun-fl.mesh-box-domain}
@deffn Function BOX-DOMAIN @var{DIMENSIONS}
@findex BOX-DOMAIN
Generates a box domain for the given dimensions.  Here,
dimensions is expected to be a list of 2-element lists denoting
the interval along the respective axis.  The algorithm works by
copying the unit cube and modifying the coordinates of the
vertices of the copy.
@end deffn

@anchor{fun-fl.mesh-cell->cube}
@deffn Function CELL->CUBE @var{CELL}
@findex CELL->CUBE
Transforms a product-cell into a degenerated cube with the same vertices.
@end deffn

@anchor{fun-fl.mesh-cell-identification}
@deffn Function CELL-IDENTIFICATION @var{CELL} @var{SKEL}
@findex CELL-IDENTIFICATION
Returns @arg{cell}'s identification in @arg{skel} or NIL.
@end deffn

@anchor{fun-fl.mesh-cells-of-dim}
@deffn Function CELLS-OF-DIM @var{SKEL} @var{DIM}
@findex CELLS-OF-DIM
Returns the cells of @arg{skel} of dimension @arg{dim} in form of a
list.
@end deffn

@anchor{fun-fl.mesh-cells-of-highest-dim}
@deffn Function CELLS-OF-HIGHEST-DIM @var{SKEL}
@findex CELLS-OF-HIGHEST-DIM
Returns the cells of @arg{skel} of highest dimension in form of a list.
@end deffn

@anchor{fun-fl.mesh-combine-identifications}
@deffn Function COMBINE-IDENTIFICATIONS @var{SETS}
@findex COMBINE-IDENTIFICATIONS
Reduces identifications to maximally connected sets.
@end deffn

@anchor{fun-fl.mesh-compare-lexicographically}
@deffn Function COMPARE-LEXICOGRAPHICALLY &KEY (@var{FUZZY} 1.e-12) @var{DIRECTION}
@findex COMPARE-LEXICOGRAPHICALLY
Returns a function which compares two vectors lexicographically.
@end deffn

@anchor{fun-fl.mesh-copy-mesh}
@deffn Function COPY-MESH @var{MESH}
@findex COPY-MESH
Copies a mesh.  Properties copied are only patch and identification.  If
necessary, one might add further properties to be copied as a keyword
argument.
@end deffn

@anchor{fun-fl.mesh-corners}
@deffn Function CORNERS @var{CELL}
@findex CORNERS
Returns a list of corners of the cell, i.e. the global
positions of the cell's vertices.
@end deffn

@anchor{fun-fl.mesh-cube-extender}
@deffn Function CUBE-EXTENDER @var{DOMAIN-CUBE} @var{DIRECTION}
@findex CUBE-EXTENDER
Makes domain-cube ---which should be a cube in a domain--- extensible in
the given direction.
@end deffn

@anchor{fun-fl.mesh-cube-p}
@deffn Function CUBE-P @var{CELL}
@findex CUBE-P
Returns T iff CELL is a cube.
@end deffn

@anchor{fun-fl.mesh-diameter}
@deffn Function DIAMETER @var{CELL}
@findex DIAMETER
Returns the diameter of a cell.
@end deffn

@anchor{fun-fl.mesh-domain-characteristics}
@deffn Function DOMAIN-CHARACTERISTICS @var{DOMAIN}
@findex DOMAIN-CHARACTERISTICS
Returns a property list of characteristics.  The property curved means
that curved patches exist.  The property exact is set to t if the domain
mappings are exact.  Otherwise, only the boundary of the domain should be
assumed to be provided in an exact form.
@end deffn

@anchor{macro-fl.mesh-doskel}
@deffn Macro DOSKEL (@var{LOOPING-VAR} @var{SKEL} &KEY (@var{DIRECTION} @var{UP}) @var{WHERE} @var{DIMENSION}) &BODY @var{BODY}
@findex DOSKEL
Loop through a skeleton.  If looping-var is an atom, it loops through
all cells, otherwise it loops through cells and properties.
@end deffn

@anchor{fun-fl.mesh-embedded-dimension}
@deffn Function EMBEDDED-DIMENSION @var{SKEL}
@findex EMBEDDED-DIMENSION
Dimension of the embedding space for object.
@end deffn

@anchor{fun-fl.mesh-ensure-domain}
@deffn Function ENSURE-DOMAIN @var{DOMAIN}
@findex ENSURE-DOMAIN
If @arg{domain} is an integer, return the corresponding
@arg{n-cube-domain}, if @arg{domain} is a domain return it unchanged,
otherwise signal an error.
@end deffn

@anchor{fun-fl.mesh-ensure-simplex-product}
@deffn Function ENSURE-SIMPLEX-PRODUCT @var{FACTOR-DIMS}
@findex ENSURE-SIMPLEX-PRODUCT
Returns the reference product-cell for the given factor dimensions.
@end deffn

@anchor{fun-fl.mesh-extend}
@deffn Function EXTEND @var{MESH} &KEY (@var{TEST} (@var{CONSTANTLY} @var{T}))
@findex EXTEND
Extends a mesh on all extensible cells for which test ---if provided---
yields T.
@end deffn

@anchor{fun-fl.mesh-factor-simplices}
@deffn Function FACTOR-SIMPLICES @var{CELL}
@findex FACTOR-SIMPLICES
Returns the factor-simplices.
@end deffn

@anchor{fun-fl.mesh-find-cells}
@deffn Function FIND-CELLS @var{TEST} @var{SKEL} &KEY @var{DIMENSION} @var{WITH-PROPERTIES} @var{WHERE}
@findex FIND-CELLS
Returns a list of cells contained in skel and satisfying test.
@end deffn

@anchor{fun-fl.mesh-for-each-cell-of-highest-dimension-on-surface}
@deffn Function FOR-EACH-CELL-OF-HIGHEST-DIMENSION-ON-SURFACE @var{FUNC} @var{H-MESH}
@findex FOR-EACH-CELL-OF-HIGHEST-DIMENSION-ON-SURFACE
Calls func for each cell on the hierarchical-mesh surface.
@end deffn

@anchor{fun-fl.mesh-get-cell-property}
@deffn Function GET-CELL-PROPERTY @var{CELL} @var{SKEL} @var{PROPERTY}
@findex GET-CELL-PROPERTY
Returns the value of the property.
@end deffn

@anchor{fun-fl.mesh-get-refinement-rule}
@deffn Function GET-REFINEMENT-RULE @var{CELL} @var{ID}
@findex GET-REFINEMENT-RULE
Finds the refinement rule for @arg{cell} defined by the @arg{id}.  This
@arg{id} can be a number (position of the rule, T (meaning 0), or some
symbol which is contained in the names of some rule.  Two values are
returned: the rule and its position in the refinement-rule vector.
@end deffn

@anchor{fun-fl.mesh-global->embedded-local}
@deffn Function GLOBAL->EMBEDDED-LOCAL @var{CELL} @var{GLOBAL-POS}
@findex GLOBAL->EMBEDDED-LOCAL
This computes a local coordinate which solves the
Ausgleichsproblem of mapping to a point as near as possible to global-pos.  It
involves more computational work than global->local.  As a second value, the
distance to global-pos is returned.
@end deffn

@anchor{fun-fl.mesh-global->local}
@deffn Function GLOBAL->LOCAL @var{VTX} @var{GLOBAL-POS}
@findex GLOBAL->LOCAL
Mainly useful for finite element evaluation: from the
local position, the value of a fe function can be obtained by
interpolation.  This is done by a Newton iteration, which converges in one
step for linear mappings.
@end deffn

@anchor{fun-fl.mesh-hierarchically-ordered-cells}
@deffn Function HIERARCHICALLY-ORDERED-CELLS @var{H-MESH} &KEY @var{LEVEL}
@findex HIERARCHICALLY-ORDERED-CELLS
Sorts the cells up to the given level (defaulting to the last
level) hierarchically for use in something similar to the nested
disection method.  Returns a list of the sorted cells.
@end deffn

@anchor{fun-fl.mesh-identified-cells}
@deffn Function IDENTIFIED-CELLS @var{CELL} @var{SKEL}
@findex IDENTIFIED-CELLS
Returns a list of cells in @arg{skel} which are
identified with @arg{cell}.
@end deffn

@anchor{fun-fl.mesh-identified-p}
@deffn Function IDENTIFIED-P @var{CELL} @var{SKEL}
@findex IDENTIFIED-P
Returns @arg{cell}'s identification in @arg{skel} or NIL.
@end deffn

@anchor{fun-fl.mesh-identify}
@deffn Function IDENTIFY @var{IDENTIFIED-CELLS} @var{SKEL}
@findex IDENTIFY
Identifies all cells in @arg{identified-cells} within @arg{skel}.
@end deffn

@anchor{fun-fl.mesh-identify-unit-cell-faces}
@deffn Function IDENTIFY-UNIT-CELL-FACES @var{SKEL} &KEY (@var{INDICES} @var{ALL})
@findex IDENTIFY-UNIT-CELL-FACES
This routines identifies boundary cells in skel which correspond to
boundary cells in the unit cube.  Warning: exact arithmetic is used to
recognize identified cells.  This should work for skeletons derived from
the unit cell, but may create problems in other situations.
@end deffn

@anchor{fun-fl.mesh-inner-refcell-children}
@deffn Function INNER-REFCELL-CHILDREN @var{REFCELL} @var{RULE}
@findex INNER-REFCELL-CHILDREN
Returns the children of refcell.
@end deffn

@anchor{fun-fl.mesh-insert-cell!}
@deffn Function INSERT-CELL! @var{SKEL} @var{CELL}
@findex INSERT-CELL!
Inserts a cell and its boundary into a skeleton.
@end deffn

@anchor{fun-fl.mesh-insert-cell-from-corners}
@deffn Function INSERT-CELL-FROM-CORNERS @var{MESH} @var{CORNERS->CELL} @var{CELL-CLASS} @var{CORNERS} @var{PROPERTIES} &KEY (@var{CREATE-SUBCELLS} @var{T})
@findex INSERT-CELL-FROM-CORNERS
Creates a cell of type cell-class with corners given by corners.
corners->cell has to be an equalp hash-table mapping corners to the
corresponding cell.  It is updated by this function.
@end deffn

@anchor{fun-fl.mesh-insert-cells!}
@deffn Function INSERT-CELLS! @var{SKEL} @var{CELLS}
@findex INSERT-CELLS!
Inserts a list of cells into a skeleton.
@end deffn

@anchor{fun-fl.mesh-inside-cell?}
@deffn Function INSIDE-CELL? @var{CELL} @var{POS}
@findex INSIDE-CELL?
Checks if global-pos is inside the interior of the cell.
It calls coordinates-inside? which is defined for every cell class.
@end deffn

@anchor{fun-fl.mesh-iterate-identifications}
@deffn Function ITERATE-IDENTIFICATIONS @var{INITIAL-IDENTIFICATIONS}
@findex ITERATE-IDENTIFICATIONS
Generates all identifications of the skeleton from the identifications
of some higher-dimensional cells.
@end deffn

@anchor{fun-fl.mesh-key-is-subcell-p}
@deffn Function KEY-IS-SUBCELL-P @var{KEY1} @var{KEY2}
@findex KEY-IS-SUBCELL-P
Checks if @arg{key1} occurs as subcell of @arg{key2}.  The keys can be
either cells or identifications.
@end deffn

@anchor{fun-fl.mesh-l-domain}
@deffn Function L-DOMAIN @var{DIM}
@findex L-DOMAIN
Creates an L-domain by cutting out a small cube of the uniform refinement of
the unit cube.
@end deffn

@anchor{fun-fl.mesh-l2dg}
@deffn Function L2DG @var{SIMPLEX} @var{LOCAL-POS}
@findex L2DG
Computes the gradient for a multilinear
interpolation from the vertices.
@end deffn

@anchor{fun-fl.mesh-l2g}
@deffn Function L2G @var{VTX} @var{LOCAL-POS}
@findex L2G
Computes the global position by interpolation from the
vertices.
@end deffn

@anchor{fun-fl.mesh-level-of-cell}
@deffn Function LEVEL-OF-CELL @var{CELL} @var{H-MESH}
@findex LEVEL-OF-CELL
Returns the level of @arg{cell} in the hirearchical mesh @arg{h-mesh}.
@end deffn

@anchor{fun-fl.mesh-local->dglobal}
@deffn Function LOCAL->DGLOBAL @var{VTX} @var{LOCAL-POS}
@findex LOCAL->DGLOBAL
local->Dglobal checks if a mapping is given for the cell.
If yes, then the gradient of this mapping is evaluated (if available).  If no,
then the function l2Dg is called which gives the gradient for a multilinear
interpolation from the cell's corners.
@end deffn

@anchor{fun-fl.mesh-local->global}
@deffn Function LOCAL->GLOBAL @var{CELL} @var{LOCAL-POS}
@findex LOCAL->GLOBAL
local->global checks if a mapping is given for the cell.
If yes, then this mapping is evaluated.  If no, then the function l2g is called
which should do a multilinear interpolation from the cell's corners.
@end deffn

@anchor{fun-fl.mesh-local-coordinates-of-midpoint}
@deffn Function LOCAL-COORDINATES-OF-MIDPOINT @var{CELL}
@findex LOCAL-COORDINATES-OF-MIDPOINT
Returns the local coordinates of the cell midpoint.
@end deffn

@anchor{fun-fl.mesh-make-cell-from-corners}
@deffn Function MAKE-CELL-FROM-CORNERS @var{CELL-CLASS} @var{CORNERS}
@findex MAKE-CELL-FROM-CORNERS
Creates a cell of class CELL-CLASS having the given CORNERS.
@end deffn

@anchor{fun-fl.mesh-make-cell-from-vertices}
@deffn Function MAKE-CELL-FROM-VERTICES @var{CELL-CLASS} @var{VERTICES}
@findex MAKE-CELL-FROM-VERTICES
Creates a cell of class CELL-CLASS having the given VERTICES.
@end deffn

@anchor{fun-fl.mesh-make-hierarchical-mesh-from-domain}
@deffn Function MAKE-HIERARCHICAL-MESH-FROM-DOMAIN @var{DOMAIN} &KEY @var{PARAMETRIC} &ALLOW-OTHER-KEYS
@findex MAKE-HIERARCHICAL-MESH-FROM-DOMAIN
Construct a hierarchical-mesh from a domain.
@end deffn

@anchor{fun-fl.mesh-make-line}
@deffn Function MAKE-LINE @var{FROM-VTX} @var{TO-VTX} &KEY (@var{CHECK} @var{T}) @var{MAPPING}
@findex MAKE-LINE
Creates a line given its endpoints.
@end deffn

@anchor{fun-fl.mesh-make-mesh-from-domain}
@deffn Function MAKE-MESH-FROM-DOMAIN @var{DOMAIN} &KEY @var{PARAMETRIC} &ALLOW-OTHER-KEYS
@findex MAKE-MESH-FROM-DOMAIN
Transforms a domain which is specified sufficiently well
into a mesh.
@end deffn

@anchor{fun-fl.mesh-make-simplex}
@deffn Function MAKE-SIMPLEX @var{BOUNDARY} &KEY (@var{CHECK} @var{T}) @var{MAPPING}
@findex MAKE-SIMPLEX
Short form of creating a simplex given its boundary.  An alternative is
creating it from its vertices, see the functions MAKE-CELL-FROM-VERTICES
and INSERT-CELL-FROM-CORNERS.
@end deffn

@anchor{fun-fl.mesh-make-vertex}
@deffn Function MAKE-VERTEX @var{POSITION} &OPTIONAL @var{MAPPING}
@findex MAKE-VERTEX
General vertex constructor.
@end deffn

@anchor{fun-fl.mesh-mapped-cell-class}
@deffn Function MAPPED-CELL-CLASS @var{CLASS} &OPTIONAL @var{DISTORTED}
@findex MAPPED-CELL-CLASS
Constructs a cell class with <mapped-cell> mixin.
@end deffn

@anchor{fun-fl.mesh-member-of-skeleton?}
@deffn Function MEMBER-OF-SKELETON? @var{CELL} @var{SKEL}
@findex MEMBER-OF-SKELETON?
Returns T if @arg{cell} is in @arg{skel}, NIL otherwise.
@end deffn

@anchor{fun-fl.mesh-meshsize}
@deffn Function MESHSIZE @var{MESH}
@findex MESHSIZE
Computes a meshsize.  Please refer to the method
documentations for the exact definition.
@end deffn

@anchor{fun-fl.mesh-midpoint}
@deffn Function MIDPOINT @var{<BOUNDARY-CELL>}
@findex MIDPOINT
Returns cell midpoint in global coordinates.
@end deffn

@anchor{fun-fl.mesh-n-ball-domain}
@deffn Function N-BALL-DOMAIN @var{DIM}
@findex N-BALL-DOMAIN
Generates an n-dimensional ball domain with 2^n simplex patches.
@end deffn

@anchor{fun-fl.mesh-n-cell-domain}
@deffn Function N-CELL-DOMAIN @var{DIM}
@findex N-CELL-DOMAIN
Generates an n-dimensional cell domain which is a n-dimensional unit
cube with its opposite sides identified.
@end deffn

@anchor{fun-fl.mesh-n-cube}
@deffn Function N-CUBE @var{DIM}
@findex N-CUBE
Returns the reference cube of dimension dim.
@end deffn

@anchor{fun-fl.mesh-n-simplex}
@deffn Function N-SIMPLEX @var{DIM}
@findex N-SIMPLEX
Returns the reference simplex of the given dimension.
@end deffn

@anchor{fun-fl.mesh-nr-of-cells}
@deffn Function NR-OF-CELLS @var{SKEL} &OPTIONAL @var{DIMENSION}
@findex NR-OF-CELLS
Returns number of cells in a skeleton.
@end deffn

@anchor{fun-fl.mesh-nr-of-sides}
@deffn Function NR-OF-SIDES @var{CELL}
@findex NR-OF-SIDES
Returns the number of boundary faces.
@end deffn

@anchor{fun-fl.mesh-nr-of-subcells}
@deffn Function NR-OF-SUBCELLS @var{CELL}
@findex NR-OF-SUBCELLS
Returns the number of subcells.
@end deffn

@anchor{fun-fl.mesh-nr-of-vertices}
@deffn Function NR-OF-VERTICES @var{CELL}
@findex NR-OF-VERTICES
Returns the number of vertices.
@end deffn

@anchor{fun-fl.mesh-origin}
@deffn Function ORIGIN @var{CELL}
@findex ORIGIN
Returns cell origin in global coordinates.
@end deffn

@anchor{fun-fl.mesh-patch-classification}
@deffn Function PATCH-CLASSIFICATION @var{PATCH} @var{DOMAIN}
@findex PATCH-CLASSIFICATION
Returns a list of classifications for @arg{patch} in @arg{domain}.
@end deffn

@anchor{fun-fl.mesh-refcell-children}
@deffn Function REFCELL-CHILDREN @var{REFCELL} @var{RULE}
@findex REFCELL-CHILDREN
Returns the children for refcell and subcells.
@end deffn

@anchor{fun-fl.mesh-refcell-refinement-skeleton}
@deffn Function REFCELL-REFINEMENT-SKELETON @var{REFCELL} &OPTIONAL (@var{LEVEL} 1) (@var{RULE} 0) @var{REINIT}
@findex REFCELL-REFINEMENT-SKELETON
Returns an LEVEL times refined skeleton of REFCELL.  It is partially
memoized, see the documentation of *REFCELL-REFINEMENT-MEMOIZE-DEPTH*.
@end deffn

@anchor{fun-fl.mesh-reference-cell-p}
@deffn Function REFERENCE-CELL-P @var{CELL}
@findex REFERENCE-CELL-P
Tests if a cell is a reference cell.
@end deffn

@anchor{fun-fl.mesh-refine}
@deffn Function REFINE @var{H-MESH} &KEY (@var{INDICATOR} (@var{CONSTANTLY} @var{T}))
@findex REFINE
Refines @arg{skel} either locally or globally depending
on the @function{indicator}.
@end deffn

@anchor{fun-fl.mesh-refine-info}
@deffn Function REFINE-INFO @var{CELL}
@findex REFINE-INFO
Returns refinement information for the cell.
@end deffn

@anchor{fun-fl.mesh-refinement}
@deffn Function REFINEMENT @var{CELL} @var{SKELETON}
@findex REFINEMENT
Returns the refinement of @arg{cell} in @arg{skeleton} as two values:
the rule and the children.
@end deffn

@anchor{fun-fl.mesh-refinement-interface}
@deffn Function REFINEMENT-INTERFACE @var{H-MESH} &KEY @var{LEVEL}
@findex REFINEMENT-INTERFACE
Returns the refined boundary subcells of unrefined cells in a skeleton.
Those cells are found as all refined cells which are not part of the domain
boundary.  At the moment, this is a global operation.  Later on, it should
probably be localized.
@end deffn

@anchor{fun-fl.mesh-refinement-rule}
@deffn Function REFINEMENT-RULE @var{CELL} @var{SKEL}
@findex REFINEMENT-RULE
Returns the refinement rule of @arg{cell} in @arg{skel}.
@end deffn

@anchor{class-fl.mesh-refinement-rule}
@deftp Class REFINEMENT-RULE
@tindex REFINEMENT-RULE
Rule for refining reference cells.  Those rules are
stored in the refine-info slot of the cell class.

Direct slots:
@itemize
@item NAMES: Names identifying the rule.
@item REFCELL: Reference cell for this refinement rule.
@item BOUNDARY-REFINEMENT-RULES: Refinement rules for the sides required by this rule.
@item REFINEMENT-INFO: Vector of refinement information for the children.
@end itemize
@end deftp

@anchor{fun-fl.mesh-representative}
@deffn Function REPRESENTATIVE @var{OBJ}
@findex REPRESENTATIVE
Returns a representative for this object.
@end deffn

@anchor{fun-fl.mesh-simplex-product-domain}
@deffn Function SIMPLEX-PRODUCT-DOMAIN @var{DIMS}
@findex SIMPLEX-PRODUCT-DOMAIN
Generates a product-cell domain for the given factor dimensions.
@end deffn

@anchor{fun-fl.mesh-skel-add!}
@deffn Function SKEL-ADD! @var{SKEL-1} @var{SKEL-2} &KEY (@var{OVERRIDE} @var{NIL}) @var{ACTIVE-SKEL-1}
@findex SKEL-ADD!
Adds @arg{skel-2} to @arg{skel-1} destructively for @arg{skel-1}.
Overlaying cells are identified.  @arg{override} is a list of properties
which are copied from skel-2 on the overlap.  @arg{active-skel-1} is used
for hierarchical-meshes for selecting a level to which @arg{skel-2} is
added.  This function returns three values: the first is @arg{skel-1}, the
second is @arg{skel-2}, the third is a hash-table mapping overlapping cells
from @arg{skel-2} to their counterpart in @arg{skel-1}.
@end deffn

@anchor{fun-fl.mesh-skel-for-each}
@deffn Function SKEL-FOR-EACH @var{FUNC} @var{SKEL} &KEY @var{DIRECTION} @var{DIMENSION} @var{WHERE} @var{WITH-PROPERTIES}
@findex SKEL-FOR-EACH
Loops through a skeleton applying func.  When direction is :down then loops
with dimension of the cells decreasing, otherwise increasing.
@end deffn

@anchor{fun-fl.mesh-skel-ref}
@deffn Function SKEL-REF @var{SKEL} @var{CELL}
@findex SKEL-REF
Returns the properties of @arg{cell} in @arg{skel}.
@end deffn

@anchor{fun-fl.mesh-skeleton}
@deffn Function SKELETON @var{CELL}
@findex SKELETON
Returns a skeleton for the given cell or the given
cells.
@end deffn

@anchor{fun-fl.mesh-skeleton-without-cell}
@deffn Function SKELETON-WITHOUT-CELL @var{SKEL} @var{CELL-TO-REMOVE}
@findex SKELETON-WITHOUT-CELL
Removes a cell from a skeleton such that the rest remains a skeleton.
Warning: does not handle identifications yet.
@end deffn

@anchor{fun-fl.mesh-sort-lexicographically}
@deffn Function SORT-LEXICOGRAPHICALLY @var{ELIST} &KEY (@var{FUZZY} 1.e-12)
@findex SORT-LEXICOGRAPHICALLY
Sorts a cell list lexicographically by the coordinates of their
midpoint.
@end deffn

@anchor{fun-fl.mesh-special-mesh-on-box-domain}
@deffn Function SPECIAL-MESH-ON-BOX-DOMAIN @var{DOMAIN} @var{PATCH->MESH-SIZES}
@findex SPECIAL-MESH-ON-BOX-DOMAIN
Creates a uniform mesh consisting of N_1 x ... x N_dim cells on a box
domain.
@end deffn

@anchor{fun-fl.mesh-standard-extender}
@deffn Function STANDARD-EXTENDER @var{ORIGINAL-CELL} @var{REPLACEMENT}
@findex STANDARD-EXTENDER
Extension function replacing an original-cell with a replacement.
@end deffn

@anchor{fun-fl.mesh-structured-skeleton}
@deffn Function STRUCTURED-SKELETON @var{N} @var{H} &KEY @var{CORNERS->CELL}
@findex STRUCTURED-SKELETON
Create a uniform box skeleton consisting of N_1 x ... x N_dim cubes of
dimensions h_1 x ... x h_dim.
@end deffn

@anchor{fun-fl.mesh-subcell-children}
@deffn Function SUBCELL-CHILDREN @var{CELL} @var{SKELETON}
@findex SUBCELL-CHILDREN
Returns a vector of all children of the subcells of @arg{cell} in
@arg{skeleton}.
@end deffn

@anchor{fun-fl.mesh-subcells}
@deffn Function SUBCELLS @var{CELL}
@findex SUBCELLS
Returns a vector containing all subcells of a given cell.  The code is
special to each class and often automatically generated by
@function{generate-subcell-access-code}.
@end deffn

@anchor{fun-fl.mesh-surface-cells-of-dim}
@deffn Function SURFACE-CELLS-OF-DIM @var{H-MESH} @var{DIM}
@findex SURFACE-CELLS-OF-DIM
This function returns the surface cells of a locally refined
hierarchical-mesh structure.
@end deffn

@anchor{fun-fl.mesh-surface-cells-of-highest-dim}
@deffn Function SURFACE-CELLS-OF-HIGHEST-DIM @var{H-MESH}
@findex SURFACE-CELLS-OF-HIGHEST-DIM
This function returns the surface cells of highest dimension of a
locally refined hierarchical-mesh structure.
@end deffn

@anchor{fun-fl.mesh-triangulate}
@deffn Function TRIANGULATE @var{DOMAIN} &REST @var{ARGS} &KEY @var{PARAMETRIC} &ALLOW-OTHER-KEYS
@findex TRIANGULATE
Triangulate @arg{domain} by successively building a mesh on the domain
skeleton starting from the 0-dimensional patches.
@end deffn

@anchor{fun-fl.mesh-triangulize}
@deffn Function TRIANGULIZE @var{MESH}
@findex TRIANGULIZE
Transforms a product-cell mesh into a simplex mesh.
@end deffn

@anchor{fun-fl.mesh-uniform-mesh-on-box-domain}
@deffn Function UNIFORM-MESH-ON-BOX-DOMAIN @var{DOMAIN} @var{N}
@findex UNIFORM-MESH-ON-BOX-DOMAIN
Creates a uniform mesh consisting of N_1 x ... x N_dim cells on a box
domain.
@end deffn

@anchor{fun-fl.mesh-uniformly-refined-mesh}
@deffn Function UNIFORMLY-REFINED-MESH @var{DOMAIN} @var{N} &KEY @var{PARAMETRIC}
@findex UNIFORMLY-REFINED-MESH
Generates a mesh by refining the domain partition uniformly.
@end deffn

@anchor{fun-fl.mesh-vertices}
@deffn Function VERTICES @var{CELL}
@findex VERTICES
Returns a list of all vertices of the cell.
@end deffn

@node Package FL.PROBLEM, Package FL.CDR, Package FL.MESH, Reference manual
@section Package FL.PROBLEM

 The @package{FL.PROBLEM} package introduces the
general class @class{<problem>} and some subclasses.  The most interesting
subclass is @class{<pde-problem>}.  A @class{<pde-problem>} is defined on a
domain and provides a table mapping the domain patches to property lists
containing the coefficient functions.

Several subclasses of @class{<pde-problem>} are defined in own packages,
e.g. @class{<cdr-problem>} in @package{FL.CDR},
@class{<elasticity-problem>} in @package{FL.ELASTICITY} and
@class{<navier-stokes-problem} in @package{FL.NAVIER-STOKES}.

@anchor{class-fl.problem-<coefficient>}
@deftp Class <COEFFICIENT>
@tindex <COEFFICIENT>
The coefficient class.

Direct slots:
@itemize
@item DIMENSION: The dimension of the cell on which this coefficient is
active.  The value T means that it is active on all cells lying on the
patch.
@item DEMANDS: A list indicating which information the evaluation
function needs.  Possible choices depend on problem and discretization,
e.g. @code{:local}, @code{:global}, @code{:fe}, @code{:cell} are possible
choices.  One element can also be a list starting with the keyword
@code{:fe-parameters} and followed by symbols indicating names of finite
element functions on the discretization blackboard.
@item EVAL: The evaluation funtion.  It accepts a list of
keyword parameters which should correspond to the list in DEMANDS.
@item RESIDUAL: T means evaluation for computing the residual.
@item JACOBIAN: T means evaluation for computing the Jacobian.
@end itemize
@end deftp

@anchor{class-fl.problem-<domain-problem>}
@deftp Class <DOMAIN-PROBLEM>
@tindex <DOMAIN-PROBLEM>
An instance of this class describes a problem posed on
the domain @slot{domain}.  The slot @slot{coefficients} contains a table
mapping domain patches to property lists of the form (@symbol{identifier1}
@code{coefficient1} @symbol{identifier2} @code{coefficient2} ...).  Here
identifiers are special symbols and the coefficients are objects of type
@class{<coefficient>}.  When the problem instance is initialized this table
is usually set up by calling the function @function{patch->coefficients}
which has to be provided as a key argument.  The slot @slot{multiplicity}
can be chosen as a positive integer @math{n} if the problem is posed with
@math{n} different right hand sides simultaneously.

Note also that for nonlinear problems, where the coefficients depend on the
solution, an approximate solution can be found as a property of the
problem.

Superclasses: <PROBLEM>

Direct slots:
@itemize
@item DOMAIN: NIL
@item COEFFICIENTS: Hash table which maps domain patches to coefficients.
@item MULTIPLICITY: NIL
@end itemize
@end deftp

@anchor{class-fl.problem-<evp-mixin>}
@deftp Class <EVP-MIXIN>
@tindex <EVP-MIXIN>
A mixin for eigenvalue problems.

Direct slots:
@itemize
@item LAMBDA: The multiplier for the mass matrix, usually equal to the
eigenvalue.
@item MU: The multiplier for the system matrix.
@end itemize
@end deftp

@anchor{class-fl.problem-<evp>}
@deftp Class <EVP>
@tindex <EVP>
Standard class for discrete eigenvalue problems.

Superclasses: <EVP-MIXIN> <NONLINEAR-PROBLEM>
@end deftp

@anchor{class-fl.problem-<interpolation-problem>}
@deftp Class <INTERPOLATION-PROBLEM>
@tindex <INTERPOLATION-PROBLEM>
Interpolation problem on a domain.  The function which
is to be interpolated is given as a coefficient with key FUNCTION in the
coefficient list.

Superclasses: <DOMAIN-PROBLEM>
@end deftp

@anchor{class-fl.problem-<ls-evp>}
@deftp Class <LS-EVP>
@tindex <LS-EVP>
Generalized eigenvalue problem for matrices.

Superclasses: <EVP>

Direct slots:
@itemize
@item A: (Energy) matrix A.
@item B: (Mass) matrix B.
@end itemize
@end deftp

@anchor{class-fl.problem-<lse>}
@deftp Class <LSE>
@tindex <LSE>
Standard form of a linear system of equations.

Superclasses: <PROBLEM>

Direct slots:
@itemize
@item MATRIX: NIL
@item RHS: NIL
@end itemize
@end deftp

@anchor{class-fl.problem-<nlse>}
@deftp Class <NLSE>
@tindex <NLSE>
Class for nonlinear system of equations.

Superclasses: <NONLINEAR-PROBLEM>
@end deftp

@anchor{class-fl.problem-<nonlinear-problem>}
@deftp Class <NONLINEAR-PROBLEM>
@tindex <NONLINEAR-PROBLEM>
Class for nonlinear problems.  The linearization
contains a function returning a linear problem.

Superclasses: <PROBLEM>

Direct slots:
@itemize
@item LINEARIZATION: A function linearizing the problem.
@item INITIAL-GUESS: An initial guess for a solution.
@end itemize
@end deftp

@anchor{class-fl.problem-<pde-problem>}
@deftp Class <PDE-PROBLEM>
@tindex <PDE-PROBLEM>
Base-class for a pde-problem.

Superclasses: <DOMAIN-PROBLEM>
@end deftp

@anchor{class-fl.problem-<problem>}
@deftp Class <PROBLEM>
@tindex <PROBLEM>
Base class for all problems.

Superclasses: PROPERTY-MIXIN
@end deftp

@anchor{class-fl.problem-<solver>}
@deftp Class <SOLVER>
@tindex <SOLVER>
The base class of linear, nonlinear and whatever
iterative solvers.

Direct slots:
@itemize
@item OUTPUT: NIL
@end itemize
@end deftp

@anchor{class-fl.problem-<time-dependent-problem>}
@deftp Class <TIME-DEPENDENT-PROBLEM>
@tindex <TIME-DEPENDENT-PROBLEM>
A mixin which should be used together with a
<PDE-PROBLEM> in a call to MAKE-PROGRAMMATIC-INSTANCE.
@end deftp

@anchor{fun-fl.problem-add-fe-parameters-demand}
@deffn Function ADD-FE-PARAMETERS-DEMAND @var{DEMANDS} @var{NEW-PARAS}
@findex ADD-FE-PARAMETERS-DEMAND
Adds a list of fe-functions to the demands.
@end deffn

@anchor{fun-fl.problem-boundary-coefficient-p}
@deffn Function BOUNDARY-COEFFICIENT-P @var{PROBLEM} @var{COEFF}
@findex BOUNDARY-COEFFICIENT-P
Tests, if @arg{coeff} is a boundary coefficient of @arg{problem}.
@end deffn

@anchor{fun-fl.problem-boundary-coefficients}
@deffn Function BOUNDARY-COEFFICIENTS @var{PROBLEM}
@findex BOUNDARY-COEFFICIENTS
Returns a list of possible boundary coefficients for
@arg{problem}.
@end deffn

@anchor{fun-fl.problem-coefficient-p}
@deffn Function COEFFICIENT-P @var{PROBLEM} @var{COEFF}
@findex COEFFICIENT-P
Test if @arg{coeff} is a coefficient of @arg{problem}.
@end deffn

@anchor{fun-fl.problem-coefficients-of-cell}
@deffn Function COEFFICIENTS-OF-CELL @var{CELL} @var{MESH} @var{MSP}
@findex COEFFICIENTS-OF-CELL
An accessor for the coefficients of @arg{problem} valid
for @arg{cell}.
@end deffn

@anchor{fun-fl.problem-coefficients-of-patch}
@deffn Function COEFFICIENTS-OF-PATCH @var{PATCH} @var{PROBLEM}
@findex COEFFICIENTS-OF-PATCH
An accessor for the coefficients of @arg{patch} for @arg{problem}.
@end deffn

@anchor{fun-fl.problem-constant-coefficient}
@deffn Function CONSTANT-COEFFICIENT @var{VALUE} &REST @var{OTHER-VALUES}
@findex CONSTANT-COEFFICIENT
Returns a coefficient which takes the given value.  Several values can
be passed which is needed, for example, for returning also the type of a
boundary condition.
@end deffn

@anchor{fun-fl.problem-constraint-coefficient}
@deffn Function CONSTRAINT-COEFFICIENT @var{COMPONENTS} @var{MULTIPLICITY}
@findex CONSTRAINT-COEFFICIENT
Returns a coefficient function which sets Dirichlet zero boundary
conditions for all components of a PDE system.
@end deffn

@anchor{fun-fl.problem-dual-problem}
@deffn Function DUAL-PROBLEM @var{PROBLEM} @var{CELL->RHS}
@findex DUAL-PROBLEM
Returns the dual problem for @arg{problem} with the
right-hand side given by @arg{functional}.  The solution of this problem
measures the sensitivity of @arg{functional} applied to the solution of
problem with respect to errors in the solution.
@end deffn

@anchor{fun-fl.problem-energy}
@deffn Function ENERGY @var{EVP} @var{X}
@findex ENERGY
Evaluates the energy bilinear form for a generalized eigenvalue problem.
@end deffn

@anchor{fun-fl.problem-ensure-coefficient}
@deffn Function ENSURE-COEFFICIENT @var{OBJ}
@findex ENSURE-COEFFICIENT
Returns @arg{obj} if it is a coefficient, converts @arg{obj} into a
coefficient depending on the space variable if @arg{obj} is a function;
otherwise, @arg{obj} is made into a constant coefficient.
@end deffn

@anchor{fun-fl.problem-ensure-residual}
@deffn Function ENSURE-RESIDUAL @var{LSE} @var{BLACKBOARD}
@findex ENSURE-RESIDUAL
Ensures that the field :RESIDUAL is computed and that
the flag :RESIDUAL-P is set on the blackboard.
@end deffn

@anchor{fun-fl.problem-ensure-solution}
@deffn Function ENSURE-SOLUTION @var{NLPB} @var{BLACKBOARD}
@findex ENSURE-SOLUTION
Ensures that the field :SOLUTION is set on the
blackboard.
@end deffn

@anchor{fun-fl.problem-filter-applicable-coefficients}
@deffn Function FILTER-APPLICABLE-COEFFICIENTS @var{COEFFS} @var{CELL} @var{PATCH} &KEY (@var{CONSTRAINTS} @var{T})
@findex FILTER-APPLICABLE-COEFFICIENTS
Filters out the applicable coefficients for the respective cell with the
given patch.
@end deffn

@anchor{fun-fl.problem-f[u]->coefficient}
@deffn Function F[U]->COEFFICIENT @var{FUNC}
@findex F[U]->COEFFICIENT
The function argument @arg{func} is transformed into a coefficient
depending on the solution.
@end deffn

@anchor{fun-fl.problem-f[xu]->coefficient}
@deffn Function F[XU]->COEFFICIENT @var{FUNC}
@findex F[XU]->COEFFICIENT
The function argument @arg{func} is transformed into a coefficient
depending on position and solution.
@end deffn

@anchor{fun-fl.problem-f[x]->coefficient}
@deffn Function F[X]->COEFFICIENT @var{FUNC}
@findex F[X]->COEFFICIENT
The function argument @arg{func} is transformed into a coefficient
depending on global coordinates.
@end deffn

@anchor{fun-fl.problem-get-coefficient}
@deffn Function GET-COEFFICIENT @var{COEFFS} @var{NAME}
@findex GET-COEFFICIENT
Get coefficient @arg{name} from the list @arg{coeffs}.
@end deffn

@anchor{fun-fl.problem-get-property}
@deffn Function GET-PROPERTY @var{OBJECT} @var{PROPERTY}
@findex GET-PROPERTY
Gets @arg{property} for @arg{object}.
@end deffn

@anchor{fun-fl.problem-interior-coefficient-p}
@deffn Function INTERIOR-COEFFICIENT-P @var{PROBLEM} @var{COEFF}
@findex INTERIOR-COEFFICIENT-P
Tests, if @arg{coeff} is an interior coefficient of @arg{problem}.
@end deffn

@anchor{fun-fl.problem-interior-coefficients}
@deffn Function INTERIOR-COEFFICIENTS @var{PROBLEM}
@findex INTERIOR-COEFFICIENTS
Returns a list of possible interior coefficients for
@arg{problem}.
@end deffn

@anchor{fun-fl.problem-linear-p}
@deffn Function LINEAR-P @var{PROBLEM}
@findex LINEAR-P
Predicate determining if a problem is linear or nonlinear.
@end deffn

@anchor{fun-fl.problem-linearize}
@deffn Function LINEARIZE @var{PROBLEM} @var{SOLUTION}
@findex LINEARIZE
Linearize the nonlinear problem PROBLEM at the point
SOLUTION.  The result should be a linear problem.
@end deffn

@anchor{fun-fl.problem-lse}
@deffn Function LSE &REST @var{ARGS}
@findex LSE
Constructs a standard LSE.
@end deffn

@anchor{fun-fl.problem-map-coefficients}
@deffn Function MAP-COEFFICIENTS @var{FUNC} @var{COEFFS}
@findex MAP-COEFFICIENTS
Maps a given coefficient list @arg{coeffs} into a new coefficient list.
@arg{func} takes coefficient name and coefficient and returns two values
for new coefficient name and coefficient.  If the first value returned is
@code{NIL}, this coefficient is not collected.
@end deffn

@anchor{fun-fl.problem-mass}
@deffn Function MASS @var{EVP} @var{X}
@findex MASS
Evaluates the mass bilinear form for a generalized eigenvalue problem.
@end deffn

@anchor{fun-fl.problem-multiplicity}
@deffn Function MULTIPLICITY @var{<ANSATZ-SPACE>}
@findex MULTIPLICITY
We allow multiple vectors, for solving linear problems
in parallel.
@end deffn

@anchor{fun-fl.problem-nlse}
@deffn Function NLSE &REST @var{ARGS}
@findex NLSE
Constructs a standard NLSE.
@end deffn

@anchor{fun-fl.problem-nr-of-components}
@deffn Function NR-OF-COMPONENTS @var{MSFE}
@findex NR-OF-COMPONENTS
Returns the number of components for @arg{problem}.
@end deffn

@anchor{fun-fl.problem-required-fe-functions}
@deffn Function REQUIRED-FE-FUNCTIONS @var{COEFFS}
@findex REQUIRED-FE-FUNCTIONS
Returns a list of finite element functions required by the coefficients
in the property list @arg{coeffs}.
@end deffn

@anchor{fun-fl.problem-select-linear-solver}
@deffn Function SELECT-LINEAR-SOLVER @var{PROBLEM} @var{BLACKBOARD}
@findex SELECT-LINEAR-SOLVER
Selects a linear solver for OBJECT.  OBJECT is usually a
matrix or a linear problem with certain characteristics.
@end deffn

@anchor{fun-fl.problem-select-solver}
@deffn Function SELECT-SOLVER @var{PROBLEM} @var{BLACKBOARD}
@findex SELECT-SOLVER
Selects a solver for OBJECT.  OBJECT is usually a
problem with certain characteristics.
@end deffn

@anchor{fun-fl.problem-self-adjoint-p}
@deffn Function SELF-ADJOINT-P @var{PROBLEM}
@findex SELF-ADJOINT-P
Returns two values.  The first says if @arg{problem} is
self-adjoint, the second says if that value has really been checked.
@end deffn

@anchor{fun-fl.problem-solve}
@deffn Function SOLVE @var{BLACKBOARD} &OPTIONAL @var{DUMMY}
@findex SOLVE
Solve a problem specified on the blackboard.  Returns a
modified blackboard.  The returned blackboard is guaranteed to contain at
least the fields :solution and :status.  :status is one of the values
:success or :failure.

SOLVE can also be called as (SOLVE blackboard) and will then try to figure
out a suitable solver itself.
@end deffn

@anchor{fun-fl.problem-stationary-problem-class}
@deffn Function STATIONARY-PROBLEM-CLASS @var{TDP}
@findex STATIONARY-PROBLEM-CLASS
Finds the stationary pde problem for the time-dependent problem TDP.
@end deffn

@anchor{fun-fl.problem-zero-constraints}
@deffn Function ZERO-CONSTRAINTS @var{PROBLEM}
@findex ZERO-CONSTRAINTS
Returns a coefficient function which constrains all
system components to zero.
@end deffn

@node Package FL.CDR, Package FL.ELLSYS, Package FL.PROBLEM, Reference manual
@section Package FL.CDR

Defines convection-diffusion-reaction problems

@anchor{class-fl.cdr-<cdr-problem>}
@deftp Class <CDR-PROBLEM>
@tindex <CDR-PROBLEM>
Convection-diffusion-reaction problem.

Superclasses: <PDE-PROBLEM>
@end deftp

@anchor{fun-fl.cdr-bratu-problem}
@deffn Function BRATU-PROBLEM @var{DIM}
@findex BRATU-PROBLEM
Returns a linearization for the Bratu problem @math{-Delta u +e^u =0}.
@end deffn

@anchor{fun-fl.cdr-cdr-model-problem}
@deffn Function CDR-MODEL-PROBLEM @var{DOMAIN} &KEY (@var{DIFFUSION} @var{NIL} @var{DIFFUSION-P}) (@var{SOURCE} @var{NIL} @var{SOURCE-P}) (@var{DIRICHLET} @var{NIL} @var{DIRICHLET-P}) @var{GAMMA} @var{CONVECTION} @var{REACTION} @var{INITIAL} @var{EVP} @var{PROPERTIES}
@findex CDR-MODEL-PROBLEM
Generates a convection-diffusion-reaction model problem.  Defaults are
identity diffusion, right-hand-side equal 1, and Dirichlet zero boundary
conditions.  Ordinary function are converted into coefficient functions
depending on a global coordinate.  The first argument can be either a
domain or an integer n which is interpreted as the n-dimensional unit
cube.
@end deffn

@anchor{fun-fl.cdr-cdr-nonlinear-rhs-problem}
@deffn Function CDR-NONLINEAR-RHS-PROBLEM @var{DOMAIN} @var{F} &REST @var{ARGS} &KEY @var{SOURCE} @var{REACTION} &ALLOW-OTHER-KEYS
@findex CDR-NONLINEAR-RHS-PROBLEM
Returns the Newton linearization @math{-Delta u + F'(u) u = F'(u) u -
F(u)} for the nonlinear problem @math{-Delta u +F(u) =0}.
@end deffn

@node Package FL.ELLSYS, Package FL.ELASTICITY, Package FL.CDR, Reference manual
@section Package FL.ELLSYS

This package contains the problem definition of systems
of convection-diffusion-reaction equations.  The system is given in the
following form which is suited for a fixed-point iteration:

@math{-div(a(x,u_old,nabla u_old) nabla u)
 - div(b(x,u_old,nabla u_old) u) +
 + c(x,u_old,nabla u_old) u
= f(x,u_old, nabla u_old) 
- div(g(x,u_old, nabla u_old))
- div(a(x,u_old,nabla u_old) h(x,u_old, nabla u_old)) }

where @math{u:G to R^N}.  Note that the last two terms are introduced in
the variational formulation and imply a natural Neumann boundary condition
@math{derivative{u}{n} = (g+a h) cdot n} at boundaries where no Dirichlet
constraints are posed.

@anchor{class-fl.ellsys-<ellsys-problem>}
@deftp Class <ELLSYS-PROBLEM>
@tindex <ELLSYS-PROBLEM>
Systems of convection-diffusion-reaction equations.  The
coefficients should be vector-valued functions in this case.

Superclasses: <PDE-PROBLEM>

Direct slots:
@itemize
@item NR-OF-COMPONENTS: NIL
@end itemize
@end deftp

@anchor{fun-fl.ellsys-ellsys-model-problem}
@deffn Function ELLSYS-MODEL-PROBLEM @var{DOMAIN} @var{NCOMPS} &KEY @var{A} @var{B} @var{C} @var{F} @var{G} @var{H} @var{DIRICHLET} @var{INITIAL} @var{EVP} @var{PROPERTIES} @var{DERIVED-CLASS}
@findex ELLSYS-MODEL-PROBLEM
Generates a rather general elliptic problem on the given domain.
@end deffn

@anchor{fun-fl.ellsys-isotropic-diffusion}
@deffn Function ISOTROPIC-DIFFUSION @var{DIM} @var{VALUES}
@findex ISOTROPIC-DIFFUSION
Returns a sparse diagonal diffusion tensor with isotropic diffusion in
each component.  @arg{value} should be a vector or a number and contains
the amount of diffusion in each component.
@end deffn

@anchor{fun-fl.ellsys-nr-of-components}
@deffn Function NR-OF-COMPONENTS @var{MSFE}
@findex NR-OF-COMPONENTS
Returns the number of components for @arg{problem}.
@end deffn

@node Package FL.ELASTICITY, Package FL.NAVIER-STOKES, Package FL.ELLSYS, Reference manual
@section Package FL.ELASTICITY

Defines elasticity problems.

@anchor{class-fl.elasticity-<elasticity-problem>}
@deftp Class <ELASTICITY-PROBLEM>
@tindex <ELASTICITY-PROBLEM>
An elasticity problem is a special instance of an
elliptic sytems.

Superclasses: <ELLSYS-PROBLEM>
@end deftp

@anchor{fun-fl.elasticity-check-elasticity-tensor}
@deffn Function CHECK-ELASTICITY-TENSOR @var{TENSOR} @var{DIM} &OPTIONAL (@var{THRESHOLD} 1.e-6)
@findex CHECK-ELASTICITY-TENSOR
Checks the symmetries in the elasticity tensor.
@end deffn

@anchor{fun-fl.elasticity-isotropic-elasticity-tensor}
@deffn Function ISOTROPIC-ELASTICITY-TENSOR &KEY @var{DIM} @var{LAMBDA} @var{MU}
@findex ISOTROPIC-ELASTICITY-TENSOR
Returns the tensor corresponding to the Lam'e constants @math{lambda}
and @math{mu}, i.e.:

@math{A_{ij}^{kl} = lambda delta_{ik} delta_{jl} + mu (delta_{ij}
delta_{kl} + delta_{kj} delta_{il})}.
@end deffn

@node Package FL.NAVIER-STOKES, Package FL.CDRSYS, Package FL.ELASTICITY, Reference manual
@section Package FL.NAVIER-STOKES

Defines the class of Navier-Stokes problems.

@anchor{class-fl.navier-stokes-<navier-stokes-problem>}
@deftp Class <NAVIER-STOKES-PROBLEM>
@tindex <NAVIER-STOKES-PROBLEM>
Navier-Stokes problem.

Superclasses: <PDE-PROBLEM>
@end deftp

@node Package FL.CDRSYS, Package FL.DISCRETIZATION, Package FL.NAVIER-STOKES, Reference manual
@section Package FL.CDRSYS

This package contains some definitions for systems of
convection-diffusion-reaction equations.  These are a special case of
general elliptic systems defined in @path{ellsys.lisp}.

@anchor{class-fl.cdrsys-<cdrsys-problem>}
@deftp Class <CDRSYS-PROBLEM>
@tindex <CDRSYS-PROBLEM>
Problem class for a system of
convection-diffusion-reaction equations.

Superclasses: <ELLSYS-PROBLEM>
@end deftp

@anchor{fun-fl.cdrsys-cdrsys-model-problem}
@deffn Function CDRSYS-MODEL-PROBLEM @var{DOMAIN} @var{NCOMPS} &KEY (@var{DIFFUSION} @var{NIL} @var{DIFFUSION-P}) (@var{SOURCE} @var{NIL} @var{SOURCE-P}) (@var{DIRICHLET} @var{NIL} @var{DIRICHLET-P}) @var{CONVECTION} @var{REACTION} @var{INITIAL} @var{EVP} @var{PROPERTIES}
@findex CDRSYS-MODEL-PROBLEM
Generates a system of convection-diffusion-reaction equations.  Defaults
are identity diffusion, right-hand-side equal 1, and Dirichlet zero
boundary conditions for each component.  Ordinary function are converted
into coefficient functions depending on a global coordinate.  The first
argument can be either a domain or an integer n which is interpreted as the
n-dimensional unit cube.
@end deffn

@node Package FL.DISCRETIZATION, Package FL.CDR-FE, Package FL.CDRSYS, Reference manual
@section Package FL.DISCRETIZATION

The @package{FL.DISCRETIZATION} package defines
@class{<discretization>} as an abstract class and
@class{<fe-discretization>} as a concrete derived class.

The key for local assembly is given by the generic function
@function{get-fe}, which yields a suitable finite element for a given cell.
The value of @function{get-fe} is a class @class{<fe>} for scalar problems
or @class{<vector-fe>} for vector-valued problems which contains
information on base functions and node functionals.  Another generic
function @function{quadrature-rule} computes memoized quadrature rules for
those finite elements.

Obviously, also non-standard finite element discretizations like hp-methods
would fit into this scheme.  The key for local assembly is given by the
generic function @function{get-fe}, which yields a suitable finite element
for a given cell.  The value of @function{get-fe} is a class @class{<fe>}
for scalar problems or @class{<vector-fe>} for vector-valued problems which
contains information on base functions and node functionals.  Another
generic function @function{quadrature-rule} computes memoized quadrature
rules for those finite elements.

The file @path{lagrange.lisp} provides Lagrange finite elements of
arbitrary order.  The evaluation points for the node functionals may be
chosen either uniformly distributed or at the Gauss-Lobatto points.  The
latter choice of points yields better stability properties but is
restricted to cube meshes.  Also functions for constructing cell mappings
by pointwise evaluation of the domain boundary are provided here, which may
be used to construct isoparametric domain approximations.

In the file @path{fedisc.lisp}, the function @function{fe-discretize} is
defined.  This function performs the standard steps for finite element
discretization: interior assembly, assembly and elimination of hanging-node
and essential-boundary constraints.  It works on a blackboard as explained
in Section @ref{Blackboards} and can reuse already available matrix-vector
structure.  There is a somewhat less flexible interface provided by the
funtion @function{discretize-globally} which calls
@function{fe-discretize}.

In the files @path{cdr-fe.lisp}, @path{elasticity-fe.lisp} and
@path{navier-stokes.lisp} one can find methods for local assembly for the
different problems.  They are defined in own packages which use both the
package @package{FL.DISCRETIZATION} and the package for the particular
problem.

@anchor{var-fl.discretization-*suggested-discretization-order*}
@defvr Variable *SUGGESTED-DISCRETIZATION-ORDER*
@vindex *SUGGESTED-DISCRETIZATION-ORDER*
The suggested order of discretization.  In non-nil, this value should be
taken into account by methods to @arg{select-discretization}.
@end defvr

@anchor{class-fl.discretization-<ansatz-space-automorphism>}
@deftp Class <ANSATZ-SPACE-AUTOMORPHISM>
@tindex <ANSATZ-SPACE-AUTOMORPHISM>
A sparse-matrix which is interpreted as an automorphism
for an ansatz-space.  Should probably be made a specialization of
ansatz-space-morphism.

Superclasses: <ANSATZ-SPACE-OBJECT> <SPARSE-MATRIX>
@end deftp

@anchor{class-fl.discretization-<ansatz-space-morphism>}
@deftp Class <ANSATZ-SPACE-MORPHISM>
@tindex <ANSATZ-SPACE-MORPHISM>
A sparse-matrix which is interpreted as an morphism
between two ansatz-spaces.

Superclasses: <SPARSE-MATRIX>

Direct slots:
@itemize
@item DOMAIN-ANSATZ-SPACE: NIL
@item IMAGE-ANSATZ-SPACE: NIL
@end itemize
@end deftp

@anchor{class-fl.discretization-<ansatz-space-vector>}
@deftp Class <ANSATZ-SPACE-VECTOR>
@tindex <ANSATZ-SPACE-VECTOR>
A sparse vector which is interpreted as the ansatz-space
for a specific fe-class on a given mesh.

Superclasses: <ANSATZ-SPACE-OBJECT> <SPARSE-VECTOR>
@end deftp

@anchor{class-fl.discretization-<ansatz-space>}
@deftp Class <ANSATZ-SPACE>
@tindex <ANSATZ-SPACE>
A finite element ansatz space is determined by finite
element discretization, mesh and problem.  The constraints are stored in
the slot @var{properties}.

Superclasses: PROPERTY-MIXIN

Direct slots:
@itemize
@item FE-CLASS: The finite element class for this ansatz space.
@item PROBLEM: The proplem for this ansatz space which determines essential constraints.
@item MESH: The mesh for this ansatz space which determines hanging-node constraints.
@item MULTIPLICITY: Should be a copy of problem multiplicity.
@end itemize
@end deftp

@anchor{class-fl.discretization-<cell-fe-discretization>}
@deftp Class <CELL-FE-DISCRETIZATION>
@tindex <CELL-FE-DISCRETIZATION>
Finite element discretization where the finite elements
can differ from cell to cell.  Especially, hp-FEM are included.

Superclasses: <FE-DISCRETIZATION>

Direct slots:
@itemize
@item CELL->FE: A function mapping a cell to a finite element.
@end itemize
@end deftp

@anchor{class-fl.discretization-<discretization>}
@deftp Class <DISCRETIZATION>
@tindex <DISCRETIZATION>
Discretization base class.
@end deftp

@anchor{class-fl.discretization-<fe-discretization>}
@deftp Class <FE-DISCRETIZATION>
@tindex <FE-DISCRETIZATION>
FE discretization base class.

Superclasses: <DISCRETIZATION>
@end deftp

@anchor{class-fl.discretization-<scalar-fe-discretization>}
@deftp Class <SCALAR-FE-DISCRETIZATION>
@tindex <SCALAR-FE-DISCRETIZATION>
Class for scalar fe discretizations.

Superclasses: <STANDARD-FE-DISCRETIZATION>

Direct slots:
@itemize
@item ORDER: NIL
@end itemize
@end deftp

@anchor{class-fl.discretization-<scalar-fe>}
@deftp Class <SCALAR-FE>
@tindex <SCALAR-FE>
A finite element <fe> is given for each reference cell,
e.g. <2-simplex>.  dofs are the degrees of freedom associated with the
cell, basis is the dual basis to dofs in some polynomial space.
subcell-ndofs is the number of ndofs on each subcell.  subcell-indices is a
list of indices for all subcells with dofs.  Usually, the <scalar-fe> will occur
as values of a procedure or as values in a hash-table with the reference
cells as keys.

Superclasses: <FE>

Direct slots:
@itemize
@item DOFS: NIL
@item BASIS: NIL
@item ORDER: NIL
@end itemize
@end deftp

@anchor{class-fl.discretization-<standard-fe-discretization>}
@deftp Class <STANDARD-FE-DISCRETIZATION>
@tindex <STANDARD-FE-DISCRETIZATION>
Finite element discretization where the finite element
depends only on the type of the reference cell.

Superclasses: <CELL-FE-DISCRETIZATION>
@end deftp

@anchor{class-fl.discretization-<vector-fe-discretization>}
@deftp Class <VECTOR-FE-DISCRETIZATION>
@tindex <VECTOR-FE-DISCRETIZATION>
Vector FE discretization class.

Superclasses: <STANDARD-FE-DISCRETIZATION>

Direct slots:
@itemize
@item COMPONENTS: NIL
@end itemize
@end deftp

@anchor{class-fl.discretization-<vector-fe>}
@deftp Class <VECTOR-FE>
@tindex <VECTOR-FE>
Finite element for vector functions.  Components is a
vector of scalar finite elements.  Local-offset is an array of the same
length which contains the offsets for each component in the local
discretization vector.  Subcell-offsets is an array consisting of arrays
which yield such an offset for every subcell.

Superclasses: <FE>

Direct slots:
@itemize
@item COMPONENTS: NIL
@item DOFS: NIL
@end itemize
@end deftp

@anchor{fun-fl.discretization-assemble-interior}
@deffn Function ASSEMBLE-INTERIOR @var{ANSATZ-SPACE} &KEY @var{LEVEL} (@var{WHERE} @var{SURFACE}) @var{MATRIX} @var{RHS} (@var{MASS-FACTOR} 0.0) (@var{STIFFNESS-FACTOR} 1.0)
@findex ASSEMBLE-INTERIOR
Assemble the interior, i.e. ignore constraints arising from boundaries
and hanging nodes.  Discretization is done using the ansatz space
@arg{ansatz-space} on level @arg{level}.  The level argument will usually
be @code{NIL} when performing a global assembly, and be equal to some
number when assembling coarse level matrices for multigrid.  The argument
@arg{where} is a flag indicating where assembly is to be done.  It should
be one of the keywords @code{:surface}, @code{:refined}, @code{:all}.  The
arguments @arg{matrix}, @arg{rhs} should contain vectors/matrices where the
local assembly is accumulated.  The numbers @arg{mass-factor} and
@arg{stiffness-factor} determine weights for mass and stiffness matrix
which is used when solving time-dependent and eigenvalue problems.
Boundary conditions and constraints are not taken into account within this
routine.

In general, this function does most of the assembly work.  Other steps like
handling constraints are intricate, but usually of lower complexity.
@end deffn

@anchor{fun-fl.discretization-cell->matrix-value-blocks}
@deffn Function CELL->MATRIX-VALUE-BLOCKS @var{CELL} @var{FE} @var{SMAT}
@findex CELL->MATRIX-VALUE-BLOCKS
Gets all value-blocks associated with the local
stiffness matrix.  If necessary, those value-blocks are generated.
@end deffn

@anchor{fun-fl.discretization-cell-key}
@deffn Function CELL-KEY @var{CELL} @var{MESH}
@findex CELL-KEY
If cell is identified, its identification is the key.
@end deffn

@anchor{fun-fl.discretization-choose-start-vector}
@deffn Function CHOOSE-START-VECTOR @var{AS} @var{PROBLEM}
@findex CHOOSE-START-VECTOR
Choose a reasonable start vector for some strategy.
@end deffn

@anchor{fun-fl.discretization-constrained-interpolation-matrix}
@deffn Function CONSTRAINED-INTERPOLATION-MATRIX @var{ANSATZ-SPACE} &KEY @var{LEVEL} @var{WHERE} @var{IMAT} (@var{TYPE} @var{LOCAL})
@findex CONSTRAINED-INTERPOLATION-MATRIX
The multigrid algorithm needs an interpolation which satisfies the
constraints like essential or periodic boundary conditions.
@end deffn

@anchor{fun-fl.discretization-construct-coeff-input}
@deffn Function CONSTRUCT-COEFF-INPUT @var{CELL} @var{GLOBAL} @var{DPHI} @var{VALUES} @var{GRADIENTS} @var{FE-PARAMETERS}
@findex CONSTRUCT-COEFF-INPUT
Constructs a coefficient input list from FE data @arg{cell} is the cell,
@arg{global} is the global coordinate of the integration point,
@arg{values} and @arg{gradients} the values and gradients of the shape
functions at the ip, and @arg{fe-parameters} are the corresponding data of
fe-functions to be evalutated.
@end deffn

@anchor{fun-fl.discretization-discretization-order}
@deffn Function DISCRETIZATION-ORDER @var{VECFE-DISC}
@findex DISCRETIZATION-ORDER
Returns the order of the discretization.
@end deffn

@anchor{fun-fl.discretization-discretize}
@deffn Function DISCRETIZE @var{FEDISC} @var{PROBLEM} @var{BLACKBOARD}
@findex DISCRETIZE
Calculates matrix and right-hand side for the
@var{discretization} and the @var{problem}.  Further parameters are
provided inside the @var{blackboard}.
@end deffn

@anchor{fun-fl.discretization-discretize-globally}
@deffn Function DISCRETIZE-GLOBALLY @var{PROBLEM} @var{H-MESH} @var{FE-CLASS}
@findex DISCRETIZE-GLOBALLY
Discretize @arg{problem} on the hierarchical mesh @arg{h-mesh} using
finite elments given by @arg{fe-class}.
@end deffn

@anchor{fun-fl.discretization-discretize-locally}
@deffn Function DISCRETIZE-LOCALLY @var{MSP} @var{COEFFS} @var{FE} @var{QRULE} @var{GEOMETRY} &REST @var{ARGS} &ALLOW-OTHER-KEYS
@findex DISCRETIZE-LOCALLY
Computes a local stiffness matrix and right-hand side.
The algorithm will usually work as follows:

@enumerate
@item Get coefficient functions for the patch of the cell.
@item Compute geometry information for all ips (values and gradients of the shape functions).
@item Loop over integration points ip:
  @enumerate
    @item If necessary, compute input for coefficient functions.
          This input may contain values of finite element function in the
          property list @arg{fe-parameters}.
    @item Evaluate coefficient functions at ips.
    @item Add the contributions for matrix and right-hand side to @arg{local-mat} and @arg{local-rhs}.
  @end enumerate
@end enumerate

@arg{mass-factor} and @arg{stiffness-factor} are weights for mass and
stiffness matrix which are used for solving eigenvalue and time-dependent
problems.  If @arg{local-u} and @arg{local-v} are set, then
@arg{local-v}*@arg{local-mat}*@arg{local-u} and
@arg{local-v}*@arg{local-rhs} is computed.  This feature may be used later
on for implementing matrixless computations.
@end deffn

@anchor{class-fl.discretization-dof}
@deftp Class DOF
@tindex DOF
Degree of freedom in a finite element.  It is defined as a functional
defined by integration over a sub-cell or by evaluation at a local
coordinate of a sub-cell of a reference cell. 

Direct slots:
@itemize
@item INDEX: index of the dof in the cell-dof array
@item SUBCELL-INDEX: index of the reference subcell on which the dof is defined
@item IN-VBLOCK-INDEX: index of the dof in the subcell vblock
@item SUBCELL: reference subcell on which the dof is defined
@item COORD: local coordinate of the dof in the reference subcell
@item GCOORD: global coordinate of the dof on the reference cell
@item FUNCTIONAL: a functional for functions defined on the reference cell
@end itemize
@end deftp

@anchor{fun-fl.discretization-eliminate-constraints}
@deffn Function ELIMINATE-CONSTRAINTS @var{MAT} @var{RHS} @var{CONSTRAINTS-P} @var{CONSTRAINTS-Q} @var{CONSTRAINTS-R} &KEY @var{ASSEMBLE-LOCALLY} @var{INCLUDE-CONSTRAINTS}
@findex ELIMINATE-CONSTRAINTS
Constraints are given by an equation:  P x = Q x + r

Here x in V, P is an orthogonal projection on a subspace V_P of V, Q maps
some other space which may have nonempty intersection with V_P to V_P.
With S we denote the mapping Id-P.  This function returns the matrix for a
Galerkin method on the constrained space.  It is used for treating hanging
nodes and essential boundary conditions.  When assemble-locally is t the
sparse structure of mat is used instead of the sparse structure of the
hanging node interface.  When include-constraints is non-nil, the
constraints are included in matrix and rhs.
@end deffn

@anchor{fun-fl.discretization-essential-boundary-constraints}
@deffn Function ESSENTIAL-BOUNDARY-CONSTRAINTS @var{MSP} @var{ANSATZ-SPACE} &REST @var{ARGS} &KEY @var{LEVEL} @var{WHERE} &ALLOW-OTHER-KEYS
@findex ESSENTIAL-BOUNDARY-CONSTRAINTS
Computation of essential constraints.  Should probably
be incorporated into the ansatz-space definition.
@end deffn

@anchor{fun-fl.discretization-fe-cell-geometry}
@deffn Function FE-CELL-GEOMETRY @var{CELL} @var{SAMPLE-POINTS} &KEY @var{WEIGHTS} @var{METRIC} @var{VOLUME} &AUX (@var{N} (@var{LENGTH} @var{SAMPLE-POINTS}))
@findex FE-CELL-GEOMETRY
Collects cell geometry information at @arg{sample-points} inside a
property list.
@end deffn

@anchor{fun-fl.discretization-fe-discretize}
@deffn Function FE-DISCRETIZE @var{BLACKBOARD}
@findex FE-DISCRETIZE
Finite element discretization for an ansatz space provided on the
blackboard.
@end deffn

@anchor{fun-fl.discretization-gauss-rule}
@deffn Function GAUSS-RULE @var{FACTOR-DIMS} @var{S}
@findex GAUSS-RULE
Returns an s-point Gauss integration rule.
@end deffn

@anchor{fun-fl.discretization-get-fe}
@deffn Function GET-FE @var{DISC} @var{CELL}
@findex GET-FE
Returns the finite element for the given discretization
and reference cell.
@end deffn

@anchor{fun-fl.discretization-get-local-from-global-mat}
@deffn Function GET-LOCAL-FROM-GLOBAL-MAT @var{CELL} @var{FE} @var{SMAT}
@findex GET-LOCAL-FROM-GLOBAL-MAT
Maps the region in the global stiffness matrix
determined by cell and fe to a local matrix array.
@end deffn

@anchor{fun-fl.discretization-get-local-from-global-vec}
@deffn Function GET-LOCAL-FROM-GLOBAL-VEC @var{CELL} @var{FE} @var{SVEC}
@findex GET-LOCAL-FROM-GLOBAL-VEC
Maps the region in global-vec determined by cell and fe
to a local vector.
@end deffn

@anchor{fun-fl.discretization-increment-global-by-local-mat}
@deffn Function INCREMENT-GLOBAL-BY-LOCAL-MAT @var{CELL} @var{FE} @var{SMAT} @var{LOCAL-MAT}
@findex INCREMENT-GLOBAL-BY-LOCAL-MAT
Increments the region in global-mat determined by cell
and fe to the values of local-mat.
@end deffn

@anchor{fun-fl.discretization-increment-global-by-local-vec}
@deffn Function INCREMENT-GLOBAL-BY-LOCAL-VEC @var{CELL} @var{FE} @var{SVEC} @var{LOCAL-VEC}
@findex INCREMENT-GLOBAL-BY-LOCAL-VEC
Increments the region in global-vec determined by cell
and fe to the values of the local vector array.
@end deffn

@anchor{fun-fl.discretization-interpolation-matrix}
@deffn Function INTERPOLATION-MATRIX @var{ANSATZ-SPACE} &KEY @var{LEVEL} @var{REGION} @var{IMAT} (@var{TYPE} @var{*INTERPOLATION-TYPE*})
@findex INTERPOLATION-MATRIX
On each cell of the skeleton @arg{region} or on all cells of level
@arg{level} of the mesh of @arg{ansatz-space}, a local interpolation matrix
is collected into an interpolation matrix.  @arg{type} is the interpolation
type having a default value @var{*interpolation-type*}.
@end deffn

@anchor{fun-fl.discretization-ip-gradients}
@deffn Function IP-GRADIENTS @var{FE} @var{QRULE}
@findex IP-GRADIENTS
Returns a vector of local gradient matrices for
@arg{obj} which may be a vector of integration points or a quadrature rule.
Note that this function is memoized using an :around method.
@end deffn

@anchor{fun-fl.discretization-ip-values}
@deffn Function IP-VALUES @var{FE} @var{QRULE}
@findex IP-VALUES
Returns a vector of ip values for @arg{obj} which may
be a vector of integration points or a quadrature rule.  Note that this
function is memoized using an :around method.
@end deffn

@anchor{fun-fl.discretization-lagrange-fe}
@deffn Function LAGRANGE-FE @var{ORDER} &KEY @var{NR-COMPS} (@var{TYPE} @var{UNIFORM})
@findex LAGRANGE-FE
Constructor for Lagrange fe.
@end deffn

@anchor{fun-fl.discretization-lagrange-mapping}
@deffn Function LAGRANGE-MAPPING @var{ORDER} &OPTIONAL (@var{TYPE} @var{UNIFORM})
@findex LAGRANGE-MAPPING
Returns a function which maps a cell by a polynomial which is obtained
by interpolating the boundary map via Lagrange interpolation.
@end deffn

@anchor{fun-fl.discretization-local-imatrix}
@deffn Function LOCAL-IMATRIX @var{RULE} @var{FE} &OPTIONAL (@var{TYPE} @var{LOCAL})
@findex LOCAL-IMATRIX
Memoized call of compute-local-imatrix.
@end deffn

@anchor{fun-fl.discretization-local-offset}
@deffn Function LOCAL-OFFSET @var{FE}
@findex LOCAL-OFFSET
Reader for the local-offset of this component in the local cell vector.
@end deffn

@anchor{fun-fl.discretization-local-pmatrix}
@deffn Function LOCAL-PMATRIX @var{RULE} @var{FE}
@findex LOCAL-PMATRIX
Memoized call of compute-local-pmatrix.
@end deffn

@anchor{fun-fl.discretization-local-transfer-matrix}
@deffn Function LOCAL-TRANSFER-MATRIX @var{FE-FROM} @var{FE-TO}
@findex LOCAL-TRANSFER-MATRIX
Computes a local transfer matrix between different FE spaces.
@end deffn

@anchor{fun-fl.discretization-make-ansatz-space-vector}
@deffn Function MAKE-ANSATZ-SPACE-VECTOR @var{AS}
@findex MAKE-ANSATZ-SPACE-VECTOR
Deprecated.
@end deffn

@anchor{fun-fl.discretization-make-fe-ansatz-space}
@deffn Function MAKE-FE-ANSATZ-SPACE @var{FE-CLASS} @var{PROBLEM} @var{MESH} &OPTIONAL @var{MULTIPLICITY}
@findex MAKE-FE-ANSATZ-SPACE
<ansatz-space> constructor.  Somewhat shorter than with MAKE-INSTANCE.
@end deffn

@anchor{fun-fl.discretization-nr-of-components}
@deffn Function NR-OF-COMPONENTS @var{MSFE}
@findex NR-OF-COMPONENTS
Returns the number of components for @arg{problem}.
@end deffn

@anchor{fun-fl.discretization-projection-matrix}
@deffn Function PROJECTION-MATRIX @var{ANSATZ-SPACE} &KEY @var{LEVEL} @var{REGION} @var{PMAT}
@findex PROJECTION-MATRIX
The algorithm works as follows: On each cell of the provided cell list
or the whole refinement a local projection matrix computed on the reference
finite element is copied into the global projection matrix.
@end deffn

@anchor{fun-fl.discretization-quadrature-rule}
@deffn Function QUADRATURE-RULE @var{FE}
@findex QUADRATURE-RULE
Computes the quadrature rule to be used for the finite
element @arg{fe}.
@end deffn

@anchor{fun-fl.discretization-random-ansatz-space-vector}
@deffn Function RANDOM-ANSATZ-SPACE-VECTOR @var{ANSATZ-SPACE}
@findex RANDOM-ANSATZ-SPACE-VECTOR
Returns a ansatz space vector for @arg{ansatz-space} filled with random
entries.  Essential constraints are satisfied.
@end deffn

@anchor{fun-fl.discretization-representative}
@deffn Function REPRESENTATIVE @var{OBJ}
@findex REPRESENTATIVE
Returns a representative for this object.
@end deffn

@anchor{fun-fl.discretization-select-discretization}
@deffn Function SELECT-DISCRETIZATION @var{MSP} @var{BLACKBOARD}
@findex SELECT-DISCRETIZATION
Select a discretization for the given @var{problem}
depending on the parameters on the @var{blackboard}.
@end deffn

@anchor{fun-fl.discretization-set-global-to-local-mat}
@deffn Function SET-GLOBAL-TO-LOCAL-MAT @var{CELL} @var{FE} @var{SMAT} @var{LOCAL-MAT}
@findex SET-GLOBAL-TO-LOCAL-MAT
Sets the region in global-mat determined by cell and fe
to the values of the local matrix array.
@end deffn

@anchor{fun-fl.discretization-set-global-to-local-vec}
@deffn Function SET-GLOBAL-TO-LOCAL-VEC @var{CELL} @var{FE} @var{SVEC} @var{LOCAL-VEC}
@findex SET-GLOBAL-TO-LOCAL-VEC
Sets the region in global-vec determined by cell and fe
to the values of the local vector array.
@end deffn

@anchor{fun-fl.discretization-subcell-offsets}
@deffn Function SUBCELL-OFFSETS @var{FE}
@findex SUBCELL-OFFSETS
Reader for subcell-offsets.  This is an array of length the number of
components.  Each component is an array giving the offset of this component
in a sparse vector value block corresponding to the subcell.
@end deffn

@anchor{fun-fl.discretization-transfer-matrix}
@deffn Function TRANSFER-MATRIX @var{DOMAIN-AS} @var{IMAGE-AS} &KEY @var{NO-SLAVES}
@findex TRANSFER-MATRIX
Builds a transfer matrix from domain-as to image-as.
@end deffn

@node Package FL.CDR-FE, Package FL.ELLSYS-FE, Package FL.DISCRETIZATION, Reference manual
@section Package FL.CDR-FE

This package specializes the finite element
discretization for convection-diffusion-reaction problems.

It can handle the following equation:

@math{- partial_i (K_{ij} (partial_j u + g_j) + partial_i (c_i u) + r u = f}

Here, @math{K} is the diffusion tensor, @math{c} is the convection vector,
@math{r} is the reaction coefficient, @math{f} is the source function, and
@math{g} is a distributional source.

@node Package FL.ELLSYS-FE, Package FL.ELASTICITY-FE, Package FL.CDR-FE, Reference manual
@section Package FL.ELLSYS-FE

Finite element discretization of an elliptic system, see
the description in the ELLSYS package.  The result is a local matrix A and
local rhs b.  They will usually depend on u_old which is stored in the
solution vector.

This discretization is a unification of scalar and elasticity
discretization, and might replace those later on.

@node Package FL.ELASTICITY-FE, Package FL.NAVIER-STOKES-FE, Package FL.ELLSYS-FE, Reference manual
@section Package FL.ELASTICITY-FE

This package specializes the discretization for systems
of elasticity.  Since elasticity is a special case of elliptic systems
which are handled in @path{ellsys-fe.lisp}, not much remains to do.

@node Package FL.NAVIER-STOKES-FE, Package FL.ITERATION, Package FL.ELASTICITY-FE, Reference manual
@section Package FL.NAVIER-STOKES-FE

This package specializes the finite element
discretization for Navier-Stokes problems.  Up to now, we use only
generalized Taylor hood elements.

@anchor{fun-fl.navier-stokes-fe-navier-stokes-lagrange-fe}
@deffn Function NAVIER-STOKES-LAGRANGE-FE @var{ORDER} @var{DIM} @var{DELTA}
@findex NAVIER-STOKES-LAGRANGE-FE
Returns a generalized Tylor-Hood element @math{(Q^{k+delta})^d/Q^k} of
order @math{k} in dimension @math{d}.
@end deffn

@node Package FL.ITERATION, Package FL.MULTIGRID, Package FL.NAVIER-STOKES-FE, Reference manual
@section Package FL.ITERATION

The @package{FL.ITERATION} package includes the
definition for the abstract classes @class{<solver>},
@class{<iterative-solver>}, as well as the generic functions
@function{iterate} and @function{solve} which constitutes the interface for
linear and non-linear solving.  Both functions work on a blackboard which
is passed together with the iteration used as argument.

Several instances of iterative solvers are implemented, e.g. Gauss-Seidel,
SOR, ILU (in @file{linit.lisp}) and CG (in @file{krylow.lisp}).  A larger
block of code is contained in a separate package @package{FL.MULTIGRID} and
contains the multigrid iteration.  From this class, an algebraic multigrid
iteration is derived in @file{amg.lisp} and a geometric multigrid iteration
in a separate file @file{geomg.lisp} and package @package{FL.GEOMG}.

@anchor{var-fl.iteration-*discrete-iterative-solver-observe*}
@defvr Variable *DISCRETE-ITERATIVE-SOLVER-OBSERVE*
@vindex *DISCRETE-ITERATIVE-SOLVER-OBSERVE*
Standard observe quantities for iterative solvers.
@end defvr

@anchor{var-fl.iteration-*output-depth*}
@defvr Variable *OUTPUT-DEPTH*
@vindex *OUTPUT-DEPTH*
Maximum iteration depth for which status output is done.
@end defvr

@anchor{var-fl.iteration-*time-observe*}
@defvr Variable *TIME-OBSERVE*
@vindex *TIME-OBSERVE*
Observe time during an iteration.  This should be used as element in the
observe list of an iteration.
@end defvr

@anchor{class-fl.iteration-<bi-cgstab>}
@deftp Class <BI-CGSTAB>
@tindex <BI-CGSTAB>
Preconditioned Bi-CGStab iteration

Superclasses: <LINEAR-ITERATION>

Direct slots:
@itemize
@item PRECONDITIONER: NIL
@end itemize
@end deftp

@anchor{class-fl.iteration-<block-iteration>}
@deftp Class <BLOCK-ITERATION>
@tindex <BLOCK-ITERATION>
Subspace correction scheme generated by collecting
overlapping blocks of unknowns.

Superclasses: <LINEAR-ITERATION>

Direct slots:
@itemize
@item INNER-ITERATION: Iteration which is used to solve for each block.
@item ORDERING: NIL
@item STORE-P: T if diagonal can be stored.
@end itemize
@end deftp

@anchor{class-fl.iteration-<cg>}
@deftp Class <CG>
@tindex <CG>
Preconditioned conjugate gradient iteration

Superclasses: <LINEAR-ITERATION>

Direct slots:
@itemize
@item PRECONDITIONER: NIL
@end itemize
@end deftp

@anchor{class-fl.iteration-<custom-psc>}
@deftp Class <CUSTOM-PSC>
@tindex <CUSTOM-PSC>
PSC with custom BLOCK-SETUP function slot.

Superclasses: <SETUP-BLOCKS-MIXIN> <PSC>
@end deftp

@anchor{class-fl.iteration-<custom-ssc>}
@deftp Class <CUSTOM-SSC>
@tindex <CUSTOM-SSC>
SSC with custom BLOCK-SETUP function slot.

Superclasses: <SETUP-BLOCKS-MIXIN> <SSC>
@end deftp

@anchor{class-fl.iteration-<function>}
@deftp Class <FUNCTION>
@tindex <FUNCTION>
The <function> class is an abstract class for a general
function.  This function will usually accept vector arguments, the dimensions of
domain and image are fixed when defining the function. If the function is
differentiable, the gradient matrix can be obtained by evaluating the gradient
slot.

Direct slots:
@itemize
@item DOMAIN-DIMENSION: NIL
@item IMAGE-DIMENSION: NIL
@end itemize
@end deftp

@anchor{class-fl.iteration-<gauss-seidel>}
@deftp Class <GAUSS-SEIDEL>
@tindex <GAUSS-SEIDEL>
The Gauss-Seidel iteration is SOR with omega=1.

Superclasses: <SOR>
@end deftp

@anchor{class-fl.iteration-<gradient-method>}
@deftp Class <GRADIENT-METHOD>
@tindex <GRADIENT-METHOD>
Gradient-method.  Better use CG.

Superclasses: <LINEAR-ITERATION>
@end deftp

@anchor{class-fl.iteration-<ilu>}
@deftp Class <ILU>
@tindex <ILU>
Incomplete LU iteration.  omega is the modification
parameter, eta is the diagonal enhancement.

Superclasses: <LINEAR-ITERATION>

Direct slots:
@itemize
@item OMEGA: NIL
@item ETA: NIL
@item ORDERING: NIL
@end itemize
@end deftp

@anchor{class-fl.iteration-<iteration>}
@deftp Class <ITERATION>
@tindex <ITERATION>
The iteration base class.

Direct slots:
@itemize
@item OBSERVE: The initform depends on the subclass.
@item OUTPUT: A boolean indicating if output is to be done.
@item SUCCESS-IF: A form specifying a success criterion.
@item FAILURE-IF: A form specifying a failure criterion.
@item START-TIME: Start time of the iteration.
@item SUCCESS-IF-FN: Compiled success-if form.
@item FAILURE-IF-FN: Compiled failure-if form.
@end itemize
@end deftp

@anchor{class-fl.iteration-<iterative-solver>}
@deftp Class <ITERATIVE-SOLVER>
@tindex <ITERATIVE-SOLVER>
Base class of all iterative solvers and solution
strategies.

Superclasses: <ITERATION> <SOLVER>
@end deftp

@anchor{class-fl.iteration-<iterator>}
@deftp Class <ITERATOR>
@tindex <ITERATOR>
An <iterator> object contains functions doing iteration
work or flags indicating which work has or has not to be done for calling
that iterator.  It is generated by the generic function make-iterator.

Direct slots:
@itemize
@item MATRIX: The matrix on which the iterator is working.
@item INITIALIZE: NIL or an initialization function which is called with the
matrix as argument.
@item ITERATE: A function of
the arguments solution, rhs, and residual which performs an update step.
@item RESIDUAL-BEFORE: T if the
residual has to be up-to-date before the iteration step.
@item RESIDUAL-AFTER: T if the
residual is updated through the iteration step.
@end itemize
@end deftp

@anchor{class-fl.iteration-<linear-iteration>}
@deftp Class <LINEAR-ITERATION>
@tindex <LINEAR-ITERATION>
The <linear-iteration> class.  Linear iterations are
e.g. <gauss-seidel> or <multigrid>.

Direct slots:
@itemize
@item DAMP: NIL
@end itemize
@end deftp

@anchor{class-fl.iteration-<linear-solver>}
@deftp Class <LINEAR-SOLVER>
@tindex <LINEAR-SOLVER>
Class for linear iterative solvers.

Superclasses: <DISCRETE-ITERATIVE-SOLVER>

Direct slots:
@itemize
@item ITERATION: The inner iteration.
@end itemize
@end deftp

@anchor{class-fl.iteration-<lu>}
@deftp Class <LU>
@tindex <LU>
A linear iteration interface for the LU exact solver.

Superclasses: <LINEAR-ITERATION>

Direct slots:
@itemize
@item STORE-P: Store decomposition for multiple applications.
@end itemize
@end deftp

@anchor{class-fl.iteration-<multi-iteration>}
@deftp Class <MULTI-ITERATION>
@tindex <MULTI-ITERATION>
One step of this iteration performs nr-steps of the base
iteration.

Superclasses: <LINEAR-ITERATION>

Direct slots:
@itemize
@item BASE: Base iteration.
@item NR-STEPS: Number of steps with which the base iteration
is performed.
@end itemize
@end deftp

@anchor{class-fl.iteration-<newton>}
@deftp Class <NEWTON>
@tindex <NEWTON>
Class for the Newton iteration.

Superclasses: <NONLINEAR-SOLVER>
@end deftp

@anchor{class-fl.iteration-<psc>}
@deftp Class <PSC>
@tindex <PSC>
Parallel subspace correction scheme.

Superclasses: <BLOCK-ITERATION>
@end deftp

@anchor{class-fl.iteration-<safe-linear-solver>}
@deftp Class <SAFE-LINEAR-SOLVER>
@tindex <SAFE-LINEAR-SOLVER>
If failure occurs, object of this class try an
alternative iteration.  Usually this will be a direct decomposition.

Superclasses: <LINEAR-SOLVER>

Direct slots:
@itemize
@item FALLBACK: The fallback iteration.
@end itemize
@end deftp

@anchor{class-fl.iteration-<special-solver>}
@deftp Class <SPECIAL-SOLVER>
@tindex <SPECIAL-SOLVER>
If you happen to have a problem-adapted solver given as
a function, you may use this base class.

Superclasses: <ITERATIVE-SOLVER>

Direct slots:
@itemize
@item SOLVER-FUNCTION: NIL
@end itemize
@end deftp

@anchor{class-fl.iteration-<ssc>}
@deftp Class <SSC>
@tindex <SSC>
Successive subspace correction scheme.

Superclasses: <BLOCK-ITERATION>

Direct slots:
@itemize
@item OMEGA: NIL
@end itemize
@end deftp

@anchor{fun-fl.iteration-evaluate}
@deffn Function EVALUATE @var{DOF} @var{FE-FUNC}
@findex EVALUATE
Generic evaluation of functions on an argument.  Numbers and
arrays are treated as constants.  Special evaluation is defined for multivariate
polynomials on vectors and for <function> objects.
@end deffn

@anchor{fun-fl.iteration-evaluate-gradient}
@deffn Function EVALUATE-GRADIENT @var{POLYGON} @var{S}
@findex EVALUATE-GRADIENT
Generic evaluation of gradients of differentiable functions.
@end deffn

@anchor{fun-fl.iteration-finally}
@deffn Function FINALLY @var{ITSOLVE} @var{BLACKBOARD}
@findex FINALLY
Performs final operations.
@end deffn

@anchor{fun-fl.iteration-initially}
@deffn Function INITIALLY @var{ROTHE} @var{BLACKBOARD}
@findex INITIALLY
Performs initial operations.
@end deffn

@anchor{fun-fl.iteration-intermediate}
@deffn Function INTERMEDIATE @var{ROTHE} @var{BLACKBOARD}
@findex INTERMEDIATE
Is called after initialization and after each step.
@end deffn

@anchor{fun-fl.iteration-interval-method}
@deffn Function INTERVAL-METHOD @var{FUNC} @var{A} @var{B} @var{ACCURACY}
@findex INTERVAL-METHOD
Finds zeros of functions in 1d by the interval method.
@end deffn

@anchor{fun-fl.iteration-iterate}
@deffn Function ITERATE @var{ITER} @var{BLACKBOARD}
@findex ITERATE
Iterates on the data in the blackboard according to the
iteration iter.
@end deffn

@anchor{fun-fl.iteration-linsolve}
@deffn Function LINSOLVE @var{MAT} @var{RHS} &KEY @var{SOL} @var{RES} @var{OUTPUT} @var{ITERATION} (@var{RESIDUAL-NORM} (@var{FUNCTION} @var{NORM})) (@var{THRESHOLD} 1.e-12) @var{REDUCTION} (@var{MAXSTEPS} 100) @var{SUCCESS-IF} @var{FAILURE-IF} &ALLOW-OTHER-KEYS
@findex LINSOLVE
Old and deprecated interface for solving linear problems.
@end deffn

@anchor{fun-fl.iteration-lu-solver}
@deffn Function LU-SOLVER &KEY (@var{OUTPUT} @var{NIL} @var{OUTPUT-P})
@findex LU-SOLVER
LU decomposition without pivoting.
@end deffn

@anchor{fun-fl.iteration-make-iterator}
@deffn Function MAKE-ITERATOR @var{S1-CGIT} @var{A}
@findex MAKE-ITERATOR
Constructs an iterator object given a linear iteration
and a matrix.
@end deffn

@anchor{fun-fl.iteration-next-step}
@deffn Function NEXT-STEP @var{ROTHE} @var{BLACKBOARD}
@findex NEXT-STEP
Does a step of the iteration.
@end deffn

@anchor{fun-fl.iteration-product-iterator}
@deffn Function PRODUCT-ITERATOR @var{ITERATOR} @var{NR-STEPS}
@findex PRODUCT-ITERATOR
Returns an iterator which does several steps of the given iterator.
@end deffn

@anchor{fun-fl.iteration-setup-blocks}
@deffn Function SETUP-BLOCKS @var{VANKA} @var{ASA}
@findex SETUP-BLOCKS
Setup routine for determining the blocking of unknowns.
Returns a list of blocks where each block is a vector of keys.  May return
a second value which is a list of pair.  Each pair is of the form
start-index/end-index and can be used to filter out different fe
components.
@end deffn

@anchor{fun-fl.iteration-terminate-p}
@deffn Function TERMINATE-P @var{FE-STRATEGY} @var{BLACKBOARD}
@findex TERMINATE-P
Tests terminating conditions.  Returns either NIL or
:success or :failure.
@end deffn

@node Package FL.MULTIGRID, Package FL.GEOMG, Package FL.ITERATION, Reference manual
@section Package FL.MULTIGRID

This package contains the definition of the multigrid
iteration including algebraic multigrid (AMG).

@anchor{class-fl.multigrid-<correction-scheme>}
@deftp Class <CORRECTION-SCHEME>
@tindex <CORRECTION-SCHEME>
This is a mixin-class which yields the correction
scheme.  It should be merged !before! <mg-iteration> for standard CLOS
class precedence.
@end deftp

@anchor{class-fl.multigrid-<fas>}
@deftp Class <FAS>
@tindex <FAS>
This is a mixin-class for <mg-iteration> which yields
the behaviour of Brandt's FAS scheme.  It should be merged !before!
<mg-iteration> or the derived class <geometric-mg> when using standard CLOS
class precedence.
@end deftp

@anchor{class-fl.multigrid-<mg-iteration>}
@deftp Class <MG-ITERATION>
@tindex <MG-ITERATION>
The multigrid iteration is a linear iteration specially
suited for the solution of systems of equations with elliptic terms.  In
ideal situations, it solves such systems with optimal complexity.  It is a
complicated linear iteration, which consists of applying simple linear
iterators as smoothers on a hierarchy of grids.  This grid hierarchy is
obtained either by discretizing on successively refined meshes (geometric
multigrid) or it is constructed from matrix information alone (algebraic
multigrid).

The <mg-iteration> is not intended to be used directly.  Only incorporating
mixins like <correction-scheme> or <fas> results in concrete classes like
<algebraic-mg>.

Superclasses: <LINEAR-ITERATION>

Direct slots:
@itemize
@item PRE-SMOOTHER: NIL
@item PRE-STEPS: NIL
@item POST-SMOOTHER: NIL
@item POST-STEPS: NIL
@item GAMMA: NIL
@item BASE-LEVEL: NIL
@item COARSE-GRID-ITERATION: NIL
@item FMG: NIL
@item COMBINATION: Switch between additive and multiplicative
combination of corrections from different levels.  The additive version
should be used as a preconditioner.
@end itemize
@end deftp

@anchor{class-fl.multigrid-<selection-amg>}
@deftp Class <SELECTION-AMG>
@tindex <SELECTION-AMG>
This variant of algebraic multigrid coarsens in a
special way by selecting coarse-grid nodes from the fine-grid nodes.  This
selection is kept in a table, which is then used by the method build-ip to
build the actual interpolation matrix.

Superclasses: <ALGEBRAIC-MG>
@end deftp

@anchor{class-fl.multigrid-<stueben>}
@deftp Class <STUEBEN>
@tindex <STUEBEN>
This provides something like Stueben's variant for
selection amg.  The original Ruge-Stueben algorithm was developed further
since 1987 by Klaus Stueben and collaborators.  These developments are
published in ....  The algorithm implemented here uses their ideas, but
does not claim to be equivalent to their code which can be bought at SCAI,
St. Augustin, Germany.  At this point, I want to thank Tanja Clees
for several discussions on AMG.

Superclasses: <SELECTION-AMG>

Direct slots:
@itemize
@item THETA: NIL
@end itemize
@end deftp

@anchor{fun-fl.multigrid-coarse-grid-matrix}
@deffn Function COARSE-GRID-MATRIX @var{AMG} @var{A} @var{P} @var{R}
@findex COARSE-GRID-MATRIX
Computes a coarse-grid matrix from amg, mat,
prolongation and restriction.
@end deffn

@anchor{fun-fl.multigrid-coarsen}
@deffn Function COARSEN @var{AMG} @var{MAT}
@findex COARSEN
Given AMG and matrix, this generic function returns
coarse-grid matrix, interpolation and restriction matrices for one coarsening
step.
@end deffn

@anchor{fun-fl.multigrid-dirichlet-dof-p}
@deffn Function DIRICHLET-DOF-P @var{KEY} @var{MAT}
@findex DIRICHLET-DOF-P
Checks if key does not depend on other keys, so that it can be kept on
the fine grid.
@end deffn

@anchor{fun-fl.multigrid-galerkin-product}
@deffn Function GALERKIN-PRODUCT @var{R} @var{A} @var{P}
@findex GALERKIN-PRODUCT
Builds the Galerkin product R A P.  This function works for every type
of matrices for which the row- and column-loop macros are defined.  This
procedure should be inlined into an environment where types are known for
avoiding generic arithmetic.
@end deffn

@anchor{fun-fl.multigrid-multilevel-decomposition}
@deffn Function MULTILEVEL-DECOMPOSITION @var{MGIT} @var{MAT}
@findex MULTILEVEL-DECOMPOSITION
The central generic function constructing the multilevel
hierarchy.
@end deffn

@anchor{fun-fl.multigrid-preprocess-matrix}
@deffn Function PREPROCESS-MATRIX @var{AMG} @var{MAT}
@findex PREPROCESS-MATRIX
Eliminates Dirichlet or slave degrees of freedom which
can be handled well by smoothing.
@end deffn

@anchor{fun-fl.multigrid-prolongation}
@deffn Function PROLONGATION @var{AMG} @var{MAT}
@findex PROLONGATION
Computes a prolongation matrix from amg and mat.  This
is often the essence of an AMG method.
@end deffn

@anchor{fun-fl.multigrid-restriction}
@deffn Function RESTRICTION @var{AMG} @var{MAT} @var{PROL}
@findex RESTRICTION
Compute a restriction matrix from amg, mat and
prolongation.
@end deffn

@anchor{fun-fl.multigrid-select-smoother}
@deffn Function SELECT-SMOOTHER @var{MGIT} @var{MSP}
@findex SELECT-SMOOTHER
Select a suitable smoother depending on multigrid
iteration and matrix.
@end deffn

@anchor{fun-fl.multigrid-slave-dof-p}
@deffn Function SLAVE-DOF-P @var{KEY} @var{MAT}
@findex SLAVE-DOF-P
Checks if nothing depends on key and if key depends on other keys.
@end deffn

@anchor{fun-fl.multigrid-slave-or-dirichlet-dof-p}
@deffn Function SLAVE-OR-DIRICHLET-DOF-P @var{KEY} @var{MAT}
@findex SLAVE-OR-DIRICHLET-DOF-P
Checks if key is a hanging node or a Dirichlet node.
@end deffn

@node Package FL.GEOMG, Package FL.STRATEGY, Package FL.MULTIGRID, Reference manual
@section Package FL.GEOMG

The @package{FL.GEOMG} package contains iterations which
depend on geometric information, obtained for example from the
discretization.  At the moment, these are the geometric multigrid
iteration, an AMG-like scheme for preconditioning high-order
discretizations with low-order ones, and some block smoothers with
overlapping blocks.

@anchor{class-fl.geomg-<geometric-cs>}
@deftp Class <GEOMETRIC-CS>
@tindex <GEOMETRIC-CS>
Geometric multigrid of correction scheme type.

Superclasses: <CORRECTION-SCHEME> <GEOMETRIC-MG>
@end deftp

@anchor{class-fl.geomg-<geometric-fas>}
@deftp Class <GEOMETRIC-FAS>
@tindex <GEOMETRIC-FAS>
Brandt's FAS scheme approximates the unknowns on every
level instead of using corrections.  This requires slightly more work, but
is better suited for handling nonlinear problems and local refinements.

Superclasses: <FAS> <GEOMETRIC-MG>
@end deftp

@anchor{class-fl.geomg-<geometric-psc>}
@deftp Class <GEOMETRIC-PSC>
@tindex <GEOMETRIC-PSC>
PSC with geometry-based block choice.

Superclasses: <GEOMETRIC-BLOCKING-MIXIN> <PSC>
@end deftp

@anchor{class-fl.geomg-<geometric-ssc>}
@deftp Class <GEOMETRIC-SSC>
@tindex <GEOMETRIC-SSC>
SSC with geometry-based block choice.

Superclasses: <GEOMETRIC-BLOCKING-MIXIN> <SSC>
@end deftp

@anchor{class-fl.geomg-<s1-coarse-grid-iterator>}
@deftp Class <S1-COARSE-GRID-ITERATOR>
@tindex <S1-COARSE-GRID-ITERATOR>
Calls LU directly, if the matrix was not reduced to S1
which may happen if there are only Dirichlet vertices.

Superclasses: <LINEAR-ITERATION>
@end deftp

@anchor{class-fl.geomg-<s1-reduction>}
@deftp Class <S1-REDUCTION>
@tindex <S1-REDUCTION>
This class is useful for reducing a higher-order FE
discretization to a first-order FE discretization.  This can afterwards be
treated by ordinary AMG steps.  Even if it has the structure of a
<selection-amg>, it is far from being a pure algebraic multigrid.

Superclasses: <SELECTION-AMG>
@end deftp

@anchor{class-fl.geomg-<vanka>}
@deftp Class <VANKA>
@tindex <VANKA>
Vanka-like smoother for @math{Q^{k+1}/Q^k}
discretizations of Navier-Stokes.

Superclasses: <GEOMETRIC-SSC>
@end deftp

@anchor{fun-fl.geomg-fas}
@deffn Function FAS &REST @var{KEY-ARGS}
@findex FAS
Constructor of a geometric multigrid iteration of FAS type.
@end deffn

@anchor{fun-fl.geomg-geometric-cs}
@deffn Function GEOMETRIC-CS &REST @var{KEY-ARGS}
@findex GEOMETRIC-CS
Constructor of a geometric multigrid iteration of correction scheme
type.
@end deffn

@anchor{fun-fl.geomg-geometric-psc}
@deffn Function GEOMETRIC-PSC &REST @var{REST}
@findex GEOMETRIC-PSC
Constructor of a geometric parallel subspace correction.
@end deffn

@anchor{fun-fl.geomg-geometric-ssc}
@deffn Function GEOMETRIC-SSC &REST @var{REST}
@findex GEOMETRIC-SSC
Constructor of a geometric successive subspace correction.
@end deffn

@anchor{fun-fl.geomg-s1-reduction-amg-solver}
@deffn Function S1-REDUCTION-AMG-SOLVER @var{ORDER} &KEY @var{OUTPUT} @var{REDUCTION} (@var{MAXSTEPS} 100)
@findex S1-REDUCTION-AMG-SOLVER
This is an AMG solver which works also for Lagrange fe of order p by
reducing them to P^1 first.
@end deffn

@node Package FL.STRATEGY, Package FL.GRAPHIC, Package FL.GEOMG, Reference manual
@section Package FL.STRATEGY

This package provides methods for solving problems by
adaptive FEM.

@anchor{var-fl.strategy-*eta-observe*}
@defvr Variable *ETA-OBSERVE*
@vindex *ETA-OBSERVE*
Observe an estimate of the global error.
@end defvr

@anchor{var-fl.strategy-*stationary-fe-strategy-observe*}
@defvr Variable *STATIONARY-FE-STRATEGY-OBSERVE*
@vindex *STATIONARY-FE-STRATEGY-OBSERVE*
Standard observe quantities for stationary finite element strategies.
@end defvr

@anchor{class-fl.strategy-<duality-error-estimator>}
@deftp Class <DUALITY-ERROR-ESTIMATOR>
@tindex <DUALITY-ERROR-ESTIMATOR>
Estimates the error by testing the difference z-IPz
against the residual.  Here z is the solution of a dual problem in an
enriched finite element space.

Superclasses: <SETUP-ENRICHED-ANSATZ-SPACE> <SOLVE-DUAL-PROBLEM> <LOCAL-TEST-WITH-DUAL> <STANDARD-ERROR-ESTIMATOR>
@end deftp

@anchor{class-fl.strategy-<fe-approximation>}
@deftp Class <FE-APPROXIMATION>
@tindex <FE-APPROXIMATION>
This class describes iterative finite element
appoximation strategies.

Superclasses: <STRATEGY>

Direct slots:
@itemize
@item OBSERVE: Providing initform for <iteration> slot.
@item PLOT-MESH: Plot the mesh at the beginning and after changes.  Can
be a function in which case it is called on the mesh to do the plotting.
@item FE-CLASS: The class of finite element.  If it is not set, it is
automatically chosen.
@item ESTIMATOR: The error estimator, which computes information on the error
distribution in a hash-table in the :ETA-field on the blackboard, as well
as a global estimate in :GLOBAL-ETA which can be used to terminate the
iteration.
@item INDICATOR: The error indicator which marks cells for local refinement.
Usually, this procedure will be based on the error distribution
approximated in the :ETA-field on the blackboard.
@end itemize
@end deftp

@anchor{class-fl.strategy-<fe-interpolation>}
@deftp Class <FE-INTERPOLATION>
@tindex <FE-INTERPOLATION>
This class implements adaptive finite element
interpolation of the given coefficient function as a variant of finite
element approximation.

Superclasses: <FE-APPROXIMATION>

Direct slots:
@itemize
@item COEFFICIENT: A coefficient determining the function to be interpolated.
@end itemize
@end deftp

@anchor{class-fl.strategy-<largest-eta-indicator>}
@deftp Class <LARGEST-ETA-INDICATOR>
@tindex <LARGEST-ETA-INDICATOR>
Puts the fraction of the cells with the largest error
contributions in the refinement table.  Note that a fraction of 1.0 yields
uniform refinement.  Below from-level, global refinement is used.  block-p
indicates that all children of a parent cell have to be refined at once.

Superclasses: <REFINEMENT-INDICATOR>

Direct slots:
@itemize
@item FRACTION: NIL
@item PIVOT-FACTOR: NIL
@item FROM-LEVEL: NIL
@item BLOCK-P: NIL
@end itemize
@end deftp

@anchor{class-fl.strategy-<projection-error-estimator>}
@deftp Class <PROJECTION-ERROR-ESTIMATOR>
@tindex <PROJECTION-ERROR-ESTIMATOR>
Estimates the error by measuring the difference between
the solution and a projected solution in a hierarchical mesh by a certain
norm given by local-p and global-p.

Superclasses: <DIFFERENCE-WITH-PROJECTION> <GLOBAL-AND-LOCAL-NORM> <STANDARD-ERROR-ESTIMATOR>
@end deftp

@anchor{class-fl.strategy-<refinement-indicator>}
@deftp Class <REFINEMENT-INDICATOR>
@tindex <REFINEMENT-INDICATOR>
An indicator is used as first argument in the generic
functions indicate which works on a blackboard.  Based on the
quantities computed by an error estimator, i.e. eta, indicate puts a list
of elements to be refined on the blackboard.  When ensure-mesh-quality
is t, the indicator ensures that the difference of mesh widths of
neighboring cells does not become larger than a factor of 4.

Direct slots:
@itemize
@item ENSURE-MESH-QUALITY: NIL
@end itemize
@end deftp

@anchor{class-fl.strategy-<region-indicator>}
@deftp Class <REGION-INDICATOR>
@tindex <REGION-INDICATOR>
Marks all cells in a region for refinement.

Superclasses: <REFINEMENT-INDICATOR>

Direct slots:
@itemize
@item IN-REGION: NIL
@end itemize
@end deftp

@anchor{class-fl.strategy-<rothe>}
@deftp Class <ROTHE>
@tindex <ROTHE>
Rothe strategy for time-dependent problems.  The idea of
the Rothe method for solving @math{U_t +A U =f} is to do an ODE
time-stepping scheme in an infinite-dimensional function space.  Therefore,
in every time-step, the solution has to be approximated sufficiently well
in the space variable.

Superclasses: <ITERATION>

Direct slots:
@itemize
@item MODEL-TIME: Current time in the time-stepping scheme.
@item TIME-STEP: NIL
@item SCHEME: Time-stepping scheme,
e.g. @code{:implicit-euler} or @code{:crank-nicolson}.
@item STATIONARY-SUCCESS-IF: NIL
@item STATIONARY-FAILURE-IF: NIL
@item PLOT: NIL
@item OBSERVE: Providing initform for <iteration> slot.
@end itemize
@end deftp

@anchor{class-fl.strategy-<stationary-fe-strategy>}
@deftp Class <STATIONARY-FE-STRATEGY>
@tindex <STATIONARY-FE-STRATEGY>
This class describes some iterative finite element
solution strategies for continuous, stationary PDE problems.

Superclasses: <FE-APPROXIMATION>

Direct slots:
@itemize
@item OBSERVE: NIL
@item SOLVER: The solver for solving the discretized systems.
@end itemize
@end deftp

@anchor{class-fl.strategy-<strategy>}
@deftp Class <STRATEGY>
@tindex <STRATEGY>
A strategy is an iteration for solving a problem defined
on a blackboard.

Superclasses: <ITERATIVE-SOLVER>
@end deftp

@anchor{class-fl.strategy-<uniform-refinement-indicator>}
@deftp Class <UNIFORM-REFINEMENT-INDICATOR>
@tindex <UNIFORM-REFINEMENT-INDICATOR>
Marks all cells for refinement.

Superclasses: <REFINEMENT-INDICATOR>
@end deftp

@anchor{fun-fl.strategy-estimate}
@deffn Function ESTIMATE @var{ERREST} @var{BLACKBOARD}
@findex ESTIMATE
Yields both local and global estimate.
@end deffn

@anchor{fun-fl.strategy-indicate}
@deffn Function INDICATE @var{INDICATOR} @var{BLACKBOARD}
@findex INDICATE
Puts a list of elements to be refined on the blackboard.
@end deffn

@node Package FL.GRAPHIC, Package FL.PLOT, Package FL.STRATEGY, Reference manual
@section Package FL.GRAPHIC

This package provides a low-level interface to external
graphic software; at the moment both IBM's @code{OpenDX} and @code{Gnuplot}
are supported.

@anchor{var-fl.graphic-*default-graphic-program*}
@defvr Variable *DEFAULT-GRAPHIC-PROGRAM*
@vindex *DEFAULT-GRAPHIC-PROGRAM*
Default graphics program.
@end defvr

@anchor{fun-fl.graphic-graphic-commands}
@deffn Function GRAPHIC-COMMANDS @var{ASA} @var{PROGRAM} &ALLOW-OTHER-KEYS
@findex GRAPHIC-COMMANDS
Returns commands for plotting to be sent to the graphics
program.
@end deffn

@anchor{fun-fl.graphic-graphic-file-name}
@deffn Function GRAPHIC-FILE-NAME @var{OBJECT} @var{PROGRAM} &ALLOW-OTHER-KEYS
@findex GRAPHIC-FILE-NAME
Return a filename for the data of this plot.
@end deffn

@anchor{fun-fl.graphic-graphic-write-data}
@deffn Function GRAPHIC-WRITE-DATA @var{STREAM} @var{ASA} @var{PROGRAM} &KEY @var{DIMENSION} &ALLOW-OTHER-KEYS
@findex GRAPHIC-WRITE-DATA
Write the data file for @arg{program} to
@arg{stream}.
@end deffn

@anchor{fun-fl.graphic-send-graphic-commands}
@deffn Function SEND-GRAPHIC-COMMANDS @var{OBJECT} @var{PROGRAM} &REST @var{PARAS} &KEY (@var{OUTPUT} "gnuplot.ps") (@var{TERMINAL} "x11") (@var{TICS} @var{T}) (@var{BORDER} @var{T}) @var{BOTTOM} @var{TOP} @var{RIGHT} @var{LEFT} &ALLOW-OTHER-KEYS
@findex SEND-GRAPHIC-COMMANDS
Routine for sending commands to the graphics server.
@end deffn

@node Package FL.PLOT, Package FL.DOMAINS, Package FL.GRAPHIC, Reference manual
@section Package FL.PLOT

This package provides a high-level interface to
plotting.  It defines a generic function @code{PLOT} which can be used to
plot several types of objects, e.g. cells, meshes, finite element and
coefficient functions.

@anchor{fun-fl.plot-plot}
@deffn Function PLOT @var{ASA} &REST @var{REST} &ALLOW-OTHER-KEYS
@findex PLOT
Plot is a generic function which dispatches depending on
the type of object it receives.  Its behaviour can additionally be modified
by keyword parameters.
@end deffn

@node Package FL.DOMAINS, Package FL.APPLICATION, Package FL.PLOT, Reference manual
@section Package FL.DOMAINS

Femlisp package for domain definitions.

@anchor{fun-fl.domains-bl-patch-on-artificial-boundary}
@deffn Function BL-PATCH-ON-ARTIFICIAL-BOUNDARY @var{BL-DOMAIN} @var{PATCH}
@findex BL-PATCH-ON-ARTIFICIAL-BOUNDARY
Returns the artificial boundary on which the distributional source
acts.
@end deffn

@anchor{fun-fl.domains-bl-patch-on-lower-boundary}
@deffn Function BL-PATCH-ON-LOWER-BOUNDARY @var{BL-DOMAIN} @var{PATCH}
@findex BL-PATCH-ON-LOWER-BOUNDARY
Returns T if the patch is on the lower oscillating boundary.
@end deffn

@anchor{fun-fl.domains-bl-patch-on-pellet-boundary}
@deffn Function BL-PATCH-ON-PELLET-BOUNDARY @var{BL-DOMAIN} @var{PATCH}
@findex BL-PATCH-ON-PELLET-BOUNDARY
Returns T if the patch is on the pellet.
@end deffn

@anchor{fun-fl.domains-bl-patch-on-upper-boundary}
@deffn Function BL-PATCH-ON-UPPER-BOUNDARY @var{BL-DOMAIN} @var{PATCH}
@findex BL-PATCH-ON-UPPER-BOUNDARY
Returns T if the patch is on the upper boundary.
@end deffn

@anchor{fun-fl.domains-n-cell-with-ball-hole}
@deffn Function N-CELL-WITH-BALL-HOLE @var{DIM} &KEY (@var{RADIUS} 0.25)
@findex N-CELL-WITH-BALL-HOLE
Generates an n-dimensional cell domain with an n-ball hole.
@end deffn

@anchor{fun-fl.domains-n-cell-with-ball-inlay}
@deffn Function N-CELL-WITH-BALL-INLAY @var{DIM} &KEY (@var{RADIUS} 0.25)
@findex N-CELL-WITH-BALL-INLAY
Generates an n-dimensional cell domain with an n-ball inlay.
@end deffn

@anchor{fun-fl.domains-n-cell-with-cubic-hole}
@deffn Function N-CELL-WITH-CUBIC-HOLE @var{DIM}
@findex N-CELL-WITH-CUBIC-HOLE
Generates an n-dimensional cell domain with an n-cube hole.
@end deffn

@anchor{fun-fl.domains-n-cell-with-cubic-inlay}
@deffn Function N-CELL-WITH-CUBIC-INLAY @var{DIM}
@findex N-CELL-WITH-CUBIC-INLAY
Generates an n-dimensional cell domain with an n-cube hole.
@end deffn

@anchor{fun-fl.domains-n-cell-with-ellipsoidal-hole}
@deffn Function N-CELL-WITH-ELLIPSOIDAL-HOLE @var{DIM} &KEY @var{A}
@findex N-CELL-WITH-ELLIPSOIDAL-HOLE
Generates an n-dimensional cell domain with an ellipsoidal hole.
@end deffn

@anchor{fun-fl.domains-n-cube-with-ball-hole}
@deffn Function N-CUBE-WITH-BALL-HOLE @var{DIM} &KEY (@var{RADIUS} 0.25)
@findex N-CUBE-WITH-BALL-HOLE
Generates an n-cube-domain with an n-ball hole using n-cube patches.
@end deffn

@anchor{fun-fl.domains-n-cube-with-ball-inlay}
@deffn Function N-CUBE-WITH-BALL-INLAY @var{DIM} &KEY (@var{RADIUS} 0.25)
@findex N-CUBE-WITH-BALL-INLAY
Generates an n-cube-domain with an n-ball inlay using n-cube patches.
@end deffn

@anchor{fun-fl.domains-n-cube-with-cubic-hole}
@deffn Function N-CUBE-WITH-CUBIC-HOLE @var{DIM}
@findex N-CUBE-WITH-CUBIC-HOLE
Generates an n-cube-domain with an n-cube hole.
@end deffn

@anchor{fun-fl.domains-n-cube-with-cubic-inlay}
@deffn Function N-CUBE-WITH-CUBIC-INLAY @var{DIM}
@findex N-CUBE-WITH-CUBIC-INLAY
Generates an n-cube-domain with an n-cube inlay.
@end deffn

@anchor{fun-fl.domains-n-cube-with-ellipsoidal-hole}
@deffn Function N-CUBE-WITH-ELLIPSOIDAL-HOLE @var{DIM} &KEY @var{A}
@findex N-CUBE-WITH-ELLIPSOIDAL-HOLE
Generates an n-cube-domain with an ellipsoidal hole satisfying (Ax,x)=1
using n-cube patches.
@end deffn

@anchor{fun-fl.domains-oscillating-boundary-domain}
@deffn Function OSCILLATING-BOUNDARY-DOMAIN @var{DIM} @var{F} &KEY @var{GRAD-F} (@var{UPPER} @var{T})
@findex OSCILLATING-BOUNDARY-DOMAIN
Returns a domain with an oscillating lower boundary at $x_n=-1$ where
the oscillation is defined by a scaling function $f$ with values in $R^+$.
Usually, also $grad-f$ should be provided, because it makes possible an
enhanced domain approximation.
@end deffn

@anchor{fun-fl.domains-patch-in-inlay-p}
@deffn Function PATCH-IN-INLAY-P @var{PATCH}
@findex PATCH-IN-INLAY-P
Checks if the patch is part of the inlay including its boundary.
@end deffn

@anchor{fun-fl.domains-patch-on-inner-boundary-p}
@deffn Function PATCH-ON-INNER-BOUNDARY-P @var{PATCH}
@findex PATCH-ON-INNER-BOUNDARY-P
Checks if the patch is part of the hole boundary.
@end deffn

@anchor{fun-fl.domains-patch-on-n-cube-boundary-p}
@deffn Function PATCH-ON-N-CUBE-BOUNDARY-P @var{PATCH}
@findex PATCH-ON-N-CUBE-BOUNDARY-P
Returns T, if the patch is on the boundary of the n-cube.
@end deffn

@anchor{fun-fl.domains-sinusoidal-bl-cell}
@deffn Function SINUSOIDAL-BL-CELL @var{DIM} &REST @var{REST} &KEY (@var{AMPLITUDE} 0.15) (@var{SHIFT} 1.0) &ALLOW-OTHER-KEYS
@findex SINUSOIDAL-BL-CELL
Returns a boundary layer cell with a sinusoidally oscillating lower
boundary.
@end deffn

@anchor{fun-fl.domains-spline-interpolated-bl-cell}
@deffn Function SPLINE-INTERPOLATED-BL-CELL @var{HEIGHTS}
@findex SPLINE-INTERPOLATED-BL-CELL
Boundary which is interpolated from heights.
@end deffn

@node Package FL.APPLICATION,  , Package FL.DOMAINS, Reference manual
@section Package FL.APPLICATION

This package uses most other Femlisp packages.  It is
meant to be the package a Femlisp user works in.

