;;; -*- mode: lisp; -*-

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; linit.lisp
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;
;;; Copyright (C) 2003 Nicolas Neuss, University of Heidelberg.
;;; All rights reserved.
;;; 
;;; Redistribution and use in source and binary forms, with or without
;;; modification, are permitted provided that the following conditions are
;;; met:
;;; 
;;; 1. Redistributions of source code must retain the above copyright
;;; notice, this list of conditions and the following disclaimer.
;;; 
;;; 2. Redistributions in binary form must reproduce the above copyright
;;; notice, this list of conditions and the following disclaimer in the
;;; documentation and/or other materials provided with the distribution.
;;; 
;;; THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED
;;; WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
;;; MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
;;; NO EVENT SHALL THE AUTHOR, THE UNIVERSITY OF HEIDELBERG OR OTHER
;;; CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
;;; EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
;;; PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
;;; PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
;;; LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
;;; NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
;;; SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(in-package :iterations)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Iteration interface
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defclass <iteration> ()
  ((damp :reader damping-factor :initform 1.0d0 :initarg :damp)
   (output :reader output :initform nil :initarg :output))
  (:documentation "The <iteration> base class."))

(defclass <linear-iteration> (<iteration>)
  ()
  (:documentation "The <linear-iteration> class.  Linear iterations are
e.g. <gauss-seidel>, <cg>, or <multigrid>."))

(defclass <iterator> ()
  ((matrix :reader matrix :initarg :matrix)
   (initialize :reader initialize :initarg :initialize :initform nil)
   (iterate :reader iterate :initarg :iterate :type function)
   (residual-before :reader residual-before :initarg :residual-before)
   (residual-after :reader residual-after :initarg :residual-after))
  (:documentation "An <iterator> object contains functions doing iteration
work or flags indicating which work has or has not to be done for calling
that iterator.  It is generated by the generic function make-iterator."))

(defgeneric make-iterator (linit mat)
  (:documentation "Constructs an iterator object given a linear iteration
and a matrix."))

(defun do-nothing-iterator (mat)
  (make-instance
   '<iterator>
   :matrix mat
   :residual-before nil
   :initialize nil
   :iterate #'(lambda (x b r) (declare (ignore b r)) x)
   :residual-after nil))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; residual computation
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defmethod compute-residual (A x b r)
  "Default method for residual computation.  Should work for everything for
which the blas operations copy! and gemm! are defined."
  (copy! b r)
  (gemm! -1.0d0 A x 1.0d0 r)
  r)

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; <multi-iteration>
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defclass <multi-iteration> (<linear-iteration>)
  ((base :accessor base-iteration :initarg :base)
   (nr-steps :accessor nr-steps :initarg :nr-steps))
  (:documentation "Each step of this iteration performs nr-steps of the
base iteration."))

(defun product-iterator (iterator nr-steps)
  "Returns an iterator which does several steps of the given iterator."
  (with-slots (matrix initialize iterate residual-before residual-after)
    iterator
    (cond ((= 0 nr-steps) (do-nothing-iterator (matrix iterator)))
	  ((= 1 nr-steps) iterator)
	  (t				; we build the product iterator
	   (make-instance
	    '<iterator>
	    :matrix matrix
	    :residual-before residual-before
	    :initialize initialize
	    :iterate
	    #'(lambda (x b r)
		(loop repeat nr-steps do
		      (funcall iterate x b r)
		      (when (and residual-before (not residual-after))
			(compute-residual matrix x b r))))
	    :residual-after residual-after)))))

(defmethod make-iterator ((multi-iter <multi-iteration>) mat)
  "Construct an iterator for a multi-iteration."
  (dbg :iter "making <multi-iteration>-iterator.")
  (product-iterator (make-iterator (base-iteration multi-iter) mat)
		    (nr-steps multi-iter)))

	  
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; LU decomposition
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defclass <lu> (<linear-iteration>)
  ((store-p :initarg store-p :initform t
	    :documentation "Store decomposition for multiple applications."))
  (:documentation "A linear iteration interface for the LU exact solver."))

(defmethod make-iterator ((linit <lu>) mat)
  "Default method for lu iteration."
  (let ((damp (damping-factor linit))
	lu ipiv)
    (when (slot-value linit 'store-p)
      (multiple-value-setq (lu ipiv) (getrf! (copy mat))))
    (make-instance
     '<iterator>
     :matrix mat
     :residual-before t
     :initialize nil
     :iterate
     #'(lambda (x b r)
	 (declare (ignore b))
	 (unless (slot-value linit 'store-p)
	   (multiple-value-setq (lu ipiv) (getrf! (copy mat))))
	 (getrs! lu ipiv r)
	 (x+=s*y x damp r))
     :residual-after nil)))

(defparameter *lu-iteration* (make-instance '<lu>))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; ILU decomposition
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defclass <ilu> (<linear-iteration>)
  ((omega :accessor ilu-omega :initform 0.0d0 :initarg :omega)
   (eta :accessor ilu-eta :initform 0.0d0 :initarg :eta)
   (ordering :accessor ordering :initform () :initarg :ordering :type list))
  (:documentation "Incomplete LU iteration.  omega is the modification
parameter, eta is the diagonal enhancement."))

(defmethod make-iterator ((linit <ilu>) mat)
  "Default method for ILU iteration.  Works only for our sparse matrices."
  (let ((damp (damping-factor linit))
	(ldu (sparse-ldu mat :ordering (ordering linit) :incomplete t
			 :omega (ilu-omega linit) :diagonal-inverter
			 (shift-diagonal-inverter (ilu-eta linit)))))
      (make-instance
       '<iterator>
       :matrix mat
       :residual-before t
       :initialize nil
       :iterate #'(lambda (x b r)
		    (declare (type <sparse-vector> x b r))
		    (declare (optimize (speed 3) (safety 1)))
		    (declare (ignore b))
		    (let ((result (copy r)))
		      (x<-Ay result ldu r)
		      (x+=s*y x damp result)))
       :residual-after nil)))

(defparameter *standard-ilu* (make-instance '<ilu>))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Jacobi iteration
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defclass <jacobi> (<linear-iteration>))

(defmethod make-iterator ((jac <jacobi>) (mat standard-matrix))
  (let ((damp (damping-factor jac)))
    (make-instance
     '<iterator>
     :matrix mat
     :residual-before t
     :initialize nil
     :iterate
     #'(lambda (x b r)
	 (declare (ignore b))
	 (dotimes (i (nrows mat))
	   (let ((factor (/ damp (mat-ref mat i i))))
	     (dotimes (j (ncols r))
	       (incf (mat-ref x i j)
		     (* factor (mat-ref r i j)))))))
     :residual-after nil)))

(defmethod make-iterator ((jac <jacobi>) (mat <sparse-matrix>))
  (let ((damp (damping-factor jac)))
    (make-instance
     '<iterator>
     :matrix mat
     :residual-before t
     :initialize nil			; one could maybe store D^{-1} here
     :iterate
     #'(lambda (x b r)
	 (declare (ignore b))
	 (for-each-row-key
	  #'(lambda (row-key)
	      (let ((rblock (vec-ref r row-key)))
		(unless (= damp 1.0) (scal! damp rblock))
		(m/! (mat-ref mat row-key row-key) rblock)
		(m+! rblock (vec-ref x row-key))))
	  mat))
     :residual-after nil)))

(defparameter *undamped-jacobi* (make-instance '<jacobi>))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;; Gauss-Seidel and SOR iteration
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defclass <sor> (<linear-iteration>)
  ((omega :initform 1.0d0 :initarg :omega)
   (ordering :accessor ordering :initform () :initarg :ordering :type list)))

(defmethod make-iterator ((sor <sor>) (mat standard-matrix))
  (let ((omega (slot-value sor 'omega)))
    (make-instance
     '<iterator>
     :matrix mat
     :residual-before nil
     :initialize nil
     :iterate
     #'(lambda (x b r)
	 (declare (ignore r))
	 (dotimes (i (nrows mat))
	   (let ((factor (/ omega (mat-ref mat i i))))
	     (dotimes (j (ncols b))
	       (incf (mat-ref x i j)
		     (* factor
			(- (mat-ref b i j)
			   (loop for k from 0 below (ncols mat)
				 summing (* (mat-ref mat i k) (mat-ref x k j))))))))))
     :residual-after nil)))

(defmethod make-iterator ((sor <sor>) (mat <sparse-matrix>))
  (let ((omega (float (slot-value sor 'omega) 1.0d0))
	(diagonal-inverse (make-hash-table)))
    ;; store the inverse of the diagonal
    (for-each-row-key
     #'(lambda (row-key)
	 (setf (gethash row-key diagonal-inverse)
	       (m/ (mat-ref mat row-key row-key))))
     mat)
    (make-instance
     '<iterator>
     :matrix mat
     :residual-before nil
     :initialize nil
     :iterate
     #'(lambda (x b r)
	 (declare (type <sparse-vector> x b r))
	 (declare (ignore r))
	 (declare (optimize (speed 3) (safety 1)))
	 (for-each-row-key
	  #'(lambda (row-key)
	      (let ((corr (copy (vec-ref b row-key))))
		(for-each-key-and-entry-in-row
		 #'(lambda (col-key mblock)
		     ;;(gemm! -1.0d0 mblock (vec-ref x col-key) 1.0d0 corr)
		     (x-=Ay corr mblock (vec-ref x col-key)))
		 mat row-key)
		(gemm! omega (gethash row-key diagonal-inverse) corr
		       1.0d0 (matrix-ref x row-key))
		))
	  mat))
     :residual-after nil)))

(defclass <gauss-seidel> (<sor>)
  ()
  (:documentation "The Gauss-Seidel iteration is SOR with omega=1."))

(defmethod initialize-instance ((instance <gauss-seidel>) &rest initargs)
  (assert (not (getf initargs :omega)))
  (call-next-method))

(defparameter *gauss-seidel* (make-instance '<gauss-seidel>))

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;; Testing
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  
(defun test-linit ()
  "Most tests can be found in linsolve.lisp."
  (make-instance '<multi-iteration> :base *undamped-jacobi* :nr-steps 2))

;;; (test-linit)
(tests::adjoin-femlisp-test 'test-linit)
