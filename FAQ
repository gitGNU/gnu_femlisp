# -*- mode: text; -*-

Femlisp FAQ
-----------

* A: INSTALLATION AND GETTING STARTED

1. Q: On which architectures is Femlisp available?

   A: See the file INSTALL.

2. Q: What manuals and other introductory material are available?

   A: There is a short description of Femlisp in the doc-directory,
   unfortunately it is not really up-to-date anymore.  Additionally, you
   should know how to get documentation of functions and variables out of
   your Lisp environment.  I plan to have a real manual for Femlisp-1.0 in
   summer 2004.

3. Q: What is the best way to get started?

   A: Work through the demos to see what is possible.  The set up an own
   directory for yourself and try something like:

     (solve (cdr-problem dim) :success-if '(> :time 20.0))

   Plot the result using 
     (plot (getbb *result* :solution))

  Try to find out what SOLVE is doing here, then look at how the demos are
  done.  Try to modify the above problem by giving it a different
  right-hand side.


* B: MESH MANAGEMENT

1. Q: Which types of cells are available?

   A: Femlisp has simplices and simplex-product cells.  I.e. it has the
   interval in 1D, triangle and square in 2D, tetrahedron, prism, and cube
   in 3D, and so on for higher dimensions.  It does not have pyramids.  It
   would be rather easy to incorporate also those in the mesh module, but
   it is not clear to me how the construction should look like in higher
   dimensions.


* C: LINEAR ALGEBRA

1. Q: Why is Femlisp's linear algebra so slow?  Is this necessary?

   A: Because the sparse-matrix implementation is based on hash-tables
   indexed by mesh-entities like vertices, lines, ..., and each entry is
   again a block consisting of a matrix object.  This means that generic
   functions have to be used for handling those entries.  Unfortunately,
   the overhead for hash-table and method lookup is large, especially in
   the case of scalar equations with low-order discretizations.

2. Q: Is it possible to improve the linear algebra?

   A: It is possible to improve it by replacing the data structure by a
   more efficient array-based one where the operations are also specialized
   depending on the type of their entries.  I have started working on this
   and preliminary results look promising.  The result should be a
   matrix-vector data structure having most of the flexibility of the
   current approach while being as efficient as the usual CRS scheme.


* D: PROBLEMS

1. Q: How can I solve nonlinear problems?

   A: See the files src/applications/cdr/bratu.lisp and
   src/applications/navier-stokes/driven-cavity.lisp for examples how to
   solve nonlinear pdes by a Newton iteration and multigrid.

2. Q: How can I solve time-dependent problems?

   A: This is work in progress.  At the moment, you have still to set up
   your time-stepping scheme yourself by assembling a delta-t dependent
   term in matrix and right-hand side.


* E: DISCRETIZATION

1. Q: Is it possible to handle problems with more than one right-hand side
   with different choice of essential boundary?
   
   A: For the moment, no.  This feature needs that the system matrix is the
   same for every such right-hand-side.  Changes in the location of
   essential boundary require slightly different matrices which does not
   fit into this pattern.


* F: SOLVERS

1. Q: Is there a BiCGStab or GMRES iteration available?

   A: No, not yet.  For the problems I considered up to now, pure multigrid
   was sufficient.

2. Q: Wouldn't it be useful to include also an interface to Fortran/C++
   sparse matrix packages or sparse direct solvers like SuperLU?

   A: Up to now, I did not need it, but it would surely be a useful
   feature.


* G: PARALLELIZATION

1. Q: What about parallelization?

   A: This has not yet been started.  The first step will be to parallelize
   computationally intensive parts like mesh management, assembly, and
   iterative solvers on MISD architectures.  Parallelization for MIMD
   architectures is also possible using MPI or PVM, but would require a
   major restructuring.


* H: GENERAL

1. Q: How does Femlisp's compare with other programs wrt speed?

   A: This depends very much on the problem at hand.  Femlisp is still very
   slow for several standard problems.  On the other hand, it does also
   perform astonishingly well for other benchmark problems (compared with
   other unstructured-mesh FEM toolboxes).  Furthermore, most often the
   speed of program development is the decisive factor.  Here, Common Lisp
   cannot be beaten by statically typed languages like C++ or Fortran and
   differs often by an order of magnitude.

2. Q: Why is Femlisp slow for my problem?

   A: Please ask on the femlisp-user mailing list for optimization help.


